{"version":3,"file":"static/development/pages/composition.js","sources":["webpack:///./node_modules/@babel/runtime-corejs2/core-js/object/define-properties.js","webpack:///./node_modules/@babel/runtime-corejs2/core-js/object/define-property.js","webpack:///./node_modules/@babel/runtime-corejs2/core-js/object/get-own-property-descriptor.js","webpack:///./node_modules/@babel/runtime-corejs2/core-js/object/get-own-property-descriptors.js","webpack:///./node_modules/@babel/runtime-corejs2/core-js/object/get-own-property-symbols.js","webpack:///./node_modules/@babel/runtime-corejs2/core-js/object/keys.js","webpack:///./node_modules/@babel/runtime-corejs2/helpers/esm/classCallCheck.js","webpack:///./node_modules/@babel/runtime-corejs2/helpers/esm/createClass.js","webpack:///./node_modules/@babel/runtime-corejs2/helpers/esm/defineProperty.js","webpack:///./node_modules/core-js/library/fn/object/define-properties.js","webpack:///./node_modules/core-js/library/fn/object/define-property.js","webpack:///./node_modules/core-js/library/fn/object/get-own-property-descriptor.js","webpack:///./node_modules/core-js/library/fn/object/get-own-property-descriptors.js","webpack:///./node_modules/core-js/library/fn/object/get-own-property-symbols.js","webpack:///./node_modules/core-js/library/fn/object/keys.js","webpack:///./node_modules/core-js/library/modules/_a-function.js","webpack:///./node_modules/core-js/library/modules/_an-object.js","webpack:///./node_modules/core-js/library/modules/_array-includes.js","webpack:///./node_modules/core-js/library/modules/_cof.js","webpack:///./node_modules/core-js/library/modules/_core.js","webpack:///./node_modules/core-js/library/modules/_create-property.js","webpack:///./node_modules/core-js/library/modules/_ctx.js","webpack:///./node_modules/core-js/library/modules/_defined.js","webpack:///./node_modules/core-js/library/modules/_descriptors.js","webpack:///./node_modules/core-js/library/modules/_dom-create.js","webpack:///./node_modules/core-js/library/modules/_enum-bug-keys.js","webpack:///./node_modules/core-js/library/modules/_enum-keys.js","webpack:///./node_modules/core-js/library/modules/_export.js","webpack:///./node_modules/core-js/library/modules/_fails.js","webpack:///./node_modules/core-js/library/modules/_global.js","webpack:///./node_modules/core-js/library/modules/_has.js","webpack:///./node_modules/core-js/library/modules/_hide.js","webpack:///./node_modules/core-js/library/modules/_html.js","webpack:///./node_modules/core-js/library/modules/_ie8-dom-define.js","webpack:///./node_modules/core-js/library/modules/_iobject.js","webpack:///./node_modules/core-js/library/modules/_is-array.js","webpack:///./node_modules/core-js/library/modules/_is-object.js","webpack:///./node_modules/core-js/library/modules/_library.js","webpack:///./node_modules/core-js/library/modules/_meta.js","webpack:///./node_modules/core-js/library/modules/_object-create.js","webpack:///./node_modules/core-js/library/modules/_object-dp.js","webpack:///./node_modules/core-js/library/modules/_object-dps.js","webpack:///./node_modules/core-js/library/modules/_object-gopd.js","webpack:///./node_modules/core-js/library/modules/_object-gopn-ext.js","webpack:///./node_modules/core-js/library/modules/_object-gopn.js","webpack:///./node_modules/core-js/library/modules/_object-gops.js","webpack:///./node_modules/core-js/library/modules/_object-keys-internal.js","webpack:///./node_modules/core-js/library/modules/_object-keys.js","webpack:///./node_modules/core-js/library/modules/_object-pie.js","webpack:///./node_modules/core-js/library/modules/_object-sap.js","webpack:///./node_modules/core-js/library/modules/_own-keys.js","webpack:///./node_modules/core-js/library/modules/_property-desc.js","webpack:///./node_modules/core-js/library/modules/_redefine.js","webpack:///./node_modules/core-js/library/modules/_set-to-string-tag.js","webpack:///./node_modules/core-js/library/modules/_shared-key.js","webpack:///./node_modules/core-js/library/modules/_shared.js","webpack:///./node_modules/core-js/library/modules/_to-absolute-index.js","webpack:///./node_modules/core-js/library/modules/_to-integer.js","webpack:///./node_modules/core-js/library/modules/_to-iobject.js","webpack:///./node_modules/core-js/library/modules/_to-length.js","webpack:///./node_modules/core-js/library/modules/_to-object.js","webpack:///./node_modules/core-js/library/modules/_to-primitive.js","webpack:///./node_modules/core-js/library/modules/_uid.js","webpack:///./node_modules/core-js/library/modules/_wks-define.js","webpack:///./node_modules/core-js/library/modules/_wks-ext.js","webpack:///./node_modules/core-js/library/modules/_wks.js","webpack:///./node_modules/core-js/library/modules/es6.object.define-properties.js","webpack:///./node_modules/core-js/library/modules/es6.object.define-property.js","webpack:///./node_modules/core-js/library/modules/es6.object.get-own-property-descriptor.js","webpack:///./node_modules/core-js/library/modules/es6.object.keys.js","webpack:///./node_modules/core-js/library/modules/es6.symbol.js","webpack:///./node_modules/core-js/library/modules/es7.object.get-own-property-descriptors.js","webpack:///./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js","webpack:///delegated ./node_modules/react/index.js from dll-reference dll_ef0ff7c60362f24a921f","webpack:///./node_modules/taipa/lib/analyzer.js","webpack:///./node_modules/taipa/lib/character.js","webpack:///./node_modules/taipa/lib/client.js","webpack:///./node_modules/taipa/lib/document.js","webpack:///./node_modules/taipa/lib/dparser/analyzer.js","webpack:///./node_modules/taipa/lib/dparser/configuration.js","webpack:///./node_modules/taipa/lib/dparser/dictionary.js","webpack:///./node_modules/taipa/lib/dparser/guide.js","webpack:///./node_modules/taipa/lib/dparser/keywords.js","webpack:///./node_modules/taipa/lib/dparser/lexeme.js","webpack:///./node_modules/taipa/lib/dparser/morpheme.js","webpack:///./node_modules/taipa/lib/dparser/parser.js","webpack:///./node_modules/taipa/lib/dparser/phraseme.js","webpack:///./node_modules/taipa/lib/dparser/relation.js","webpack:///./node_modules/taipa/lib/dparser/rules.js","webpack:///./node_modules/taipa/lib/dparser/symbols.js","webpack:///./node_modules/taipa/lib/dparser/tagger.js","webpack:///./node_modules/taipa/lib/grapheme.js","webpack:///./node_modules/taipa/lib/index.js","webpack:///./node_modules/taipa/lib/kana/analyzer.js","webpack:///./node_modules/taipa/lib/kana/init.js","webpack:///./node_modules/taipa/lib/kana/kana.js","webpack:///./node_modules/taipa/lib/kana/morpheme.js","webpack:///./node_modules/taipa/lib/kana/soundgen.js","webpack:///./node_modules/taipa/lib/lexeme.js","webpack:///./node_modules/taipa/lib/morpheme.js","webpack:///./node_modules/taipa/lib/phraseme.js","webpack:///./node_modules/taipa/lib/token.js","webpack:///./node_modules/taipa/lib/tonal/analyzer.js","webpack:///./node_modules/taipa/lib/tonal/init.js","webpack:///./node_modules/taipa/lib/tonal/lexeme.js","webpack:///./node_modules/taipa/lib/tonal/lexicalroots2.js","webpack:///./node_modules/taipa/lib/tonal/matcher.js","webpack:///./node_modules/taipa/lib/tonal/morpheme.js","webpack:///./node_modules/taipa/lib/tonal/soundgen.js","webpack:///./node_modules/taipa/lib/tonal/version2.js","webpack:///./pages/composition.tsx","webpack:///external \"dll_ef0ff7c60362f24a921f\""],"sourcesContent":["module.exports = require(\"core-js/library/fn/object/define-properties\");","module.exports = require(\"core-js/library/fn/object/define-property\");","module.exports = require(\"core-js/library/fn/object/get-own-property-descriptor\");","module.exports = require(\"core-js/library/fn/object/get-own-property-descriptors\");","module.exports = require(\"core-js/library/fn/object/get-own-property-symbols\");","module.exports = require(\"core-js/library/fn/object/keys\");","export default function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}","import _Object$defineProperty from \"../../core-js/object/define-property\";\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n\n    _Object$defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nexport default function _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}","import _Object$defineProperty from \"../../core-js/object/define-property\";\nexport default function _defineProperty(obj, key, value) {\n  if (key in obj) {\n    _Object$defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}","require('../../modules/es6.object.define-properties');\nvar $Object = require('../../modules/_core').Object;\nmodule.exports = function defineProperties(T, D) {\n  return $Object.defineProperties(T, D);\n};\n","require('../../modules/es6.object.define-property');\nvar $Object = require('../../modules/_core').Object;\nmodule.exports = function defineProperty(it, key, desc) {\n  return $Object.defineProperty(it, key, desc);\n};\n","require('../../modules/es6.object.get-own-property-descriptor');\nvar $Object = require('../../modules/_core').Object;\nmodule.exports = function getOwnPropertyDescriptor(it, key) {\n  return $Object.getOwnPropertyDescriptor(it, key);\n};\n","require('../../modules/es7.object.get-own-property-descriptors');\nmodule.exports = require('../../modules/_core').Object.getOwnPropertyDescriptors;\n","require('../../modules/es6.symbol');\nmodule.exports = require('../../modules/_core').Object.getOwnPropertySymbols;\n","require('../../modules/es6.object.keys');\nmodule.exports = require('../../modules/_core').Object.keys;\n","module.exports = function (it) {\n  if (typeof it != 'function') throw TypeError(it + ' is not a function!');\n  return it;\n};\n","var isObject = require('./_is-object');\nmodule.exports = function (it) {\n  if (!isObject(it)) throw TypeError(it + ' is not an object!');\n  return it;\n};\n","// false -> Array#indexOf\n// true  -> Array#includes\nvar toIObject = require('./_to-iobject');\nvar toLength = require('./_to-length');\nvar toAbsoluteIndex = require('./_to-absolute-index');\nmodule.exports = function (IS_INCLUDES) {\n  return function ($this, el, fromIndex) {\n    var O = toIObject($this);\n    var length = toLength(O.length);\n    var index = toAbsoluteIndex(fromIndex, length);\n    var value;\n    // Array#includes uses SameValueZero equality algorithm\n    // eslint-disable-next-line no-self-compare\n    if (IS_INCLUDES && el != el) while (length > index) {\n      value = O[index++];\n      // eslint-disable-next-line no-self-compare\n      if (value != value) return true;\n    // Array#indexOf ignores holes, Array#includes - not\n    } else for (;length > index; index++) if (IS_INCLUDES || index in O) {\n      if (O[index] === el) return IS_INCLUDES || index || 0;\n    } return !IS_INCLUDES && -1;\n  };\n};\n","var toString = {}.toString;\n\nmodule.exports = function (it) {\n  return toString.call(it).slice(8, -1);\n};\n","var core = module.exports = { version: '2.6.11' };\nif (typeof __e == 'number') __e = core; // eslint-disable-line no-undef\n","'use strict';\nvar $defineProperty = require('./_object-dp');\nvar createDesc = require('./_property-desc');\n\nmodule.exports = function (object, index, value) {\n  if (index in object) $defineProperty.f(object, index, createDesc(0, value));\n  else object[index] = value;\n};\n","// optional / simple context binding\nvar aFunction = require('./_a-function');\nmodule.exports = function (fn, that, length) {\n  aFunction(fn);\n  if (that === undefined) return fn;\n  switch (length) {\n    case 1: return function (a) {\n      return fn.call(that, a);\n    };\n    case 2: return function (a, b) {\n      return fn.call(that, a, b);\n    };\n    case 3: return function (a, b, c) {\n      return fn.call(that, a, b, c);\n    };\n  }\n  return function (/* ...args */) {\n    return fn.apply(that, arguments);\n  };\n};\n","// 7.2.1 RequireObjectCoercible(argument)\nmodule.exports = function (it) {\n  if (it == undefined) throw TypeError(\"Can't call method on  \" + it);\n  return it;\n};\n","// Thank's IE8 for his funny defineProperty\nmodule.exports = !require('./_fails')(function () {\n  return Object.defineProperty({}, 'a', { get: function () { return 7; } }).a != 7;\n});\n","var isObject = require('./_is-object');\nvar document = require('./_global').document;\n// typeof document.createElement is 'object' in old IE\nvar is = isObject(document) && isObject(document.createElement);\nmodule.exports = function (it) {\n  return is ? document.createElement(it) : {};\n};\n","// IE 8- don't enum bug keys\nmodule.exports = (\n  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'\n).split(',');\n","// all enumerable object keys, includes symbols\nvar getKeys = require('./_object-keys');\nvar gOPS = require('./_object-gops');\nvar pIE = require('./_object-pie');\nmodule.exports = function (it) {\n  var result = getKeys(it);\n  var getSymbols = gOPS.f;\n  if (getSymbols) {\n    var symbols = getSymbols(it);\n    var isEnum = pIE.f;\n    var i = 0;\n    var key;\n    while (symbols.length > i) if (isEnum.call(it, key = symbols[i++])) result.push(key);\n  } return result;\n};\n","var global = require('./_global');\nvar core = require('./_core');\nvar ctx = require('./_ctx');\nvar hide = require('./_hide');\nvar has = require('./_has');\nvar PROTOTYPE = 'prototype';\n\nvar $export = function (type, name, source) {\n  var IS_FORCED = type & $export.F;\n  var IS_GLOBAL = type & $export.G;\n  var IS_STATIC = type & $export.S;\n  var IS_PROTO = type & $export.P;\n  var IS_BIND = type & $export.B;\n  var IS_WRAP = type & $export.W;\n  var exports = IS_GLOBAL ? core : core[name] || (core[name] = {});\n  var expProto = exports[PROTOTYPE];\n  var target = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE];\n  var key, own, out;\n  if (IS_GLOBAL) source = name;\n  for (key in source) {\n    // contains in native\n    own = !IS_FORCED && target && target[key] !== undefined;\n    if (own && has(exports, key)) continue;\n    // export native or passed\n    out = own ? target[key] : source[key];\n    // prevent global pollution for namespaces\n    exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key]\n    // bind timers to global for call from export context\n    : IS_BIND && own ? ctx(out, global)\n    // wrap global constructors for prevent change them in library\n    : IS_WRAP && target[key] == out ? (function (C) {\n      var F = function (a, b, c) {\n        if (this instanceof C) {\n          switch (arguments.length) {\n            case 0: return new C();\n            case 1: return new C(a);\n            case 2: return new C(a, b);\n          } return new C(a, b, c);\n        } return C.apply(this, arguments);\n      };\n      F[PROTOTYPE] = C[PROTOTYPE];\n      return F;\n    // make static versions for prototype methods\n    })(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;\n    // export proto methods to core.%CONSTRUCTOR%.methods.%NAME%\n    if (IS_PROTO) {\n      (exports.virtual || (exports.virtual = {}))[key] = out;\n      // export proto methods to core.%CONSTRUCTOR%.prototype.%NAME%\n      if (type & $export.R && expProto && !expProto[key]) hide(expProto, key, out);\n    }\n  }\n};\n// type bitmap\n$export.F = 1;   // forced\n$export.G = 2;   // global\n$export.S = 4;   // static\n$export.P = 8;   // proto\n$export.B = 16;  // bind\n$export.W = 32;  // wrap\n$export.U = 64;  // safe\n$export.R = 128; // real proto method for `library`\nmodule.exports = $export;\n","module.exports = function (exec) {\n  try {\n    return !!exec();\n  } catch (e) {\n    return true;\n  }\n};\n","// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028\nvar global = module.exports = typeof window != 'undefined' && window.Math == Math\n  ? window : typeof self != 'undefined' && self.Math == Math ? self\n  // eslint-disable-next-line no-new-func\n  : Function('return this')();\nif (typeof __g == 'number') __g = global; // eslint-disable-line no-undef\n","var hasOwnProperty = {}.hasOwnProperty;\nmodule.exports = function (it, key) {\n  return hasOwnProperty.call(it, key);\n};\n","var dP = require('./_object-dp');\nvar createDesc = require('./_property-desc');\nmodule.exports = require('./_descriptors') ? function (object, key, value) {\n  return dP.f(object, key, createDesc(1, value));\n} : function (object, key, value) {\n  object[key] = value;\n  return object;\n};\n","var document = require('./_global').document;\nmodule.exports = document && document.documentElement;\n","module.exports = !require('./_descriptors') && !require('./_fails')(function () {\n  return Object.defineProperty(require('./_dom-create')('div'), 'a', { get: function () { return 7; } }).a != 7;\n});\n","// fallback for non-array-like ES3 and non-enumerable old V8 strings\nvar cof = require('./_cof');\n// eslint-disable-next-line no-prototype-builtins\nmodule.exports = Object('z').propertyIsEnumerable(0) ? Object : function (it) {\n  return cof(it) == 'String' ? it.split('') : Object(it);\n};\n","// 7.2.2 IsArray(argument)\nvar cof = require('./_cof');\nmodule.exports = Array.isArray || function isArray(arg) {\n  return cof(arg) == 'Array';\n};\n","module.exports = function (it) {\n  return typeof it === 'object' ? it !== null : typeof it === 'function';\n};\n","module.exports = true;\n","var META = require('./_uid')('meta');\nvar isObject = require('./_is-object');\nvar has = require('./_has');\nvar setDesc = require('./_object-dp').f;\nvar id = 0;\nvar isExtensible = Object.isExtensible || function () {\n  return true;\n};\nvar FREEZE = !require('./_fails')(function () {\n  return isExtensible(Object.preventExtensions({}));\n});\nvar setMeta = function (it) {\n  setDesc(it, META, { value: {\n    i: 'O' + ++id, // object ID\n    w: {}          // weak collections IDs\n  } });\n};\nvar fastKey = function (it, create) {\n  // return primitive with prefix\n  if (!isObject(it)) return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;\n  if (!has(it, META)) {\n    // can't set metadata to uncaught frozen object\n    if (!isExtensible(it)) return 'F';\n    // not necessary to add metadata\n    if (!create) return 'E';\n    // add missing metadata\n    setMeta(it);\n  // return object ID\n  } return it[META].i;\n};\nvar getWeak = function (it, create) {\n  if (!has(it, META)) {\n    // can't set metadata to uncaught frozen object\n    if (!isExtensible(it)) return true;\n    // not necessary to add metadata\n    if (!create) return false;\n    // add missing metadata\n    setMeta(it);\n  // return hash weak collections IDs\n  } return it[META].w;\n};\n// add metadata on freeze-family methods calling\nvar onFreeze = function (it) {\n  if (FREEZE && meta.NEED && isExtensible(it) && !has(it, META)) setMeta(it);\n  return it;\n};\nvar meta = module.exports = {\n  KEY: META,\n  NEED: false,\n  fastKey: fastKey,\n  getWeak: getWeak,\n  onFreeze: onFreeze\n};\n","// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])\nvar anObject = require('./_an-object');\nvar dPs = require('./_object-dps');\nvar enumBugKeys = require('./_enum-bug-keys');\nvar IE_PROTO = require('./_shared-key')('IE_PROTO');\nvar Empty = function () { /* empty */ };\nvar PROTOTYPE = 'prototype';\n\n// Create object with fake `null` prototype: use iframe Object with cleared prototype\nvar createDict = function () {\n  // Thrash, waste and sodomy: IE GC bug\n  var iframe = require('./_dom-create')('iframe');\n  var i = enumBugKeys.length;\n  var lt = '<';\n  var gt = '>';\n  var iframeDocument;\n  iframe.style.display = 'none';\n  require('./_html').appendChild(iframe);\n  iframe.src = 'javascript:'; // eslint-disable-line no-script-url\n  // createDict = iframe.contentWindow.Object;\n  // html.removeChild(iframe);\n  iframeDocument = iframe.contentWindow.document;\n  iframeDocument.open();\n  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);\n  iframeDocument.close();\n  createDict = iframeDocument.F;\n  while (i--) delete createDict[PROTOTYPE][enumBugKeys[i]];\n  return createDict();\n};\n\nmodule.exports = Object.create || function create(O, Properties) {\n  var result;\n  if (O !== null) {\n    Empty[PROTOTYPE] = anObject(O);\n    result = new Empty();\n    Empty[PROTOTYPE] = null;\n    // add \"__proto__\" for Object.getPrototypeOf polyfill\n    result[IE_PROTO] = O;\n  } else result = createDict();\n  return Properties === undefined ? result : dPs(result, Properties);\n};\n","var anObject = require('./_an-object');\nvar IE8_DOM_DEFINE = require('./_ie8-dom-define');\nvar toPrimitive = require('./_to-primitive');\nvar dP = Object.defineProperty;\n\nexports.f = require('./_descriptors') ? Object.defineProperty : function defineProperty(O, P, Attributes) {\n  anObject(O);\n  P = toPrimitive(P, true);\n  anObject(Attributes);\n  if (IE8_DOM_DEFINE) try {\n    return dP(O, P, Attributes);\n  } catch (e) { /* empty */ }\n  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');\n  if ('value' in Attributes) O[P] = Attributes.value;\n  return O;\n};\n","var dP = require('./_object-dp');\nvar anObject = require('./_an-object');\nvar getKeys = require('./_object-keys');\n\nmodule.exports = require('./_descriptors') ? Object.defineProperties : function defineProperties(O, Properties) {\n  anObject(O);\n  var keys = getKeys(Properties);\n  var length = keys.length;\n  var i = 0;\n  var P;\n  while (length > i) dP.f(O, P = keys[i++], Properties[P]);\n  return O;\n};\n","var pIE = require('./_object-pie');\nvar createDesc = require('./_property-desc');\nvar toIObject = require('./_to-iobject');\nvar toPrimitive = require('./_to-primitive');\nvar has = require('./_has');\nvar IE8_DOM_DEFINE = require('./_ie8-dom-define');\nvar gOPD = Object.getOwnPropertyDescriptor;\n\nexports.f = require('./_descriptors') ? gOPD : function getOwnPropertyDescriptor(O, P) {\n  O = toIObject(O);\n  P = toPrimitive(P, true);\n  if (IE8_DOM_DEFINE) try {\n    return gOPD(O, P);\n  } catch (e) { /* empty */ }\n  if (has(O, P)) return createDesc(!pIE.f.call(O, P), O[P]);\n};\n","// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window\nvar toIObject = require('./_to-iobject');\nvar gOPN = require('./_object-gopn').f;\nvar toString = {}.toString;\n\nvar windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames\n  ? Object.getOwnPropertyNames(window) : [];\n\nvar getWindowNames = function (it) {\n  try {\n    return gOPN(it);\n  } catch (e) {\n    return windowNames.slice();\n  }\n};\n\nmodule.exports.f = function getOwnPropertyNames(it) {\n  return windowNames && toString.call(it) == '[object Window]' ? getWindowNames(it) : gOPN(toIObject(it));\n};\n","// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)\nvar $keys = require('./_object-keys-internal');\nvar hiddenKeys = require('./_enum-bug-keys').concat('length', 'prototype');\n\nexports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {\n  return $keys(O, hiddenKeys);\n};\n","exports.f = Object.getOwnPropertySymbols;\n","var has = require('./_has');\nvar toIObject = require('./_to-iobject');\nvar arrayIndexOf = require('./_array-includes')(false);\nvar IE_PROTO = require('./_shared-key')('IE_PROTO');\n\nmodule.exports = function (object, names) {\n  var O = toIObject(object);\n  var i = 0;\n  var result = [];\n  var key;\n  for (key in O) if (key != IE_PROTO) has(O, key) && result.push(key);\n  // Don't enum bug & hidden keys\n  while (names.length > i) if (has(O, key = names[i++])) {\n    ~arrayIndexOf(result, key) || result.push(key);\n  }\n  return result;\n};\n","// 19.1.2.14 / 15.2.3.14 Object.keys(O)\nvar $keys = require('./_object-keys-internal');\nvar enumBugKeys = require('./_enum-bug-keys');\n\nmodule.exports = Object.keys || function keys(O) {\n  return $keys(O, enumBugKeys);\n};\n","exports.f = {}.propertyIsEnumerable;\n","// most Object methods by ES6 should accept primitives\nvar $export = require('./_export');\nvar core = require('./_core');\nvar fails = require('./_fails');\nmodule.exports = function (KEY, exec) {\n  var fn = (core.Object || {})[KEY] || Object[KEY];\n  var exp = {};\n  exp[KEY] = exec(fn);\n  $export($export.S + $export.F * fails(function () { fn(1); }), 'Object', exp);\n};\n","// all object keys, includes non-enumerable and symbols\nvar gOPN = require('./_object-gopn');\nvar gOPS = require('./_object-gops');\nvar anObject = require('./_an-object');\nvar Reflect = require('./_global').Reflect;\nmodule.exports = Reflect && Reflect.ownKeys || function ownKeys(it) {\n  var keys = gOPN.f(anObject(it));\n  var getSymbols = gOPS.f;\n  return getSymbols ? keys.concat(getSymbols(it)) : keys;\n};\n","module.exports = function (bitmap, value) {\n  return {\n    enumerable: !(bitmap & 1),\n    configurable: !(bitmap & 2),\n    writable: !(bitmap & 4),\n    value: value\n  };\n};\n","module.exports = require('./_hide');\n","var def = require('./_object-dp').f;\nvar has = require('./_has');\nvar TAG = require('./_wks')('toStringTag');\n\nmodule.exports = function (it, tag, stat) {\n  if (it && !has(it = stat ? it : it.prototype, TAG)) def(it, TAG, { configurable: true, value: tag });\n};\n","var shared = require('./_shared')('keys');\nvar uid = require('./_uid');\nmodule.exports = function (key) {\n  return shared[key] || (shared[key] = uid(key));\n};\n","var core = require('./_core');\nvar global = require('./_global');\nvar SHARED = '__core-js_shared__';\nvar store = global[SHARED] || (global[SHARED] = {});\n\n(module.exports = function (key, value) {\n  return store[key] || (store[key] = value !== undefined ? value : {});\n})('versions', []).push({\n  version: core.version,\n  mode: require('./_library') ? 'pure' : 'global',\n  copyright: 'Â© 2019 Denis Pushkarev (zloirock.ru)'\n});\n","var toInteger = require('./_to-integer');\nvar max = Math.max;\nvar min = Math.min;\nmodule.exports = function (index, length) {\n  index = toInteger(index);\n  return index < 0 ? max(index + length, 0) : min(index, length);\n};\n","// 7.1.4 ToInteger\nvar ceil = Math.ceil;\nvar floor = Math.floor;\nmodule.exports = function (it) {\n  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);\n};\n","// to indexed object, toObject with fallback for non-array-like ES3 strings\nvar IObject = require('./_iobject');\nvar defined = require('./_defined');\nmodule.exports = function (it) {\n  return IObject(defined(it));\n};\n","// 7.1.15 ToLength\nvar toInteger = require('./_to-integer');\nvar min = Math.min;\nmodule.exports = function (it) {\n  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991\n};\n","// 7.1.13 ToObject(argument)\nvar defined = require('./_defined');\nmodule.exports = function (it) {\n  return Object(defined(it));\n};\n","// 7.1.1 ToPrimitive(input [, PreferredType])\nvar isObject = require('./_is-object');\n// instead of the ES6 spec version, we didn't implement @@toPrimitive case\n// and the second argument - flag - preferred type is a string\nmodule.exports = function (it, S) {\n  if (!isObject(it)) return it;\n  var fn, val;\n  if (S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;\n  if (typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it))) return val;\n  if (!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;\n  throw TypeError(\"Can't convert object to primitive value\");\n};\n","var id = 0;\nvar px = Math.random();\nmodule.exports = function (key) {\n  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));\n};\n","var global = require('./_global');\nvar core = require('./_core');\nvar LIBRARY = require('./_library');\nvar wksExt = require('./_wks-ext');\nvar defineProperty = require('./_object-dp').f;\nmodule.exports = function (name) {\n  var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global.Symbol || {});\n  if (name.charAt(0) != '_' && !(name in $Symbol)) defineProperty($Symbol, name, { value: wksExt.f(name) });\n};\n","exports.f = require('./_wks');\n","var store = require('./_shared')('wks');\nvar uid = require('./_uid');\nvar Symbol = require('./_global').Symbol;\nvar USE_SYMBOL = typeof Symbol == 'function';\n\nvar $exports = module.exports = function (name) {\n  return store[name] || (store[name] =\n    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));\n};\n\n$exports.store = store;\n","var $export = require('./_export');\n// 19.1.2.3 / 15.2.3.7 Object.defineProperties(O, Properties)\n$export($export.S + $export.F * !require('./_descriptors'), 'Object', { defineProperties: require('./_object-dps') });\n","var $export = require('./_export');\n// 19.1.2.4 / 15.2.3.6 Object.defineProperty(O, P, Attributes)\n$export($export.S + $export.F * !require('./_descriptors'), 'Object', { defineProperty: require('./_object-dp').f });\n","// 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)\nvar toIObject = require('./_to-iobject');\nvar $getOwnPropertyDescriptor = require('./_object-gopd').f;\n\nrequire('./_object-sap')('getOwnPropertyDescriptor', function () {\n  return function getOwnPropertyDescriptor(it, key) {\n    return $getOwnPropertyDescriptor(toIObject(it), key);\n  };\n});\n","// 19.1.2.14 Object.keys(O)\nvar toObject = require('./_to-object');\nvar $keys = require('./_object-keys');\n\nrequire('./_object-sap')('keys', function () {\n  return function keys(it) {\n    return $keys(toObject(it));\n  };\n});\n","'use strict';\n// ECMAScript 6 symbols shim\nvar global = require('./_global');\nvar has = require('./_has');\nvar DESCRIPTORS = require('./_descriptors');\nvar $export = require('./_export');\nvar redefine = require('./_redefine');\nvar META = require('./_meta').KEY;\nvar $fails = require('./_fails');\nvar shared = require('./_shared');\nvar setToStringTag = require('./_set-to-string-tag');\nvar uid = require('./_uid');\nvar wks = require('./_wks');\nvar wksExt = require('./_wks-ext');\nvar wksDefine = require('./_wks-define');\nvar enumKeys = require('./_enum-keys');\nvar isArray = require('./_is-array');\nvar anObject = require('./_an-object');\nvar isObject = require('./_is-object');\nvar toObject = require('./_to-object');\nvar toIObject = require('./_to-iobject');\nvar toPrimitive = require('./_to-primitive');\nvar createDesc = require('./_property-desc');\nvar _create = require('./_object-create');\nvar gOPNExt = require('./_object-gopn-ext');\nvar $GOPD = require('./_object-gopd');\nvar $GOPS = require('./_object-gops');\nvar $DP = require('./_object-dp');\nvar $keys = require('./_object-keys');\nvar gOPD = $GOPD.f;\nvar dP = $DP.f;\nvar gOPN = gOPNExt.f;\nvar $Symbol = global.Symbol;\nvar $JSON = global.JSON;\nvar _stringify = $JSON && $JSON.stringify;\nvar PROTOTYPE = 'prototype';\nvar HIDDEN = wks('_hidden');\nvar TO_PRIMITIVE = wks('toPrimitive');\nvar isEnum = {}.propertyIsEnumerable;\nvar SymbolRegistry = shared('symbol-registry');\nvar AllSymbols = shared('symbols');\nvar OPSymbols = shared('op-symbols');\nvar ObjectProto = Object[PROTOTYPE];\nvar USE_NATIVE = typeof $Symbol == 'function' && !!$GOPS.f;\nvar QObject = global.QObject;\n// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173\nvar setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;\n\n// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687\nvar setSymbolDesc = DESCRIPTORS && $fails(function () {\n  return _create(dP({}, 'a', {\n    get: function () { return dP(this, 'a', { value: 7 }).a; }\n  })).a != 7;\n}) ? function (it, key, D) {\n  var protoDesc = gOPD(ObjectProto, key);\n  if (protoDesc) delete ObjectProto[key];\n  dP(it, key, D);\n  if (protoDesc && it !== ObjectProto) dP(ObjectProto, key, protoDesc);\n} : dP;\n\nvar wrap = function (tag) {\n  var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]);\n  sym._k = tag;\n  return sym;\n};\n\nvar isSymbol = USE_NATIVE && typeof $Symbol.iterator == 'symbol' ? function (it) {\n  return typeof it == 'symbol';\n} : function (it) {\n  return it instanceof $Symbol;\n};\n\nvar $defineProperty = function defineProperty(it, key, D) {\n  if (it === ObjectProto) $defineProperty(OPSymbols, key, D);\n  anObject(it);\n  key = toPrimitive(key, true);\n  anObject(D);\n  if (has(AllSymbols, key)) {\n    if (!D.enumerable) {\n      if (!has(it, HIDDEN)) dP(it, HIDDEN, createDesc(1, {}));\n      it[HIDDEN][key] = true;\n    } else {\n      if (has(it, HIDDEN) && it[HIDDEN][key]) it[HIDDEN][key] = false;\n      D = _create(D, { enumerable: createDesc(0, false) });\n    } return setSymbolDesc(it, key, D);\n  } return dP(it, key, D);\n};\nvar $defineProperties = function defineProperties(it, P) {\n  anObject(it);\n  var keys = enumKeys(P = toIObject(P));\n  var i = 0;\n  var l = keys.length;\n  var key;\n  while (l > i) $defineProperty(it, key = keys[i++], P[key]);\n  return it;\n};\nvar $create = function create(it, P) {\n  return P === undefined ? _create(it) : $defineProperties(_create(it), P);\n};\nvar $propertyIsEnumerable = function propertyIsEnumerable(key) {\n  var E = isEnum.call(this, key = toPrimitive(key, true));\n  if (this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return false;\n  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;\n};\nvar $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key) {\n  it = toIObject(it);\n  key = toPrimitive(key, true);\n  if (it === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return;\n  var D = gOPD(it, key);\n  if (D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key])) D.enumerable = true;\n  return D;\n};\nvar $getOwnPropertyNames = function getOwnPropertyNames(it) {\n  var names = gOPN(toIObject(it));\n  var result = [];\n  var i = 0;\n  var key;\n  while (names.length > i) {\n    if (!has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META) result.push(key);\n  } return result;\n};\nvar $getOwnPropertySymbols = function getOwnPropertySymbols(it) {\n  var IS_OP = it === ObjectProto;\n  var names = gOPN(IS_OP ? OPSymbols : toIObject(it));\n  var result = [];\n  var i = 0;\n  var key;\n  while (names.length > i) {\n    if (has(AllSymbols, key = names[i++]) && (IS_OP ? has(ObjectProto, key) : true)) result.push(AllSymbols[key]);\n  } return result;\n};\n\n// 19.4.1.1 Symbol([description])\nif (!USE_NATIVE) {\n  $Symbol = function Symbol() {\n    if (this instanceof $Symbol) throw TypeError('Symbol is not a constructor!');\n    var tag = uid(arguments.length > 0 ? arguments[0] : undefined);\n    var $set = function (value) {\n      if (this === ObjectProto) $set.call(OPSymbols, value);\n      if (has(this, HIDDEN) && has(this[HIDDEN], tag)) this[HIDDEN][tag] = false;\n      setSymbolDesc(this, tag, createDesc(1, value));\n    };\n    if (DESCRIPTORS && setter) setSymbolDesc(ObjectProto, tag, { configurable: true, set: $set });\n    return wrap(tag);\n  };\n  redefine($Symbol[PROTOTYPE], 'toString', function toString() {\n    return this._k;\n  });\n\n  $GOPD.f = $getOwnPropertyDescriptor;\n  $DP.f = $defineProperty;\n  require('./_object-gopn').f = gOPNExt.f = $getOwnPropertyNames;\n  require('./_object-pie').f = $propertyIsEnumerable;\n  $GOPS.f = $getOwnPropertySymbols;\n\n  if (DESCRIPTORS && !require('./_library')) {\n    redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);\n  }\n\n  wksExt.f = function (name) {\n    return wrap(wks(name));\n  };\n}\n\n$export($export.G + $export.W + $export.F * !USE_NATIVE, { Symbol: $Symbol });\n\nfor (var es6Symbols = (\n  // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14\n  'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'\n).split(','), j = 0; es6Symbols.length > j;)wks(es6Symbols[j++]);\n\nfor (var wellKnownSymbols = $keys(wks.store), k = 0; wellKnownSymbols.length > k;) wksDefine(wellKnownSymbols[k++]);\n\n$export($export.S + $export.F * !USE_NATIVE, 'Symbol', {\n  // 19.4.2.1 Symbol.for(key)\n  'for': function (key) {\n    return has(SymbolRegistry, key += '')\n      ? SymbolRegistry[key]\n      : SymbolRegistry[key] = $Symbol(key);\n  },\n  // 19.4.2.5 Symbol.keyFor(sym)\n  keyFor: function keyFor(sym) {\n    if (!isSymbol(sym)) throw TypeError(sym + ' is not a symbol!');\n    for (var key in SymbolRegistry) if (SymbolRegistry[key] === sym) return key;\n  },\n  useSetter: function () { setter = true; },\n  useSimple: function () { setter = false; }\n});\n\n$export($export.S + $export.F * !USE_NATIVE, 'Object', {\n  // 19.1.2.2 Object.create(O [, Properties])\n  create: $create,\n  // 19.1.2.4 Object.defineProperty(O, P, Attributes)\n  defineProperty: $defineProperty,\n  // 19.1.2.3 Object.defineProperties(O, Properties)\n  defineProperties: $defineProperties,\n  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)\n  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,\n  // 19.1.2.7 Object.getOwnPropertyNames(O)\n  getOwnPropertyNames: $getOwnPropertyNames,\n  // 19.1.2.8 Object.getOwnPropertySymbols(O)\n  getOwnPropertySymbols: $getOwnPropertySymbols\n});\n\n// Chrome 38 and 39 `Object.getOwnPropertySymbols` fails on primitives\n// https://bugs.chromium.org/p/v8/issues/detail?id=3443\nvar FAILS_ON_PRIMITIVES = $fails(function () { $GOPS.f(1); });\n\n$export($export.S + $export.F * FAILS_ON_PRIMITIVES, 'Object', {\n  getOwnPropertySymbols: function getOwnPropertySymbols(it) {\n    return $GOPS.f(toObject(it));\n  }\n});\n\n// 24.3.2 JSON.stringify(value [, replacer [, space]])\n$JSON && $export($export.S + $export.F * (!USE_NATIVE || $fails(function () {\n  var S = $Symbol();\n  // MS Edge converts symbol values to JSON as {}\n  // WebKit converts symbol values to JSON as null\n  // V8 throws on boxed symbols\n  return _stringify([S]) != '[null]' || _stringify({ a: S }) != '{}' || _stringify(Object(S)) != '{}';\n})), 'JSON', {\n  stringify: function stringify(it) {\n    var args = [it];\n    var i = 1;\n    var replacer, $replacer;\n    while (arguments.length > i) args.push(arguments[i++]);\n    $replacer = replacer = args[1];\n    if (!isObject(replacer) && it === undefined || isSymbol(it)) return; // IE8 returns string on undefined\n    if (!isArray(replacer)) replacer = function (key, value) {\n      if (typeof $replacer == 'function') value = $replacer.call(this, key, value);\n      if (!isSymbol(value)) return value;\n    };\n    args[1] = replacer;\n    return _stringify.apply($JSON, args);\n  }\n});\n\n// 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)\n$Symbol[PROTOTYPE][TO_PRIMITIVE] || require('./_hide')($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);\n// 19.4.3.5 Symbol.prototype[@@toStringTag]\nsetToStringTag($Symbol, 'Symbol');\n// 20.2.1.9 Math[@@toStringTag]\nsetToStringTag(Math, 'Math', true);\n// 24.3.3 JSON[@@toStringTag]\nsetToStringTag(global.JSON, 'JSON', true);\n","// https://github.com/tc39/proposal-object-getownpropertydescriptors\nvar $export = require('./_export');\nvar ownKeys = require('./_own-keys');\nvar toIObject = require('./_to-iobject');\nvar gOPD = require('./_object-gopd');\nvar createProperty = require('./_create-property');\n\n$export($export.S, 'Object', {\n  getOwnPropertyDescriptors: function getOwnPropertyDescriptors(object) {\n    var O = toIObject(object);\n    var getDesc = gOPD.f;\n    var keys = ownKeys(O);\n    var result = {};\n    var i = 0;\n    var key, desc;\n    while (keys.length > i) {\n      desc = getDesc(O, key = keys[i++]);\n      if (desc !== undefined) createProperty(result, key, desc);\n    }\n    return result;\n  }\n});\n","\n    (window.__NEXT_P=window.__NEXT_P||[]).push([\"/composition\", function() {\n      var mod = require(\"/Users/jslv/Projects/keyin/pages/composition.tsx\")\n      if(module.hot) {\n        module.hot.accept(\"/Users/jslv/Projects/keyin/pages/composition.tsx\", function() {\n          if(!next.router.components[\"/composition\"]) return\n          var updatedPage = require(\"/Users/jslv/Projects/keyin/pages/composition.tsx\")\n          next.router.update(\"/composition\", updatedPage)\n        })\n      }\n      return mod\n    }]);\n  ","module.exports = (__webpack_require__(/*! dll-reference dll_ef0ff7c60362f24a921f */ \"dll-reference dll_ef0ff7c60362f24a921f\"))(\"./node_modules/react/index.js\");","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nclass Analyzer {\n}\nexports.Analyzer = Analyzer;\n//# sourceMappingURL=analyzer.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nclass Character {\n    constructor(s) {\n        this.character = s;\n    }\n}\nexports.Character = Character;\nclass Characters {\n    constructor() {\n        this.carr = [\n            'a',\n            'b',\n            'c',\n            'd',\n            'e',\n            'f',\n            'g',\n            'h',\n            'i',\n            'j',\n            'k',\n            'l',\n            'm',\n            'n',\n            'o',\n            'p',\n            'q',\n            'r',\n            's',\n            't',\n            'u',\n            'v',\n            'w',\n            'x',\n            'y',\n            'z',\n        ];\n        this.o = new Map();\n        for (let e of this.carr) {\n            this.assign(e);\n        }\n    }\n    assign(e) {\n        this.o.set(e, new Character(e));\n    }\n    get(key) {\n        let value = this.o.get(key);\n        if (value) {\n            return value;\n        }\n        return new Character('');\n    }\n    get size() {\n        return this.o.size;\n    }\n}\nexports.characters = new Characters();\n//# sourceMappingURL=character.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst init_1 = require(\"./tonal/init\");\nconst analyzer_1 = require(\"./tonal/analyzer\");\nconst init_2 = require(\"./kana/init\");\nconst analyzer_2 = require(\"./kana/analyzer\");\nconst parser_1 = require(\"./dparser/parser\");\nconst tagger_1 = require(\"./dparser/tagger\");\nconst document_1 = require(\"./document\");\nconst token_1 = require(\"./token\");\nconst token_2 = require(\"./token\");\nclass Client {\n    processKana(str) {\n        init_2.checkLetterSizeKana();\n        // kana\n        let ta = new token_1.TokenAnalysis();\n        if (str) {\n            const ka = new analyzer_2.KanaLemmatizationAnalyzer();\n            const morphemes = ka.morphAnalyze(str);\n            ta.blockSequences = init_2.getKanaBlocks(morphemes);\n            for (let m of morphemes) {\n                ta.soundSequences.push(m.sounds);\n            }\n        }\n        return ta;\n    }\n    processTonal(str) {\n        init_1.checkLetterSizeTonal();\n        // tonal lurzmafjiz\n        let ta = new token_1.TokenAnalysis();\n        if (str) {\n            const tla = new analyzer_1.TonalLemmatizationAnalyzer();\n            const morphemes = tla.morphAnalyze(str);\n            const lexeme = tla.lexAnalyze(morphemes);\n            ta.word = lexeme.word;\n            ta.lemmata = lexeme.getLemmata();\n            ta.inflectionalEnding = lexeme.getInflectionalEnding();\n            for (let m of morphemes) {\n                ta.soundSequences.push(m.sounds);\n            }\n        }\n        return ta;\n    }\n    process(str) {\n        let doc = new document_1.Document();\n        // tokenization\n        if (str) {\n            const tokens = str.match(/\\w+/g);\n            if (tokens)\n                for (let i = 0; i < tokens.length; i++) {\n                    if (tokens[i].length)\n                        doc.tokens.push(new token_1.Token(tokens[i]));\n                }\n            // tagging\n            const tggr = new tagger_1.RuleBasedTagger();\n            doc = tggr.tag(doc);\n            // lemmatization\n            const lmtzr = new token_2.TokenLemmatizer();\n            doc = lmtzr.getTonalLemmas(doc);\n            // dependency parsing\n            const dpsr = new parser_1.DependencyParser();\n            doc = dpsr.parse(doc);\n        }\n        return doc;\n    }\n}\nexports.Client = Client;\n//# sourceMappingURL=client.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nclass Document {\n    constructor() {\n        this.relations = new Array(); // dependency\n        this.speeches = new Array();\n        this.tokens = new Array();\n    }\n}\nexports.Document = Document;\n//# sourceMappingURL=document.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst grapheme_1 = require(\"../grapheme\");\nconst analyzer_1 = require(\"../analyzer\");\nconst morpheme_1 = require(\"./morpheme\");\nconst version2_1 = require(\"../tonal/version2\");\nconst lexeme_1 = require(\"./lexeme\");\nconst lexeme_2 = require(\"../lexeme\");\nconst morpheme_2 = require(\"../morpheme\");\nconst phraseme_1 = require(\"./phraseme\");\n//------------------------------------------------------------------------------\nclass TonalInflectionAnalyzer extends analyzer_1.Analyzer {\n    graphAnalyze(str) {\n        // graphemic analysis\n        const gm = new grapheme_1.GraphemeMaker(version2_1.lowerLettersOfTonal);\n        return gm.makeGraphemes(str);\n    }\n    morphAnalyze(x, tcm) {\n        // morphological analysis\n        let graphemes = [];\n        if (typeof x == 'object') {\n            graphemes = x;\n        }\n        else if (typeof x == 'string') {\n            graphemes = this.graphAnalyze(x);\n        }\n        const mm = new morpheme_1.TonalCombiningMorphemeMaker(tcm);\n        return mm.makeMorphemes(graphemes);\n    }\n    lexAnalyze(ms, tim) {\n        // lexical analysis\n        let morphemes = ms;\n        const lm = new lexeme_1.TonalInflectionLexemeMaker(tim);\n        return lm.makeLexemes(morphemes);\n    }\n}\nexports.TonalInflectionAnalyzer = TonalInflectionAnalyzer;\nclass TonalInflector {\n    inflect(str, tcm, tim) {\n        const tia = new TonalInflectionAnalyzer();\n        const mrphs = tia.morphAnalyze(str, tcm);\n        const lx = tia.lexAnalyze(mrphs, tim);\n        return lx;\n    }\n}\nexports.TonalInflector = TonalInflector;\nclass TonalAssimilator {\n    assimilate(str, dir) {\n        const tia = new TonalInflectionAnalyzer();\n        const mrphs = tia.morphAnalyze(str, new morpheme_2.TonalZeroCombining());\n        let lx;\n        if (dir === morpheme_1.AssimiDirection.agressive) {\n            lx = tia.lexAnalyze(mrphs, new lexeme_1.AgressiveAssimilation());\n        }\n        else {\n            lx = tia.lexAnalyze(mrphs, new lexeme_1.RegressiveAssimilation());\n        }\n        return lx;\n    }\n}\nexports.TonalAssimilator = TonalAssimilator;\nclass TonalPhrasalInflector {\n    constructor() {\n        this.infl = new TonalInflector();\n        this.phm = new phraseme_1.TonalInflectionPhrasemeMaker();\n    }\n    analyzeTransitiveFourth(verb, particle) {\n        // particle has no proceeding form. no need to inflect\n        const lexemeVerb = this.infl.inflect(verb, new morpheme_1.TonalCombiningForms(), new lexeme_1.TonalDesinenceInflection());\n        const lexemeParticle = this.infl.inflect(particle, new morpheme_2.TonalZeroCombining(), new lexeme_1.TonalDesinenceInflection());\n        return this.phm.makeTransitivePhraseme(lexemeVerb, lexemeParticle);\n    }\n    analyzeTransitiveFirst(verb, particle) {\n        // need to inflect to first tone. tonal f is appended to particle.\n        const lexemeVerb = this.infl.inflect(verb, new morpheme_1.TonalCombiningForms(), new lexeme_1.TonalDesinenceInflection());\n        const lexemeParticle = this.infl.inflect(particle, new morpheme_1.PhrasalVerbParticleCombining(), new lexeme_1.TonalDesinenceInflection());\n        return this.phm.makeTransitivePhraseme(lexemeVerb, lexemeParticle);\n    }\n    analyzeIntransitive(verb, particle) {\n        // no need to inflect\n        const lexemeVerb = this.infl.inflect(verb, new morpheme_2.TonalZeroCombining(), new lexeme_1.TonalDesinenceInflection());\n        const lexemeParticle = this.infl.inflect(particle, new morpheme_2.TonalZeroCombining(), new lexeme_1.TonalDesinenceInflection());\n        return this.phm.makeIntransitivePhraseme(lexemeVerb, lexemeParticle);\n    }\n    analyzeAdjective(adjectivalNoun, e, metaplasm) {\n        const lexemeAdjective = this.infl.inflect(adjectivalNoun, new morpheme_2.TonalZeroCombining(), new lexeme_1.TonalDesinenceInflection());\n        const lexemeE = this.infl.inflect(e, new morpheme_1.EncliticECombining(), new lexeme_1.TonalDesinenceInflection());\n        return this.phm.makeAdjectivePhraseme(lexemeAdjective, lexemeE, metaplasm);\n    }\n}\nexports.TonalPhrasalInflector = TonalPhrasalInflector;\nclass TonalPhrasalAssimilator {\n    constructor() {\n        this.infl = new TonalInflector();\n        this.phm = new phraseme_1.TonalInflectionPhrasemeMaker();\n    }\n    analyzeAdjective(adjectivalNoun, e, dir) {\n        const lexemeAdjective = this.infl.inflect(adjectivalNoun, new morpheme_2.TonalZeroCombining(), new lexeme_1.TonalDesinenceInflection());\n        const lexemeE = this.infl.inflect(e, new morpheme_2.TonalZeroCombining(), new lexeme_2.TonalZeroInflection());\n        return this.phm.makeAdjectivePhraseme(lexemeAdjective, lexemeE, new phraseme_1.Assimilation());\n    }\n}\nexports.TonalPhrasalAssimilator = TonalPhrasalAssimilator;\n//# sourceMappingURL=analyzer.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nclass Transition {\n}\nexports.Transition = Transition;\nclass Shift extends Transition {\n    do(c) {\n        let s = c.queue.shift();\n        if (s != undefined) {\n            c.stack.push(s);\n        }\n        return c;\n    }\n}\nexports.Shift = Shift;\nclass RightArc extends Transition {\n    do(c) {\n        c.stack.pop();\n        return c;\n    }\n}\nexports.RightArc = RightArc;\nclass LeftArc extends Transition {\n    do(c) {\n        const top = c.stack.pop();\n        c.stack.pop();\n        if (top)\n            c.stack.push(top);\n        return c;\n    }\n}\nexports.LeftArc = LeftArc;\nclass Configuration {\n    constructor() {\n        this.queue = new Array();\n        this.stack = new Array();\n        this.relations = new Array();\n    }\n    getGraph() {\n        return this.relations;\n    }\n    isTerminalConfiguration() {\n        if (this.queue.length > 0) {\n            return false;\n        }\n        if (this.stack.length == 1 && this.queue.length == 0) {\n            return true;\n        }\n        return false;\n    }\n}\nexports.Configuration = Configuration;\n//# sourceMappingURL=configuration.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// prettier-ignore\nexports.dict_of_verbs = [\n    'koannw',\n    'pah',\n];\n// prettier-ignore\nexports.dict_of_phrasal_verbs = [\n    ['koannw', 'diurh'],\n    ['longw', 'diurh'],\n];\n// prettier-ignore\nexports.dict_of_seperate_vv_compounds = {\n    siam: ['qoew'],\n};\n//# sourceMappingURL=dictionary.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst configuration_1 = require(\"./configuration\");\nconst symbols_1 = require(\"./symbols\");\nconst token_1 = require(\"../token\");\nclass Guide {\n    constructor() {\n        this.transitions = new Array();\n        this.s1 = new token_1.Token('');\n        this.s2 = new token_1.Token('');\n        this.b1 = new token_1.Token('');\n        this.s1_b1_map = new Map()\n            .set(symbols_1.Tagset.VB + symbols_1.Tagset.PPV, new configuration_1.Shift())\n            .set(symbols_1.Tagset.NPR + symbols_1.Tagset.VB, new configuration_1.Shift())\n            .set(symbols_1.Tagset.NPR + symbols_1.Tagset.NPR, new configuration_1.Shift())\n            .set(symbols_1.Tagset.APPR + symbols_1.Tagset.NPR, new configuration_1.Shift())\n            .set(symbols_1.Tagset.VB + symbols_1.Tagset.NPR, new configuration_1.Shift())\n            .set(symbols_1.Tagset.VB + symbols_1.Tagset.AUXN, new configuration_1.Shift())\n            .set(symbols_1.Tagset.AUX + symbols_1.Tagset.VB, new configuration_1.Shift())\n            .set(symbols_1.Tagset.PADV + symbols_1.Tagset.VB, new configuration_1.Shift())\n            .set(symbols_1.Tagset.NPR + symbols_1.Tagset.PADV, new configuration_1.Shift())\n            .set(symbols_1.Tagset.VB + symbols_1.Tagset.APPR, new configuration_1.Shift())\n            .set(symbols_1.Tagset.VB + symbols_1.Tagset.PADV, new configuration_1.Shift())\n            .set(symbols_1.Tagset.NPR + symbols_1.Tagset.AUX, new configuration_1.Shift())\n            .set(symbols_1.Tagset.PPV + symbols_1.Tagset.AUXN, new configuration_1.RightArc())\n            .set(symbols_1.Tagset.PPV + symbols_1.Tagset.NPR, new configuration_1.RightArc());\n        this.s2_s1_map = new Map()\n            .set(symbols_1.Tagset.VB + symbols_1.Tagset.PPV, new configuration_1.RightArc())\n            .set(symbols_1.Tagset.VB + symbols_1.Tagset.AUXN, new configuration_1.RightArc())\n            .set(symbols_1.Tagset.AUX + symbols_1.Tagset.VB, new configuration_1.LeftArc())\n            .set(symbols_1.Tagset.PADV + symbols_1.Tagset.VB, new configuration_1.LeftArc())\n            .set(symbols_1.Tagset.APPR + symbols_1.Tagset.NPR, new configuration_1.LeftArc())\n            .set(symbols_1.Tagset.VB + symbols_1.Tagset.VB, new configuration_1.RightArc())\n            .set(symbols_1.Tagset.VB + symbols_1.Tagset.NPR, new configuration_1.RightArc())\n            .set(symbols_1.Tagset.NPR + symbols_1.Tagset.VB, new configuration_1.LeftArc());\n    }\n    isQueueEmpty(c) {\n        if (c.queue.length === 0)\n            return true;\n        return false;\n    }\n    isStackEmpty(c) {\n        if (c.stack.length === 2)\n            return true;\n        return false;\n    }\n    getNextTransition(c) {\n        this.s1 = new token_1.Token('');\n        if (c.stack.length > 0)\n            this.s1 = c.stack[c.stack.length - 1];\n        this.s2 = new token_1.Token('');\n        if (c.stack.length > 1)\n            this.s2 = c.stack[c.stack.length - 2];\n        this.b1 = new token_1.Token('');\n        if (c.queue.length > 0)\n            this.b1 = c.queue[0];\n        if (this.s1.tag != '' && this.b1.tag != '') {\n            if (this.s1_b1_map.has(this.s1.tag + this.b1.tag)) {\n                const tran = this.s1_b1_map.get(this.s1.tag + this.b1.tag);\n                if (tran) {\n                    this.transitions.push(tran);\n                }\n            }\n        }\n        else if (this.isQueueEmpty(c)) {\n            if (this.s2_s1_map.has(this.s2.tag + this.s1.tag)) {\n                const tran = this.s2_s1_map.get(this.s2.tag + this.s1.tag);\n                if (tran) {\n                    this.transitions.push(tran);\n                }\n            }\n            else if (this.isStackEmpty(c)) {\n                this.transitions.push(new configuration_1.RightArc());\n            }\n        }\n        if (this.transitions.length == 0)\n            return undefined;\n        return this.transitions.shift();\n    }\n}\nexports.Guide = Guide;\n//# sourceMappingURL=guide.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst symbols_1 = require(\"./symbols\");\nclass ConstructionElement {\n    constructor() {\n        this.surface = '';\n        this.pos = '';\n        this.tag = '';\n    }\n}\nexports.ConstructionElement = ConstructionElement;\n/*\nexport class PhrasalVerbParticleDiurh extends TonalCombiningMetaplasm {\n    apply(syllable: TonalSyllable, allomorph: Allomorph): Array<TonalSyllable> {\n        if (allomorph) {\n            if (allomorph instanceof AllomorphH) {\n                let rets = [];\n                let s: TonalSyllable = new TonalSyllable(syllable.letters);\n                s.popLetter();\n                s.pushLetter(lowerLettersOfTonal.get(TonalLetterTags.hh));\n                s.pushLetter(lowerLettersOfTonal.get(TonalLetterTags.w));\n                rets.push(new TonalSyllable(s.letters));\n                return rets;\n            }\n        }\n        return [];\n    }\n}\n*/\nclass PersonalPronounSurface extends ConstructionElement {\n    constructor(str) {\n        super();\n        this.surface = str;\n        this.pos = symbols_1.POSTags.pronoun;\n    }\n}\nexports.PersonalPronounSurface = PersonalPronounSurface;\nclass VerbSurface extends ConstructionElement {\n    constructor(str) {\n        super();\n        this.surface = str;\n        this.pos = symbols_1.POSTags.verb;\n    }\n}\nexports.VerbSurface = VerbSurface;\nclass EncliticSurface extends ConstructionElement {\n    constructor(str) {\n        super();\n        this.pos = symbols_1.POSTags.auxiliary;\n        this.surface = str;\n    }\n}\nexports.EncliticSurface = EncliticSurface;\nclass PronounSurface extends ConstructionElement {\n    constructor(str) {\n        super();\n        this.pos = symbols_1.POSTags.pronoun;\n        this.surface = str;\n    }\n}\nexports.PronounSurface = PronounSurface;\nclass NounSurface extends ConstructionElement {\n    constructor() {\n        super();\n        this.pos = symbols_1.POSTags.noun;\n    }\n}\nclass ParticleSurface extends ConstructionElement {\n    constructor(str) {\n        super();\n        this.pos = symbols_1.POSTags.particle;\n        this.surface = str;\n    }\n}\nexports.ParticleSurface = ParticleSurface;\nclass PrepositionSurface extends ConstructionElement {\n    constructor(str) {\n        super();\n        this.pos = symbols_1.POSTags.adposition;\n        this.surface = str;\n    }\n}\nexports.PrepositionSurface = PrepositionSurface;\nclass CaseMarker {\n}\nclass AuxiliarySurface extends ConstructionElement {\n    constructor(str) {\n        super();\n        this.pos = symbols_1.POSTags.auxiliary;\n        this.surface = str;\n    }\n}\nexports.AuxiliarySurface = AuxiliarySurface;\nconst objectFactory = function (name, str) {\n    const set = new Set()\n        .add(PronounSurface)\n        .add(ParticleSurface)\n        .add(AuxiliarySurface)\n        .add(PersonalPronounSurface);\n    const createInstance = function (c, str) {\n        return new c(str);\n    };\n    if (set.has(name)) {\n        return createInstance(name, str);\n    }\n};\nclass KeyWords {\n    constructor() {\n        this.keyElems = new Array();\n        this.populateKeyElems();\n    }\n    getSurface(str) {\n        for (let i in this.keyElems)\n            if (this.keyElems[i].surface === str)\n                return this.keyElems[i];\n    }\n    populateKeyElems() {\n        this.keyElems = [\n            objectFactory(PronounSurface, 'che'),\n            objectFactory(PersonalPronounSurface, 'goa'),\n            objectFactory(AuxiliarySurface, 'qaz'),\n            objectFactory(ParticleSurface, 'long'),\n            objectFactory(ParticleSurface, 'bew'),\n        ];\n    }\n}\nexports.KeyWords = KeyWords;\n//# sourceMappingURL=keywords.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst lexeme_1 = require(\"../lexeme\");\nconst morpheme_1 = require(\"./morpheme\");\nconst lexeme_2 = require(\"../tonal/lexeme\");\nconst version2_1 = require(\"../tonal/version2\");\nconst morpheme_2 = require(\"../tonal/morpheme\");\n//------------------------------------------------------------------------------\nclass TonalDesinenceInflection extends lexeme_1.TonalInflectionMetaplasm {\n    apply(ms) {\n        if (ms.length > 0 && ms[ms.length - 1]) {\n            const last = ms[ms.length - 1];\n            const syls = last.getForms();\n            let rets = [];\n            if (syls) {\n                for (let i in syls) {\n                    let wd = new lexeme_2.TonalWord(ms.map(x => new morpheme_2.TonalSyllable(x.syllable.letters)));\n                    wd.popSyllable();\n                    wd.pushSyllable(syls[i]);\n                    rets.push(wd);\n                }\n            }\n            return rets;\n        }\n        return [];\n    }\n}\nexports.TonalDesinenceInflection = TonalDesinenceInflection;\n//------------------------------------------------------------------------------\nclass TransfixInflection extends lexeme_1.TonalInflectionMetaplasm {\n    apply(ms) {\n        const rets = [];\n        if (ms.length > 0) {\n            const tw = new lexeme_2.TonalWord(ms.map(x => new morpheme_2.TonalSyllable(x.syllable.letters)));\n            for (let i = 0; i < ms.length; i++) {\n                const form = ms[i].getForms()[0];\n                if (form)\n                    tw.replaceSyllable(i, form);\n            }\n            rets.push(tw);\n        }\n        return rets;\n    }\n}\nexports.TransfixInflection = TransfixInflection;\n//------------------------------------------------------------------------------\nclass RegressiveAssimilation extends lexeme_1.TonalInflectionMetaplasm {\n    apply(ms) {\n        let tw = new lexeme_2.TonalWord(ms.map(x => new morpheme_2.TonalSyllable(x.syllable.letters)));\n        if (ms.length > 1) {\n            for (let i = 1; i < ms.length; i++) {\n                if (ms[i].sounds[0].name === version2_1.TonalSoundTags.initial &&\n                    (ms[i - 1].syllable.lastSecondLetter.literal === version2_1.TonalLetterTags.t ||\n                        ms[i - 1].syllable.lastSecondLetter.literal === version2_1.TonalLetterTags.tt)) {\n                    tw.replaceSyllable(i - 1, ms[i - 1].getSoundChangeForm(ms[i].sounds[0], morpheme_1.AssimiDirection.regressive)[0]);\n                }\n                else {\n                    const syls = ms[i - 1].getSoundChangeForm(ms[i].sounds[0], morpheme_1.AssimiDirection.regressive);\n                    if (syls.length)\n                        tw.replaceSyllable(i - 1, syls[0]);\n                }\n            }\n        }\n        return [tw];\n    }\n}\nexports.RegressiveAssimilation = RegressiveAssimilation;\n//------------------------------------------------------------------------------\nclass AgressiveAssimilation extends lexeme_1.TonalInflectionMetaplasm {\n    apply(ms) {\n        if (ms.length > 1 && ms[ms.length - 2]) {\n            const snds = ms[ms.length - 2].sounds;\n            let wrd = new lexeme_2.TonalWord(ms.map(x => new morpheme_2.TonalSyllable(x.syllable.letters)));\n            if (snds[snds.length - 2].name == version2_1.TonalSoundTags.nasalFinal &&\n                ms[ms.length - 1].syllable.letters[0].literal === version2_1.TonalLetterTags.a) {\n                // m, n, ng followed by -ay. pass the preceding nasal to get forms\n                wrd.replaceSyllable(wrd.syllables.length - 1, ms[ms.length - 1].getSoundChangeForm(snds[snds.length - 2], morpheme_1.AssimiDirection.agressive)[0]);\n                return [wrd];\n            }\n            else {\n                // duplifix. pass the preceding initial to get forms\n                wrd.replaceSyllable(wrd.syllables.length - 1, ms[ms.length - 1].getSoundChangeForm(snds[0], morpheme_1.AssimiDirection.agressive)[0]);\n                return [wrd];\n            }\n        }\n        return [];\n    }\n}\nexports.AgressiveAssimilation = AgressiveAssimilation;\n//------------------------------------------------------------------------------\nclass TonalInflectionLexeme extends lexeme_1.Lexeme {\n    constructor(ms, tim) {\n        super();\n        this.ms = ms;\n        this.proceedingForms = new Array(); // inflected or assimilated forms\n        let isIStemWithX = false; // inflectional stem with x in the middle\n        for (let i = 0; i < ms.length; i++) {\n            if (ms[i] && ms[i].syllable.lastLetter.literal === version2_1.TonalLetterTags.x) {\n                if (i < ms.length - 1 &&\n                    ms[ms.length - 1].syllable.lastLetter.literal !== version2_1.TonalLetterTags.y &&\n                    ms[ms.length - 1].syllable.lastSecondLetter.literal !== version2_1.TonalLetterTags.a) {\n                    if (ms[ms.length - 1].syllable.lastLetter.literal === version2_1.TonalLetterTags.a) {\n                        break;\n                    }\n                    else {\n                        // tonal x can't not appear in them middle of an inflectional stem\n                        // if it is not preceding an ay or a\n                        isIStemWithX = true;\n                        break;\n                    }\n                }\n            }\n        }\n        if (isIStemWithX)\n            this.word = new lexeme_2.TonalWord([]);\n        else\n            this.word = new lexeme_2.TonalWord(ms.map(x => x.syllable));\n        if (ms.length > 0) {\n            if (ms[ms.length - 1].allomorph) {\n                // tonal ending needs to be assigned to sandhi lexeme\n                this.tonalSymbleEnding = this.assignTonalEnding(ms[ms.length - 1].allomorph);\n            }\n            else {\n                this.tonalSymbleEnding = new lexeme_2.TonalSymbolEnding();\n            }\n        }\n        else {\n            this.tonalSymbleEnding = new lexeme_2.TonalSymbolEnding();\n        }\n        if (!isIStemWithX) {\n            this.proceedingForms = this.assignWordForms(ms, tim);\n        }\n    }\n    assignTonalEnding(allomorph) {\n        let tse = new lexeme_2.TonalSymbolEnding();\n        if (allomorph instanceof version2_1.FreeAllomorph) {\n            // replace the tonal ending\n            let fte = new lexeme_2.FreeTonalEnding();\n            fte.allomorph = allomorph;\n            tse = fte;\n        }\n        else if (allomorph instanceof version2_1.CheckedAllomorph) {\n            // append the tonal of the tonal ending\n            let cte = new lexeme_2.CheckedTonalEnding();\n            cte.allomorph = allomorph;\n            tse = cte;\n        }\n        return tse;\n    }\n    getInflectionalEnding() {\n        if (this.tonalSymbleEnding)\n            return this.tonalSymbleEnding.allomorph.tonal.toString();\n        return '';\n    }\n    assignWordForms(ms, ti) {\n        return ti.apply(ms);\n    }\n    getProceedingForms() {\n        return this.proceedingForms;\n    }\n    getMorphemes() {\n        // when external sandhi is required, member variable morphemes has to be exposed\n        return this.ms;\n    }\n    assimilate(til) {\n        const ms = til.getMorphemes();\n        if (ms.length > 0) {\n            const other_snds = ms[ms.length - 1].sounds;\n            if (other_snds[other_snds.length - 1].name === version2_1.TonalSoundTags.nasalFinal) {\n                let wrd = new lexeme_2.TonalWord(this.ms.map(x => new morpheme_2.TonalSyllable(x.syllable.letters)));\n                const s = other_snds[other_snds.length - 1];\n                const syls = this.ms[this.ms.length - 1].getSoundChangeForm(s, morpheme_1.AssimiDirection.agressive);\n                wrd.popSyllable();\n                wrd.pushSyllable(syls[0]);\n                return wrd;\n            }\n        }\n    }\n}\nexports.TonalInflectionLexeme = TonalInflectionLexeme;\n//------------------------------------------------------------------------------\nclass TonalInflectionLexemeMaker extends lexeme_1.LexemeMaker {\n    constructor(tim) {\n        super();\n        this.tim = tim;\n    }\n    makeLexemes(ms) {\n        return this.make(ms);\n    }\n    make(ms) {\n        return new TonalInflectionLexeme(ms, this.tim);\n    }\n}\nexports.TonalInflectionLexemeMaker = TonalInflectionLexemeMaker;\n//# sourceMappingURL=lexeme.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst morpheme_1 = require(\"../morpheme\");\nconst morpheme_2 = require(\"../tonal/morpheme\");\nconst version2_1 = require(\"../tonal/version2\");\nconst grapheme_1 = require(\"../grapheme\");\nvar AssimiDirection;\n(function (AssimiDirection) {\n    AssimiDirection[AssimiDirection[\"agressive\"] = 0] = \"agressive\";\n    AssimiDirection[AssimiDirection[\"regressive\"] = 1] = \"regressive\";\n})(AssimiDirection = exports.AssimiDirection || (exports.AssimiDirection = {}));\n//------------------------------------------------------------------------------\nclass TonalCombiningForms extends morpheme_1.TonalCombiningMetaplasm {\n    apply(sounds, allomorph) {\n        if (allomorph) {\n            let s = new morpheme_2.TonalSyllable(sounds.map(x => new grapheme_1.AlphabeticLetter(x.characters)));\n            if (allomorph instanceof version2_1.FreeAllomorph) {\n                if (allomorph instanceof version2_1.ZeroAllomorph) {\n                    const cfs = version2_1.combiningRules.get(version2_1.TonalLetterTags.zero);\n                    for (let k in cfs) {\n                        // it should loop only once\n                        s.pushLetter(new grapheme_1.AlphabeticLetter(cfs[k].characters));\n                    }\n                    return [s];\n                }\n                else if (allomorph instanceof version2_1.AllomorphY) {\n                    s.popLetter();\n                    return [s];\n                }\n                else {\n                    s.popLetter();\n                    const crs = version2_1.combiningRules.get(allomorph.tonal.toString());\n                    const rets = [];\n                    for (let k in crs) {\n                        s.pushLetter(new grapheme_1.AlphabeticLetter(crs[k].characters));\n                        rets.push(new morpheme_2.TonalSyllable(s.letters));\n                        s.popLetter();\n                    }\n                    return rets;\n                }\n            }\n            else if (allomorph instanceof version2_1.CheckedAllomorph) {\n                // nothing to pop here\n                if (allomorph.tonal.toString().length > 0)\n                    return [];\n                const cfs = version2_1.combiningRules.get(allomorph.final.toString());\n                const rets = [];\n                for (let k in cfs) {\n                    s.pushLetter(new grapheme_1.AlphabeticLetter(cfs[k].characters));\n                    rets.push(new morpheme_2.TonalSyllable(s.letters));\n                    s.popLetter();\n                }\n                return rets;\n            }\n        }\n        return [];\n    }\n}\nexports.TonalCombiningForms = TonalCombiningForms;\n//------------------------------------------------------------------------------\nclass EncliticECombining extends morpheme_1.TonalCombiningMetaplasm {\n    apply(sounds, allomorph) {\n        // 1->7, 7->7, 3->3\n        if (allomorph) {\n            let s = new morpheme_2.TonalSyllable(sounds.map(x => new grapheme_1.AlphabeticLetter(x.characters)));\n            if (allomorph instanceof version2_1.FreeAllomorph) {\n                if (allomorph instanceof version2_1.ZeroAllomorph) {\n                    const cfs = version2_1.combiningRules.get(version2_1.TonalLetterTags.zero);\n                    for (let k in cfs) {\n                        // it should loop only once\n                        s.pushLetter(new grapheme_1.AlphabeticLetter(cfs[k].characters));\n                    }\n                    return [s];\n                }\n            }\n        }\n        return [];\n    }\n}\nexports.EncliticECombining = EncliticECombining;\n//------------------------------------------------------------------------------\nclass ThirdCombiningForm extends morpheme_1.TonalCombiningMetaplasm {\n    apply(sounds, allomorph) {\n        if (allomorph) {\n            let s = new morpheme_2.TonalSyllable(sounds.map(x => new grapheme_1.AlphabeticLetter(x.characters)));\n            const ps = version2_1.tonalPositionalSound.get(version2_1.TonalLetterTags.w);\n            let snd = new grapheme_1.Sound();\n            if (allomorph instanceof version2_1.FreeAllomorph) {\n                if (ps)\n                    snd = ps(version2_1.TonalSoundTags.freeTonal);\n                if (allomorph instanceof version2_1.ZeroAllomorph) {\n                    s.pushLetter(new grapheme_1.AlphabeticLetter(snd.characters));\n                }\n                else {\n                    s.popLetter();\n                    s.pushLetter(new grapheme_1.AlphabeticLetter(snd.characters));\n                }\n            }\n            else if (allomorph instanceof version2_1.CheckedAllomorph) {\n                if (ps)\n                    snd = ps(version2_1.TonalSoundTags.checkedTonal);\n                if (allomorph.tonal.toString()) {\n                    s.popLetter();\n                    s.pushLetter(new grapheme_1.AlphabeticLetter(snd.characters));\n                }\n                else {\n                    s.pushLetter(new grapheme_1.AlphabeticLetter(snd.characters));\n                }\n            }\n            return [s];\n        }\n        return [];\n    }\n}\nexports.ThirdCombiningForm = ThirdCombiningForm;\n//------------------------------------------------------------------------------\nclass PhrasalVerbParticleCombining extends morpheme_1.TonalCombiningMetaplasm {\n    apply(sounds, allomorph) {\n        if (allomorph) {\n            let s = new morpheme_2.TonalSyllable(sounds.map(x => new grapheme_1.AlphabeticLetter(x.characters)));\n            if (allomorph instanceof version2_1.CheckedAllomorph) {\n                const cfs = version2_1.combiningRules.get(allomorph.final.toString());\n                for (let k in cfs) {\n                    // f only\n                    if (cfs[k].toString() === version2_1.TonalLetterTags.f)\n                        s.pushLetter(new grapheme_1.AlphabeticLetter(cfs[k].characters));\n                    return [new morpheme_2.TonalSyllable(s.letters)];\n                }\n            }\n        }\n        return [];\n    }\n}\nexports.PhrasalVerbParticleCombining = PhrasalVerbParticleCombining;\n//------------------------------------------------------------------------------\nclass TonalCombiningMorpheme extends morpheme_1.Morpheme {\n    constructor(syllable, tcf) {\n        super();\n        this.syllable = syllable;\n        this.metaplasm = tcf;\n        // assign allomorph for each syllable\n        this.allomorph = this.assignAllomorph(this.syllable);\n        this.sounds = new Array();\n    }\n    getForms() {\n        return this.metaplasm.apply(this.sounds, this.allomorph);\n    }\n    getSoundChangeForm(sound, dir) {\n        if (sound) {\n            if (sound.name === version2_1.TonalSoundTags.nasalFinal && dir === AssimiDirection.agressive) {\n                // agressive assimilation of nasals, both internal and external sandhi\n                const snds = this.sounds;\n                snds.splice(0, 0, sound);\n                return [new morpheme_2.TonalSyllable(snds.map(x => new grapheme_1.AlphabeticLetter(x.characters)))];\n            }\n            else if (sound.name === version2_1.TonalSoundTags.initial && dir === AssimiDirection.agressive) {\n                const snds = this.sounds;\n                if (snds[0].toString() === sound.toString()) {\n                    let duplifix = new grapheme_1.Sound();\n                    const ps = version2_1.tonalPositionalSound.get(version2_1.TonalLetterTags.l);\n                    if (ps)\n                        duplifix = ps(version2_1.TonalSoundTags.initial);\n                    snds.splice(0, 1, duplifix);\n                }\n                return [new morpheme_2.TonalSyllable(snds.map(x => new grapheme_1.AlphabeticLetter(x.characters)))];\n            }\n            // internal sandhi. regressive assimilation\n            return this.regAssimilate(this.sounds, sound);\n        }\n        return [];\n    }\n    assignAllomorph(syllable) {\n        if (version2_1.uncombinedCheckedAllomorphs.has(syllable.lastLetter.literal)) {\n            return version2_1.uncombinedCheckedAllomorphs.get(syllable.lastLetter.literal);\n        }\n        if (new version2_1.CheckedTonalSounds().includes(syllable.lastLetter.literal) &&\n            version2_1.uncombinedCheckedAllomorphs.has(syllable.lastSecondLetter.literal)) {\n            // in case of final followed by tonal\n            const alms = version2_1.combinedCheckedAllomorphs.get(syllable.lastSecondLetter.literal);\n            if (alms.length > 1) {\n                const it = alms.filter(x => x.tonal.toString() === syllable.lastLetter.literal);\n                return it[0];\n            }\n            return alms[0];\n        }\n        if (version2_1.combinedFreeAllomorphs.has(syllable.lastLetter.literal)) {\n            return version2_1.combinedFreeAllomorphs.get(syllable.lastLetter.literal);\n        }\n        return new version2_1.ZeroAllomorph();\n    }\n    regAssimilate(sounds, soundFollowingSyllable) {\n        if (sounds[sounds.length - 2].name != version2_1.TonalSoundTags.stopFinal &&\n            sounds[sounds.length - 2].name != version2_1.TonalSoundTags.nasalFinal)\n            return [];\n        if ((sounds[sounds.length - 2].toString() === version2_1.TonalLetterTags.tt &&\n            new version2_1.InitialsForEuphonicTT().includes(soundFollowingSyllable.toString())) ||\n            (sounds[sounds.length - 2].toString() === version2_1.TonalLetterTags.t &&\n                new version2_1.InitialsForEuphonicT().includes(soundFollowingSyllable.toString()))) {\n            // absolute assimilation\n            let s = new morpheme_2.TonalSyllable(sounds.map(x => new grapheme_1.AlphabeticLetter(x.characters)));\n            let snd = new grapheme_1.Sound();\n            const af = version2_1.assimilatedFinals.get(sounds[sounds.length - 2].toString() + soundFollowingSyllable.toString());\n            if (af) {\n                const ps = version2_1.tonalPositionalSound.get(af);\n                if (ps)\n                    snd = ps(version2_1.TonalSoundTags.stopFinal);\n                s.replaceLetter(s.letters.length - 2, new grapheme_1.AlphabeticLetter(snd.characters));\n                if (new version2_1.NasalInitialSounds().includes(soundFollowingSyllable.toString())) {\n                    s.insertLetter(s.letters.length - 2, new grapheme_1.AlphabeticLetter(soundFollowingSyllable.characters));\n                }\n                return [s];\n            }\n        }\n        else if (soundFollowingSyllable.toString() === version2_1.TonalLetterTags.b &&\n            sounds[sounds.length - 2].toString() === version2_1.TonalLetterTags.n) {\n            // replace final n with final m\n            let s = new morpheme_2.TonalSyllable(sounds.map(x => new grapheme_1.AlphabeticLetter(x.characters)));\n            let snd = new grapheme_1.Sound();\n            const ps = version2_1.tonalPositionalSound.get(version2_1.TonalLetterTags.m);\n            if (ps)\n                snd = ps(version2_1.TonalSoundTags.nasalFinal);\n            s.replaceLetter(s.letters.length - 2, new grapheme_1.AlphabeticLetter(snd.characters));\n            return [s];\n        }\n        else {\n            const tss = this.conditionalVoicedFinal(sounds, soundFollowingSyllable);\n            if (tss)\n                return tss;\n        }\n        return [];\n    }\n    conditionalVoicedFinal(sounds, soundFollowingSyllable) {\n        if (soundFollowingSyllable.name === version2_1.TonalSoundTags.initial &&\n            new version2_1.NasalInitialSounds().includes(soundFollowingSyllable.toString())) {\n            return this.voicedFinal(sounds);\n        }\n        if (soundFollowingSyllable.name === version2_1.TonalSoundTags.medial &&\n            new version2_1.MedialSounds().includes(soundFollowingSyllable.toString())) {\n            return this.voicedFinal(sounds);\n        }\n        if (soundFollowingSyllable.name === version2_1.TonalSoundTags.initial &&\n            (soundFollowingSyllable.toString() === version2_1.TonalLetterTags.h ||\n                soundFollowingSyllable.toString() === version2_1.TonalLetterTags.l ||\n                soundFollowingSyllable.toString() === version2_1.TonalLetterTags.b ||\n                soundFollowingSyllable.toString() === version2_1.TonalLetterTags.g)) {\n            return this.voicedFinal(sounds);\n        }\n    }\n    voicedFinal(sounds) {\n        const fnl = version2_1.voiceless_voiced_finals.get(sounds[sounds.length - 2].toString());\n        if (fnl) {\n            let s = new morpheme_2.TonalSyllable(sounds.map(x => new grapheme_1.AlphabeticLetter(x.characters)));\n            let snd = new grapheme_1.Sound();\n            const ps = version2_1.tonalPositionalSound.get(fnl);\n            if (ps)\n                snd = ps(version2_1.TonalSoundTags.stopFinal);\n            s.replaceLetter(s.letters.length - 2, new grapheme_1.AlphabeticLetter(snd.characters));\n            return [s];\n        }\n    }\n}\nexports.TonalCombiningMorpheme = TonalCombiningMorpheme;\nclass TonalCombiningMorphemeMaker extends morpheme_1.MorphemeMaker {\n    constructor(tsm) {\n        super();\n        this.metaplasm = tsm;\n    }\n    createMorphemes() {\n        return new Array();\n    }\n    createMorpheme(msp) {\n        const tcm = new TonalCombiningMorpheme(new morpheme_2.TonalSyllable(msp.letters), this.metaplasm);\n        tcm.sounds = msp.pattern;\n        return tcm;\n    }\n    postprocess(patterns) {\n        let morphemes = this.createMorphemes();\n        for (let i in patterns) {\n            morphemes.push(this.createMorpheme(patterns[i]));\n        }\n        return morphemes;\n    }\n    makeMorphemes(gs) {\n        const ltrs = gs.map(it => it.letter);\n        const ptrns = this.make(ltrs, morpheme_2.syllabifyTonal);\n        const ms = this.postprocess(ptrns);\n        return ms;\n    }\n}\nexports.TonalCombiningMorphemeMaker = TonalCombiningMorphemeMaker;\n//# sourceMappingURL=morpheme.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst configuration_1 = require(\"./configuration\");\nconst guide_1 = require(\"./guide\");\nconst token_1 = require(\"../token\");\nconst symbols_1 = require(\"./symbols\");\nconst relation_1 = require(\"./relation\");\n//import { FeatureLabel, Feature } from './feature';\nclass DependencyParser {\n    constructor() {\n        this.c = this.getInitialConfiguration();\n        this.triggered = false;\n        this.s1 = new token_1.Token('');\n        this.s2 = new token_1.Token('');\n        this.b1 = new token_1.Token('');\n        this.s1_b1_right_relations = new Map()\n            .set(symbols_1.Tagset.PPV + symbols_1.Tagset.AUXN, symbols_1.DependencyLabels.compound_prt)\n            .set(symbols_1.Tagset.PPV + symbols_1.Tagset.NPR, symbols_1.DependencyLabels.compound_prt);\n        this.s1_b1_left_relations = new Map();\n        this.s2_s1_right_relations = new Map()\n            .set(symbols_1.Tagset.VB + symbols_1.Tagset.PPV, symbols_1.DependencyLabels.compound_prt)\n            .set(symbols_1.Tagset.VB + symbols_1.Tagset.AUXN, symbols_1.DependencyLabels.aux)\n            .set(symbols_1.Tagset.VB + symbols_1.Tagset.VB, symbols_1.DependencyLabels.compound)\n            .set(symbols_1.Tagset.VB + symbols_1.Tagset.NPR, symbols_1.DependencyLabels.obj);\n        this.s2_s1_left_relations = new Map()\n            .set(symbols_1.Tagset.AUX + symbols_1.Tagset.VB, symbols_1.DependencyLabels.aux)\n            .set(symbols_1.Tagset.PADV + symbols_1.Tagset.VB, symbols_1.DependencyLabels.advmod)\n            .set(symbols_1.Tagset.APPR + symbols_1.Tagset.NPR, symbols_1.DependencyLabels.case);\n        this.s2_s1_left_features = new Map().set(symbols_1.Tagset.NPR + symbols_1.Tagset.VB, [\n            symbols_1.DependencyLabels.nsubj,\n            symbols_1.DependencyLabels.dislocated,\n        ]);\n    }\n    getInitialConfiguration() {\n        return new configuration_1.Configuration();\n    }\n    apply(t, c) {\n        return t.do(c);\n    }\n    isQueueEmpty() {\n        if (this.c.queue.length === 0)\n            return true;\n        return false;\n    }\n    isStackEmpty() {\n        if (this.c.stack.length === 2)\n            return true;\n        return false;\n    }\n    rightRelation(label) {\n        this.s1.dep = label;\n        this.s1.head = this.s2;\n        return new relation_1.Relation(label, this.s2, this.s1);\n    }\n    leftRelation(label) {\n        this.s2.dep = label;\n        this.s2.head = this.s1;\n        return new relation_1.Relation(label, this.s1, this.s2);\n    }\n    set_s1_s2_b1() {\n        this.s1 = new token_1.Token('');\n        if (this.c.stack.length > 0)\n            this.s1 = this.c.stack[this.c.stack.length - 1];\n        this.s2 = new token_1.Token('');\n        if (this.c.stack.length > 1)\n            this.s2 = this.c.stack[this.c.stack.length - 2];\n        this.b1 = new token_1.Token('');\n        if (this.c.queue.length > 0)\n            this.b1 = this.c.queue[0];\n    }\n    set_s1_b1_relation(t) {\n        if (t instanceof configuration_1.RightArc) {\n            if (this.s1_b1_right_relations.has(this.s1.tag + this.b1.tag)) {\n                const rel = this.s1_b1_right_relations.get(this.s1.tag + this.b1.tag);\n                if (rel) {\n                    this.c.relations.push(this.rightRelation(rel));\n                }\n            }\n        }\n        else if (t instanceof configuration_1.LeftArc) {\n            if (this.s1_b1_left_relations.has(this.s1.tag + this.b1.tag)) {\n                const rel = this.s1_b1_left_relations.get(this.s1.tag + this.b1.tag);\n                if (rel) {\n                    this.c.relations.push(this.leftRelation(rel));\n                }\n            }\n        }\n    }\n    set_s2_s1_relation(t) {\n        if (t instanceof configuration_1.RightArc) {\n            if (this.s2_s1_right_relations.has(this.s2.tag + this.s1.tag)) {\n                const rel = this.s2_s1_right_relations.get(this.s2.tag + this.s1.tag);\n                if (rel) {\n                    this.c.relations.push(this.rightRelation(rel));\n                }\n            }\n            else if (this.isStackEmpty()) {\n                this.c.relations.push(this.rightRelation(symbols_1.DependencyLabels.root));\n            }\n        }\n        else if (t instanceof configuration_1.LeftArc) {\n            if (this.s2_s1_left_relations.has(this.s2.tag + this.s1.tag)) {\n                const rel = this.s2_s1_left_relations.get(this.s2.tag + this.s1.tag);\n                if (rel) {\n                    this.c.relations.push(this.leftRelation(rel));\n                }\n            }\n            else if (this.s2_s1_left_features.has(this.s2.tag + this.s1.tag)) {\n                const labels = this.s2_s1_left_features.get(this.s2.tag + this.s1.tag);\n                if (labels) {\n                    if (this.triggered == false) {\n                        this.c.relations.push(this.leftRelation(labels[0]));\n                        this.triggered = true;\n                    }\n                    else {\n                        this.c.relations.push(this.leftRelation(labels[1]));\n                    }\n                }\n            }\n        }\n    }\n    parse(doc) {\n        for (let t of doc.tokens) {\n            this.c.queue.push(t);\n        }\n        let guide = new guide_1.Guide();\n        let rt = new token_1.Token('ROOT');\n        this.c.stack.push(rt);\n        if (this.c.stack.length == 1 && this.c.queue.length > 0) {\n            // initial configuration\n            // shift the first lexeme from queue to stack\n            guide.transitions.push(new configuration_1.Shift());\n        }\n        while (!this.c.isTerminalConfiguration()) {\n            let t = guide.getNextTransition(this.c);\n            if (t == null || t == undefined)\n                break;\n            this.set_s1_s2_b1();\n            if (this.s1.tag != '' && this.b1.tag != '') {\n                this.set_s1_b1_relation(t);\n            }\n            else if (this.isQueueEmpty()) {\n                this.set_s2_s1_relation(t);\n            }\n            this.c = this.apply(t, this.c);\n        }\n        doc.relations = this.c.relations;\n        return doc;\n    }\n}\nexports.DependencyParser = DependencyParser;\n//# sourceMappingURL=parser.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst phraseme_1 = require(\"../phraseme\");\nclass Transitive extends phraseme_1.TonalPhrasalInflectionMetaplasm {\n    apply(lexemeVerb, lexemeParticle) {\n        if (lexemeVerb.word.literal === '' || lexemeParticle.word.literal === '')\n            return [];\n        if (lexemeParticle.getProceedingForms().length > 0) {\n            return [new phraseme_1.TonalPhrase([lexemeVerb.getProceedingForms()[0], lexemeParticle.getProceedingForms()[0]])];\n        }\n        else {\n            return [new phraseme_1.TonalPhrase([lexemeVerb.getProceedingForms()[0], lexemeParticle.word])];\n        }\n    }\n}\nclass Adnominal extends phraseme_1.TonalPhrasalInflectionMetaplasm {\n    apply(lexemeAdjectivalNoun, lexemeE) {\n        if (lexemeAdjectivalNoun.word.literal === '' || lexemeE.word.literal === '')\n            return [];\n        if (lexemeE.getProceedingForms().length > 0) {\n            return [new phraseme_1.TonalPhrase([lexemeAdjectivalNoun.word, lexemeE.getProceedingForms()[0]])];\n        }\n        else {\n            return [new phraseme_1.TonalPhrase([lexemeAdjectivalNoun.word, lexemeE.word])];\n        }\n    }\n}\nexports.Adnominal = Adnominal;\nclass Assimilation extends phraseme_1.TonalPhrasalInflectionMetaplasm {\n    apply(lexemeAdjectivalNoun, lexemeE) {\n        const wrd = lexemeE.assimilate(lexemeAdjectivalNoun);\n        if (wrd) {\n            const frs = new phraseme_1.TonalPhrase([lexemeAdjectivalNoun.word, wrd]);\n            return [frs];\n        }\n        return [];\n    }\n}\nexports.Assimilation = Assimilation;\nclass TonalTransitivePhraseme extends phraseme_1.Phraseme {\n    constructor(lexemeVerb, lexemeParticle, metaplasm) {\n        super();\n        this.lexemeVerb = lexemeVerb;\n        this.lexemeParticle = lexemeParticle;\n        this.metaplasm = metaplasm;\n        this.proceedingForms = new Array();\n        this.phrase = new phraseme_1.TonalPhrase([lexemeVerb.word, lexemeParticle.word]);\n        this.proceedingForms = this.assignPhraseForms();\n    }\n    assignPhraseForms() {\n        return this.metaplasm.apply(this.lexemeVerb, this.lexemeParticle);\n    }\n    getProceedingForms() {\n        return this.proceedingForms;\n    }\n}\nexports.TonalTransitivePhraseme = TonalTransitivePhraseme;\nclass TonalIntransitivePhraseme extends phraseme_1.Phraseme {\n    constructor(lexemeAdjective, lexemeE) {\n        super();\n        this.phrase = new phraseme_1.TonalPhrase([lexemeAdjective.word, lexemeE.word]);\n    }\n}\nexports.TonalIntransitivePhraseme = TonalIntransitivePhraseme;\nclass TonalAdjectivePhraseme extends phraseme_1.Phraseme {\n    constructor(lexemeAdjectivalNoun, lexemeE, metaplasm) {\n        super();\n        this.lexemeAdjectivalNoun = lexemeAdjectivalNoun;\n        this.lexemeE = lexemeE;\n        this.metaplasm = metaplasm;\n        this.proceedingForms = new Array();\n        this.phrase = new phraseme_1.TonalPhrase([lexemeAdjectivalNoun.word, lexemeE.word]);\n        this.proceedingForms = this.assignPhraseForm();\n    }\n    assignPhraseForm() {\n        return this.metaplasm.apply(this.lexemeAdjectivalNoun, this.lexemeE);\n    }\n    getProceedingForms() {\n        return this.proceedingForms;\n    }\n}\nexports.TonalAdjectivePhraseme = TonalAdjectivePhraseme;\nclass TonalInflectionPhrasemeMaker {\n    makeTransitivePhraseme(lexemeVerb, lexemeParticle) {\n        return new TonalTransitivePhraseme(lexemeVerb, lexemeParticle, new Transitive());\n    }\n    makeIntransitivePhraseme(lexemeVerb, lexemeParticle) {\n        return new TonalIntransitivePhraseme(lexemeVerb, lexemeParticle);\n    }\n    makeAdjectivePhraseme(lexemeAdjectivalNoun, lexemeE, metaplasm) {\n        return new TonalAdjectivePhraseme(lexemeAdjectivalNoun, lexemeE, metaplasm);\n    }\n}\nexports.TonalInflectionPhrasemeMaker = TonalInflectionPhrasemeMaker;\n//# sourceMappingURL=phraseme.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nclass Relation {\n    constructor(dep, head, dependent) {\n        this.dependency = dep;\n        this.head = head;\n        this.dependent = dependent;\n    }\n}\nexports.Relation = Relation;\n//# sourceMappingURL=relation.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst keywords_1 = require(\"./keywords\");\nconst symbols_1 = require(\"./symbols\");\nconst analyzer_1 = require(\"./analyzer\");\nconst dictionary_1 = require(\"./dictionary\");\nclass ConstructionOfSpeech {\n    constructor() {\n        this.pos = '';\n        this.elements = new Array();\n    }\n}\nexports.ConstructionOfSpeech = ConstructionOfSpeech;\nclass ConstructionOfPhrase extends ConstructionOfSpeech {\n    constructor(arr) {\n        super();\n        for (let key in arr) {\n            this.elements.push(arr[key]);\n        }\n    }\n}\nexports.ConstructionOfPhrase = ConstructionOfPhrase;\nclass NounPhrase extends ConstructionOfPhrase {\n}\nclass VerbPhrase extends ConstructionOfPhrase {\n}\nclass PhrasalVerb extends VerbPhrase {\n    constructor(arr) {\n        super(arr);\n        this.pos = symbols_1.POSTags.verb;\n    }\n}\nexports.PhrasalVerb = PhrasalVerb;\nclass VerbPhraseSurface extends ConstructionOfSpeech {\n    constructor() {\n        super();\n        this.pos = symbols_1.POSTags.verb;\n    }\n}\nclass PhrasalVerbWithEnclitic extends VerbPhraseSurface {\n    constructor(verb, particle, enclitic) {\n        super();\n        verb.tag = symbols_1.Tagset.VB;\n        this.elements.push(verb);\n        particle.tag = symbols_1.Tagset.PPV;\n        this.elements.push(particle);\n        enclitic.tag = symbols_1.Tagset.AUXN;\n        this.elements.push(enclitic);\n    }\n}\nexports.PhrasalVerbWithEnclitic = PhrasalVerbWithEnclitic;\nclass VerbWithEnclitic extends VerbPhraseSurface {\n    constructor(verb, enclitic) {\n        super();\n        verb.tag = symbols_1.Tagset.VB;\n        this.elements.push(verb);\n        enclitic.tag = symbols_1.Tagset.AUXN;\n        this.elements.push(enclitic);\n    }\n}\nexports.VerbWithEnclitic = VerbWithEnclitic;\nclass SetOfPhrasalVerbs {\n    constructor() {\n        this.phrms = new Array();\n        this.phvs = new Array();\n        this.populatePhrasemes();\n        this.populatePhrasalVerbs();\n    }\n    populatePhrasalVerbs() {\n        for (let i in this.phrms) {\n            this.phvs.push(new PhrasalVerb([\n                new keywords_1.VerbSurface(this.phrms[i].phrase.words[0].literal),\n                new keywords_1.ParticleSurface(this.phrms[i].phrase.words[1].literal),\n            ]));\n            this.phvs.push(new PhrasalVerb([\n                new keywords_1.VerbSurface(this.phrms[i].getProceedingForms()[0].words[0].literal),\n                new keywords_1.ParticleSurface(this.phrms[i].getProceedingForms()[0].words[1].literal),\n            ]));\n        }\n    }\n    populatePhrasemes() {\n        const pva = new analyzer_1.TonalPhrasalInflector();\n        for (let i in dictionary_1.dict_of_phrasal_verbs) {\n            this.phrms.push(pva.analyzeTransitiveFourth(dictionary_1.dict_of_phrasal_verbs[i][0], dictionary_1.dict_of_phrasal_verbs[i][1]));\n        }\n    }\n}\nexports.SetOfPhrasalVerbs = SetOfPhrasalVerbs;\nclass PhrasalTransitive extends VerbPhraseSurface {\n    constructor(verb, preposition, pronoun) {\n        super();\n        verb.tag = symbols_1.Tagset.VB;\n        this.elements.push(verb);\n        preposition.tag = symbols_1.Tagset.PADV;\n        this.elements.push(preposition);\n        pronoun.tag = symbols_1.Tagset.NPR; // TODO: pronType\n        this.elements.push(pronoun);\n    }\n}\nclass SmallClause extends VerbPhraseSurface {\n    constructor(verb1, pronoun, verb2) {\n        super();\n        verb1.tag = symbols_1.Tagset.VB;\n        this.elements.push(verb1);\n        pronoun.tag = symbols_1.Tagset.NPR;\n        this.elements.push(pronoun);\n        verb2.tag = symbols_1.Tagset.VB;\n        this.elements.push(verb2);\n    }\n}\nclass SetOfSmallClauses {\n    constructor() {\n        this.constructions = [];\n        // obj. xcomp.\n        const sc = new SmallClause(new keywords_1.VerbSurface('oannw'), new keywords_1.PersonalPronounSurface('goa'), new keywords_1.VerbSurface('churw'));\n        this.constructions.push(sc);\n    }\n}\nexports.SetOfSmallClauses = SetOfSmallClauses;\nclass Rules {\n    constructor() {\n        this.phrases = new Array();\n        this.keyWords = new keywords_1.KeyWords();\n        this.populatePatterns();\n        this.populatePhrasalVerbs();\n    }\n    lookupDictionary(str) {\n        let phr;\n        if (dictionary_1.dict_of_verbs.includes(str)) {\n            let vs = new keywords_1.VerbSurface(str);\n            if (vs.pos === symbols_1.POSTags.verb)\n                vs.tag = symbols_1.Tagset.VB;\n            phr = [new ConstructionOfSpeech()];\n            phr[0].elements.push(vs);\n            phr[0].pos = symbols_1.POSTags.verb;\n            return phr;\n        }\n        return undefined;\n    }\n    lookupRules(sequence) {\n        let elems = [];\n        for (let pat of this.phrases) {\n            for (let j = 0; j < pat.length; j++) {\n                //console.log(pat[j].elements)\n                for (let e of pat[j].elements) {\n                    elems.push(e);\n                }\n            }\n            for (let i = 0; i < elems.length; i++) {\n                if (i === 1 && i + 1 === elems.length) {\n                    if (elems[0].surface === sequence[0] && elems[1].surface === sequence[1]) {\n                        return pat;\n                    }\n                }\n            }\n            elems = [];\n        }\n    }\n    matchKeyWords(str) {\n        return this.keyWords.getSurface(str);\n    }\n    seperateMatches(str) {\n        const ptcls = dictionary_1.dict_of_seperate_vv_compounds[str];\n        if (ptcls) {\n            return ptcls[0];\n        }\n    }\n    matches(sequence) {\n        const phrD = this.lookupDictionary(sequence[0]);\n        const phrR = this.lookupRules(sequence);\n        if (phrR)\n            return phrR;\n        else if (phrD)\n            return phrD;\n        return undefined;\n    }\n    populatePhrasalVerbs() {\n        const s = new SetOfPhrasalVerbs();\n        for (let i = 0; i < s.phvs.length; i++) {\n            this.phrases.push([s.phvs[i]]);\n        }\n    }\n    populatePatterns() {\n        this.phrases.push([new SetOfSmallClauses().constructions[0]]);\n    }\n}\nexports.Rules = Rules;\n//# sourceMappingURL=rules.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar POSTags;\n(function (POSTags) {\n    /*\n      Universal POS tags\n      https://universaldependencies.org/u/pos/\n    */\n    POSTags[\"adjective\"] = \"ADJ\";\n    POSTags[\"adposition\"] = \"ADP\";\n    POSTags[\"adverb\"] = \"ADV\";\n    POSTags[\"auxiliary\"] = \"AUX\";\n    POSTags[\"conjunction\"] = \"CONJ\";\n    POSTags[\"coordinating_conjunction\"] = \"CCONJ\";\n    POSTags[\"determiner\"] = \"DET\";\n    POSTags[\"interjection\"] = \"INTJ\";\n    POSTags[\"noun\"] = \"NOUN\";\n    POSTags[\"number\"] = \"NUM\";\n    POSTags[\"particle\"] = \"PART\";\n    POSTags[\"pronoun\"] = \"PRON\";\n    POSTags[\"proper_noun\"] = \"PROPN\";\n    POSTags[\"punctuation\"] = \"PUNCT\";\n    POSTags[\"subordinating_conjunction\"] = \"SCONJ\";\n    POSTags[\"symbol\"] = \"SYM\";\n    POSTags[\"verb\"] = \"VERB\";\n    POSTags[\"other\"] = \"X\";\n})(POSTags = exports.POSTags || (exports.POSTags = {}));\nvar DependencyLabels;\n(function (DependencyLabels) {\n    /*\n      Universal Dependencies\n      https://universaldependencies.org/u/dep/all.html\n    */\n    DependencyLabels[\"acl\"] = \"acl\";\n    DependencyLabels[\"advcl\"] = \"advcl\";\n    DependencyLabels[\"amod\"] = \"amod\";\n    DependencyLabels[\"advmod\"] = \"advmod\";\n    DependencyLabels[\"aux\"] = \"aux\";\n    DependencyLabels[\"aux_caus\"] = \"aux:caus\";\n    DependencyLabels[\"case\"] = \"case\";\n    DependencyLabels[\"ccomp\"] = \"ccomp\";\n    DependencyLabels[\"compound\"] = \"compound\";\n    DependencyLabels[\"compound_prt\"] = \"compound:prt\";\n    DependencyLabels[\"cop\"] = \"cop\";\n    DependencyLabels[\"csubj\"] = \"csubj\";\n    DependencyLabels[\"det\"] = \"det\";\n    DependencyLabels[\"dislocated\"] = \"dislocated\";\n    DependencyLabels[\"fix\"] = \"fix\";\n    DependencyLabels[\"flat\"] = \"flat\";\n    DependencyLabels[\"obj\"] = \"obj\";\n    DependencyLabels[\"iobj\"] = \"iobj\";\n    DependencyLabels[\"iobj_agent\"] = \"iobj:agent\";\n    DependencyLabels[\"mark\"] = \"mark\";\n    DependencyLabels[\"nmod\"] = \"nmod\";\n    DependencyLabels[\"nobj\"] = \"nobj\";\n    DependencyLabels[\"nsubj\"] = \"nsubj\";\n    DependencyLabels[\"nsubj_caus\"] = \"nsubj:caus\";\n    DependencyLabels[\"obl\"] = \"obl\";\n    DependencyLabels[\"prt\"] = \"prt\";\n    DependencyLabels[\"root\"] = \"root\";\n    DependencyLabels[\"xcomp\"] = \"xcomp\";\n})(DependencyLabels = exports.DependencyLabels || (exports.DependencyLabels = {}));\nvar Tagset;\n(function (Tagset) {\n    Tagset[\"AUX\"] = \"AUX\";\n    Tagset[\"AUXN\"] = \"AUXN\";\n    Tagset[\"ADJ\"] = \"ADJ\";\n    Tagset[\"ADNOM\"] = \"ADNOM\";\n    Tagset[\"ADV\"] = \"ADV\";\n    Tagset[\"APPR\"] = \"APPR\";\n    Tagset[\"CL\"] = \"CL\";\n    Tagset[\"CONJ\"] = \"CONJ\";\n    Tagset[\"FIL\"] = \"FIL\";\n    Tagset[\"INTJ\"] = \"INTJ\";\n    Tagset[\"NN\"] = \"NN\";\n    Tagset[\"NNP\"] = \"NNP\";\n    Tagset[\"NPR\"] = \"NPR\";\n    Tagset[\"NUM\"] = \"NUM\";\n    Tagset[\"NV\"] = \"NV\";\n    Tagset[\"NADJ\"] = \"NADJ\";\n    Tagset[\"NADV\"] = \"NADV\";\n    Tagset[\"PAR\"] = \"PAR\";\n    Tagset[\"PCS\"] = \"PCS\";\n    Tagset[\"PCO\"] = \"PCO\";\n    Tagset[\"PCJ\"] = \"PCJ\";\n    Tagset[\"PEND\"] = \"PEND\";\n    Tagset[\"PADV\"] = \"PADV\";\n    Tagset[\"PPV\"] = \"PPV\";\n    Tagset[\"PSUB\"] = \"PSUB\";\n    Tagset[\"PNC\"] = \"PNC\";\n    Tagset[\"PX\"] = \"PX\";\n    Tagset[\"SX\"] = \"SX\";\n    Tagset[\"SYM\"] = \"SYM\";\n    Tagset[\"VB\"] = \"VB\";\n})(Tagset = exports.Tagset || (exports.Tagset = {}));\nvar PronType;\n(function (PronType) {\n    /*\n      pronominal types\n      https://universaldependencies.org/u/feat/PronType.html\n    */\n    PronType[\"DEM\"] = \"Dem\";\n    PronType[\"PRS\"] = \"Prs\";\n    PronType[\"REL\"] = \"Rel\";\n})(PronType = exports.PronType || (exports.PronType = {}));\n//# sourceMappingURL=symbols.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst rules_1 = require(\"./rules\");\nconst symbols_1 = require(\"./symbols\");\nconst keywords_1 = require(\"./keywords\");\nclass RuleBasedTagger {\n    constructor() {\n        this.speeches = new Array();\n        this.rules = new rules_1.Rules();\n    }\n    generate(sequence, phrases) {\n        let cps = new Array();\n        if (phrases.length > 0) {\n            for (let ph of phrases) {\n                cps.push(ph);\n                //console.log(pat.elements)\n                if (ph instanceof rules_1.PhrasalVerb) {\n                    const pvwe = new rules_1.PhrasalVerbWithEnclitic(new keywords_1.VerbSurface(ph.elements[0].surface), new keywords_1.ParticleSurface(ph.elements[1].surface), new keywords_1.EncliticSurface('aw'));\n                    cps.push(pvwe);\n                }\n                else if (ph.pos === symbols_1.POSTags.verb) {\n                    const vwe = new rules_1.VerbWithEnclitic(new keywords_1.VerbSurface(sequence[0]), new keywords_1.EncliticSurface('aw'));\n                    cps.push(vwe);\n                }\n            }\n        }\n        else {\n            //console.log(sequence)\n            const vwe = new rules_1.VerbWithEnclitic(new keywords_1.VerbSurface(sequence[0]), new keywords_1.EncliticSurface('aw'));\n            cps.push(vwe);\n        }\n        //console.log(cps)\n        return cps;\n    }\n    tagKeyWord(kw) {\n        if (kw.pos === symbols_1.POSTags.pronoun) {\n            kw.tag = symbols_1.Tagset.NPR;\n        }\n        else if (kw.pos === symbols_1.POSTags.auxiliary)\n            kw.tag = symbols_1.Tagset.AUX;\n        else if (kw.pos === symbols_1.POSTags.particle)\n            kw.tag = symbols_1.Tagset.PADV;\n    }\n    matchSeperates(sequence, particle) {\n        let phrase = new rules_1.ConstructionOfSpeech();\n        let vs = new keywords_1.VerbSurface(sequence[0]);\n        vs.tag = symbols_1.Tagset.VB;\n        phrase.elements.push(vs);\n        phrase.pos = symbols_1.POSTags.verb;\n        if (sequence.length > 1) {\n            for (let i = 1; i < sequence.length; i++) {\n                // skip the first array element\n                let kw = this.rules.matchKeyWords(sequence[i]);\n                if (kw) {\n                    this.tagKeyWord(kw);\n                    phrase.elements.push(kw);\n                }\n                if (sequence[i] === particle) {\n                    let ps = new keywords_1.VerbSurface(sequence[i]);\n                    ps.tag = symbols_1.Tagset.VB;\n                    phrase.elements.push(ps);\n                    return phrase;\n                }\n            }\n        }\n    }\n    tagPhrases(phrases) {\n        if (phrases.length > 0) {\n            for (let ph of phrases) {\n                if (ph.pos === symbols_1.POSTags.verb && ph.elements[ph.elements.length - 1].pos === symbols_1.POSTags.particle) {\n                    ph.elements[0].tag = symbols_1.Tagset.VB;\n                    ph.elements[ph.elements.length - 1].tag = symbols_1.Tagset.PPV;\n                }\n                else if (ph.pos === symbols_1.POSTags.verb && ph.elements[ph.elements.length - 1].pos === symbols_1.POSTags.auxiliary) {\n                    //console.log('something else hit')\n                }\n                else if (ph.pos === symbols_1.POSTags.verb && ph.elements[ph.elements.length - 1].pos === symbols_1.POSTags.adposition) {\n                    ph.elements[0].tag = symbols_1.Tagset.VB;\n                    ph.elements[ph.elements.length - 1].tag = symbols_1.Tagset.APPR;\n                }\n            }\n        }\n        return phrases;\n    }\n    phrase(strs, beginOfPhrase) {\n        let sequence = [];\n        let phrss;\n        for (let i = beginOfPhrase; i < strs.length; i++) {\n            sequence.push(strs[i]);\n        }\n        phrss = this.rules.matches(sequence);\n        const ptcl = this.rules.seperateMatches(sequence[0]);\n        if (ptcl) {\n            const sep = this.matchSeperates(sequence, ptcl);\n            if (sep) {\n                phrss = [];\n                phrss = [sep];\n            }\n        }\n        if (!phrss) {\n            //console.log(sequence)\n            let kw = this.rules.matchKeyWords(sequence[0]);\n            if (kw) {\n                //console.log(kw)\n                this.tagKeyWord(kw);\n                phrss = [new rules_1.ConstructionOfSpeech()];\n                phrss[0].elements.push(kw);\n            }\n        }\n        //if(pats) console.log(pats[0].elements)\n        if (phrss)\n            phrss = this.tagPhrases(phrss);\n        let listCP = new Array();\n        if (phrss)\n            listCP = this.generate(sequence, phrss);\n        else\n            listCP = this.generate(sequence, []);\n        //console.log(listCP);\n        let matchedLen = 0;\n        let mp = new rules_1.ConstructionOfSpeech();\n        for (let m in listCP) {\n            const min = Math.min(strs.length - beginOfPhrase, listCP[m].elements.length);\n            if (listCP[m].elements.length == min) {\n                for (let n = 0; n < min; n++) {\n                    if (listCP[m].elements[n] != undefined) {\n                        if (strs[beginOfPhrase + n] === listCP[m].elements[n].surface) {\n                            if (n + 1 == min && min > matchedLen) {\n                                matchedLen = min;\n                                for (let q = 0; q < matchedLen; q++) {\n                                    mp.elements[q] = listCP[m].elements[q];\n                                    if (listCP[m].elements[q].surface === '') {\n                                        mp.elements[q].surface = strs[beginOfPhrase + q];\n                                    }\n                                }\n                                mp.pos = listCP[m].pos;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return mp;\n    }\n    tagSpeeches() {\n        for (let s of this.speeches) {\n            if (s.elements.length == 1 && s.elements[0].pos == symbols_1.POSTags.pronoun)\n                s.pos = symbols_1.POSTags.pronoun;\n            //console.log(s)\n            //console.log(s.elements)\n        }\n    }\n    match(tokens) {\n        let strs = [];\n        for (let i in tokens)\n            strs.push(tokens[i].text);\n        let beginOfPhrase = 0;\n        let matched = new rules_1.ConstructionOfSpeech();\n        for (let i = 0; i < strs.length; i++) {\n            if (i - beginOfPhrase == 0) {\n                matched = this.phrase(strs, beginOfPhrase);\n                //console.log(matched)\n                if (matched.elements.length) {\n                    beginOfPhrase += matched.elements.length;\n                    this.speeches.push(matched);\n                    this.tagSpeeches();\n                }\n            }\n        }\n    }\n    tag(doc) {\n        this.match(doc.tokens);\n        let ces = new Array();\n        for (let i in this.speeches) {\n            doc.speeches.push(this.speeches[i]);\n            for (let j in this.speeches[i].elements) {\n                ces.push(this.speeches[i].elements[j]);\n            }\n        }\n        for (let i = 0; i < ces.length; i++) {\n            if (doc.tokens[i].text === ces[i].surface) {\n                doc.tokens[i].pos = ces[i].pos;\n                doc.tokens[i].tag = ces[i].tag;\n            }\n        }\n        return doc;\n    }\n}\nexports.RuleBasedTagger = RuleBasedTagger;\n//# sourceMappingURL=tagger.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst character_1 = require(\"./character\");\n//------------------------------------------------------------------------------\nclass Grapheme {\n}\nclass AlphabeticGrapheme extends Grapheme {\n    constructor(letter) {\n        super();\n        this.letter = letter;\n    }\n}\nexports.AlphabeticGrapheme = AlphabeticGrapheme;\n//------------------------------------------------------------------------------\nclass Letter {\n    constructor() {\n        this.literal = '';\n    }\n}\nexports.Letter = Letter;\nclass AlphabeticLetter extends Letter {\n    constructor(characters) {\n        super();\n        this.characters = new Array();\n        if (characters != null) {\n            let len = characters.length;\n            for (var i = 0; i < len; i++) {\n                this.pushCharacter(characters[i]);\n            }\n        }\n    }\n    pushCharacter(c) {\n        this.characters.push(c);\n        this.literal += c.character;\n    }\n}\nexports.AlphabeticLetter = AlphabeticLetter;\nclass MatchedSequence {\n    constructor() {\n        this.characters = new Array();\n    }\n    get matchedLength() {\n        return this.characters.length;\n    }\n    toString() {\n        let str = '';\n        for (let i in this.characters) {\n            str += this.characters[i].character;\n        }\n        return str;\n    }\n}\nexports.MatchedSequence = MatchedSequence;\nclass Letters {\n    constructor(larr) {\n        this.o = new Map();\n        this.larr = larr;\n        for (let i = 0; i < this.larr.length; i++) {\n            this.assign(this.larr[i]);\n        }\n    }\n    assign(e) {\n        let carr = [];\n        for (let i = 0; i < e.length; i++) {\n            let c = character_1.characters.get(e[i]);\n            if (c) {\n                carr.push(c);\n            }\n        }\n        this.o.set(e, new AlphabeticLetter(carr));\n    }\n    get(key) {\n        let value = this.o.get(key);\n        if (value) {\n            return value;\n        }\n        return new AlphabeticLetter([]);\n    }\n    get size() {\n        return this.o.size;\n    }\n    get values() {\n        return this.o.values();\n    }\n}\nexports.Letters = Letters;\n//------------------------------------------------------------------------------\nclass GraphemeMaker {\n    constructor(lowerLetters) {\n        this.list = new Array();\n        this.list = Array.from(lowerLetters.values);\n    }\n    makeGraphemes(str) {\n        const characters = new Array();\n        if (str) {\n            for (var i = 0; i < str.length; i++) {\n                if (str.charAt(i) != '\\0') {\n                    characters.push(new character_1.Character(str.charAt(i)));\n                }\n            }\n        }\n        let graphemes = this.make(characters);\n        return graphemes;\n    }\n    getMatchedSequence(characters, beginOfLetter, candidates) {\n        let ms = new MatchedSequence();\n        let matchedLen = 0;\n        //console.log(characters)\n        if (characters[beginOfLetter].character === 'n') {\n            if (characters.length - beginOfLetter >= 'nng'.length) {\n                if (characters[beginOfLetter].character === 'n' &&\n                    characters[beginOfLetter + 1].character === 'n' &&\n                    characters[beginOfLetter + 2].character === 'g') {\n                    // at the beginning of a letter, we should always prefer 'n' to 'nn'\n                    // 'nn' is not able to begin a syllable\n                    // 'ng' has higher associativity than 'nn' when in 'nng'\n                    // special case for 'nng'\n                    // copy the matched letter\n                    ms.characters[0] = new character_1.Character('n');\n                    return ms;\n                }\n            }\n        }\n        for (let j in candidates) {\n            let min = Math.min(characters.length - beginOfLetter, candidates[j].literal.length);\n            if (candidates[j].literal.length == min) {\n                for (let k = 0; k < min; k++) {\n                    if (characters[beginOfLetter + k].character === candidates[j].literal[k]) {\n                        if (k + 1 == min && min > matchedLen) {\n                            // to make sure it is longer than previous patterns\n                            // last letter matched for the pattern\n                            matchedLen = min;\n                            // copy the matched letters\n                            for (let q = 0; q < matchedLen; q++) {\n                                ms.characters[q] = characters[beginOfLetter + q];\n                            }\n                        }\n                    }\n                    else {\n                        break;\n                    }\n                }\n            }\n        }\n        return ms;\n    }\n    make(characters) {\n        let graphemes = new Array();\n        //console.log(\"metadata letter array length %d. \", letters.length);\n        let beginOfLetter = 0;\n        let letters = new Array();\n        for (let i = 0; i < characters.length; i++) {\n            //console.log(\"examining character: %s. length of characters: %d\", characters[i].symbol, characters.length);\n            //console.log(\"metadata letter array looping.\");\n            if (i - beginOfLetter == 0) {\n                //console.log(\"matchedLen: %d\", ms.matchedLength);\n                let candidates = this.list.filter(l => l.characters[0].character === characters[i].character);\n                let ms = this.getMatchedSequence(characters, beginOfLetter, candidates);\n                if (ms.matchedLength > 0) {\n                    for (let key in candidates) {\n                        //console.log(candidates[key].literal + ' - ' + ms.toString())\n                        if (candidates[key].literal === new AlphabeticLetter(ms.characters).literal) {\n                            letters.push(candidates[key]);\n                        }\n                    }\n                }\n            }\n            if (letters.length == 0) {\n                for (let j in characters) {\n                    //console.log(characters[j].character)\n                }\n                // 'length of letters is zero'\n            }\n            else if (letters.length == 1) {\n                //console.log(\"just one matched. i:%d. ls[0].characters.length:%d. ls[0]:\", i, ls[0].characters.length, ls[0])\n                //console.log(\"just one matched. i:%d. ls[0].characters.length:%d\", i, ls[0].characters.length);\n                if (i + 1 - beginOfLetter == letters[0].characters.length) {\n                    // when index i plus one equals the length of the matched syllable\n                    let l = letters.shift();\n                    if (l) {\n                        beginOfLetter += l.characters.length;\n                        // pack letters into sounds\n                        let gr = new AlphabeticGrapheme(l);\n                        graphemes.push(gr);\n                    }\n                }\n            }\n        }\n        //console.log(\"metadata letter array length %d\", letters.length);\n        return graphemes;\n    }\n}\nexports.GraphemeMaker = GraphemeMaker;\n//------------------------------------------------------------------------------\nclass Sound {\n    constructor() {\n        this.name = '';\n        // an array of character objects. can be used to make a word object.\n        this.characters = new Array();\n    }\n    // we still need a method for combinning characters from each character objects.\n    // this is different from an array of character objects. it is a string.\n    toString() {\n        let l = '';\n        // there is no characters for 1st tone\n        if (this.characters != null) {\n            // when it is not 1st tone\n            for (let k in this.characters) {\n                l += this.characters[k].character;\n            }\n        }\n        return l;\n    }\n    makeCharacters(str) {\n        let arr = new Array();\n        for (let i = 0; i < str.length; i++) {\n            arr.push(new character_1.Character(str[i]));\n        }\n        return arr;\n    }\n}\nexports.Sound = Sound;\nclass SetOfSounds {\n    constructor() {\n        this.sounds = new Array();\n    }\n    includes(str) {\n        for (let i in this.sounds) {\n            if (str && this.sounds[i] && str === this.sounds[i].toString())\n                return true;\n        }\n        return false;\n    }\n}\nexports.SetOfSounds = SetOfSounds;\n//------------------------------------------------------------------------------\nexports.pipe = (...fns) => (x) => fns.reduce((v, f) => f(v), x);\nclass SoundGeneration {\n    constructor() {\n        this.letters = [];\n        this.sounds = new Array();\n        this.matching = true;\n        this.prompt = false;\n        this.prompts = new Array();\n        this.promptEuphonicFinal = false;\n    }\n}\nexports.SoundGeneration = SoundGeneration;\n//# sourceMappingURL=grapheme.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// client\nvar client_1 = require(\"./client\");\nexports.Client = client_1.Client;\n// API\nvar token_1 = require(\"./token\");\nexports.TokenAnalysis = token_1.TokenAnalysis;\nvar analyzer_1 = require(\"./tonal/analyzer\");\nexports.TonalLemmatizationAnalyzer = analyzer_1.TonalLemmatizationAnalyzer;\nexports.TonalLemmatizer = analyzer_1.TonalLemmatizer;\nvar analyzer_2 = require(\"./dparser/analyzer\");\nexports.TonalInflectionAnalyzer = analyzer_2.TonalInflectionAnalyzer;\nexports.TonalPhrasalInflector = analyzer_2.TonalPhrasalInflector;\nexports.TonalInflector = analyzer_2.TonalInflector;\nexports.TonalAssimilator = analyzer_2.TonalAssimilator;\nvar analyzer_3 = require(\"./kana/analyzer\");\nexports.KanaLemmatizationAnalyzer = analyzer_3.KanaLemmatizationAnalyzer;\nvar lexeme_1 = require(\"./dparser/lexeme\");\nexports.TonalDesinenceInflection = lexeme_1.TonalDesinenceInflection;\nexports.TransfixInflection = lexeme_1.TransfixInflection;\nexports.AgressiveAssimilation = lexeme_1.AgressiveAssimilation;\nexports.TonalInflectionLexeme = lexeme_1.TonalInflectionLexeme;\nvar morpheme_1 = require(\"./dparser/morpheme\");\nexports.TonalCombiningForms = morpheme_1.TonalCombiningForms;\nexports.ThirdCombiningForm = morpheme_1.ThirdCombiningForm;\nexports.AssimiDirection = morpheme_1.AssimiDirection;\nexports.TonalCombiningMorpheme = morpheme_1.TonalCombiningMorpheme;\nvar phraseme_1 = require(\"./dparser/phraseme\");\nexports.TonalTransitivePhraseme = phraseme_1.TonalTransitivePhraseme;\nexports.Adnominal = phraseme_1.Adnominal;\nvar grapheme_1 = require(\"./grapheme\");\nexports.GraphemeMaker = grapheme_1.GraphemeMaker;\nexports.Sound = grapheme_1.Sound;\nexports.SoundGeneration = grapheme_1.SoundGeneration;\nvar lexicalroots2_1 = require(\"./tonal/lexicalroots2\");\nexports.lexical_roots = lexicalroots2_1.lexical_roots;\nvar version2_1 = require(\"./tonal/version2\");\nexports.lowerLettersOfTonal = version2_1.lowerLettersOfTonal;\nvar morpheme_2 = require(\"./morpheme\");\nexports.TonalZeroCombining = morpheme_2.TonalZeroCombining;\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst grapheme_1 = require(\"../grapheme\");\nconst morpheme_1 = require(\"./morpheme\");\nconst kana_1 = require(\"./kana\");\nconst analyzer_1 = require(\"../analyzer\");\nconst morpheme_2 = require(\"../morpheme\");\n//------------------------------------------------------------------------------\nclass KanaLemmatizationAnalyzer extends analyzer_1.Analyzer {\n    graphAnalyze(str) {\n        // graphemic analysis\n        const gm = new grapheme_1.GraphemeMaker(kana_1.lowerLettersOfKana);\n        return gm.makeGraphemes(str);\n    }\n    morphAnalyze(x) {\n        // morphological analysis\n        let graphemes = [];\n        if (typeof x == 'object') {\n            graphemes = x;\n        }\n        else if (typeof x == 'string') {\n            graphemes = this.graphAnalyze(x);\n        }\n        const mm = new morpheme_1.KanaUncombiningMorphemeMaker(new morpheme_2.KanaCombiningMetaplasm());\n        return mm.makeInputingMorphemes(graphemes);\n    }\n}\nexports.KanaLemmatizationAnalyzer = KanaLemmatizationAnalyzer;\n//# sourceMappingURL=analyzer.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst kana_1 = require(\"./kana\");\nfunction checkLetterSizeKana() {\n    if (kana_1.kanaPositionalSound.size !== kana_1.lowerLettersOfKana.size) {\n        console.log('sizes unmatched');\n    }\n}\nexports.checkLetterSizeKana = checkLetterSizeKana;\nfunction checkChouon(previousLetter, nextLetter) {\n    if (previousLetter === nextLetter)\n        return true;\n    if (previousLetter === 'e' && nextLetter === 'i')\n        return true;\n    if (previousLetter === 'o' && nextLetter === 'u')\n        return true;\n    return false;\n}\nfunction lookup(str) {\n    let results = kana_1.hiragana_katakana.get(str);\n    if (results == undefined) {\n        results = kana_1.gailaigo.get(str);\n    }\n    return results;\n}\nfunction getKanaBlocks(ms) {\n    // string one is hiragana, string two is katakana, string 3 is chouon\n    let kana_compositions = ['', '', ''];\n    let previous = '';\n    for (let e of ms) {\n        let ks = lookup(e.syllable.literal);\n        if (ks != undefined && ks[0] != undefined) {\n            // in case the kana is absent, we check against ks[0]\n            kana_compositions[0] += ks[0];\n            kana_compositions[1] += ks[1];\n            if (previous.length > 0 &&\n                checkChouon(previous[previous.length - 1], e.syllable.literal[e.syllable.literal.length - 1]) &&\n                new kana_1.InitialConsonantSet().includes(e.syllable.literal) == false &&\n                e.syllable.literal.length == 1) {\n                // a vowel does not begin with a consonant and is of length 1\n                // a vowel follows a previous vowel\n                kana_compositions[2] += 'ã¼';\n            }\n            else {\n                kana_compositions[2] += ks[1];\n            }\n        }\n        else if (new kana_1.FinalConsonantSet().includes(e.syllable.literal[e.syllable.literal.length - 1]) == true) {\n            ks = lookup(e.syllable.literal.substring(0, e.syllable.literal.length - 1));\n            if (ks != undefined && ks[0] != undefined) {\n                kana_compositions[0] += ks[0];\n                kana_compositions[1] += ks[1];\n                kana_compositions[2] += ks[1];\n            }\n            if (new kana_1.Hatsuon().includes(e.syllable.literal[e.syllable.literal.length - 1])) {\n                ks = kana_1.hatsuon.get('n');\n                if (ks) {\n                    kana_compositions[0] += ks[0];\n                    kana_compositions[1] += ks[1];\n                    kana_compositions[2] += ks[1];\n                }\n            }\n            else {\n                ks = kana_1.kogakimoji.get('chu');\n                if (ks) {\n                    kana_compositions[0] += ks[0];\n                    kana_compositions[1] += ks[1];\n                    kana_compositions[2] += ks[1];\n                }\n            }\n        }\n        else {\n            let first = e.syllable.literal[0];\n            let second = e.syllable.literal[1];\n            if (first === second && new kana_1.GerminatedConsonantSet().includes(first) == true) {\n                ks = kana_1.kogakimoji.get('chu');\n                if (ks) {\n                    kana_compositions[0] += ks[0];\n                    kana_compositions[1] += ks[1];\n                    kana_compositions[2] += ks[1];\n                }\n                ks = kana_1.hiragana_katakana.get(e.syllable.literal.substring(1, e.syllable.literal.length));\n                if (ks) {\n                    kana_compositions[0] += ks[0];\n                    kana_compositions[1] += ks[1];\n                    kana_compositions[2] += ks[1];\n                }\n            }\n        }\n        previous = e.syllable.literal;\n    }\n    // remove duplicates\n    if (kana_compositions[1] === kana_compositions[2])\n        kana_compositions[2] = '';\n    return kana_compositions;\n}\nexports.getKanaBlocks = getKanaBlocks;\n//# sourceMappingURL=init.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst grapheme_1 = require(\"../grapheme\");\n//------------------------------------------------------------------------------\nvar KanaLetterTags;\n(function (KanaLetterTags) {\n    KanaLetterTags[\"a\"] = \"a\";\n    KanaLetterTags[\"e\"] = \"e\";\n    KanaLetterTags[\"i\"] = \"i\";\n    KanaLetterTags[\"o\"] = \"o\";\n    KanaLetterTags[\"u\"] = \"u\";\n    KanaLetterTags[\"b\"] = \"b\";\n    KanaLetterTags[\"c\"] = \"c\";\n    KanaLetterTags[\"ch\"] = \"ch\";\n    KanaLetterTags[\"d\"] = \"d\";\n    KanaLetterTags[\"f\"] = \"f\";\n    KanaLetterTags[\"g\"] = \"g\";\n    KanaLetterTags[\"h\"] = \"h\";\n    KanaLetterTags[\"j\"] = \"j\";\n    KanaLetterTags[\"k\"] = \"k\";\n    KanaLetterTags[\"l\"] = \"l\";\n    KanaLetterTags[\"m\"] = \"m\";\n    KanaLetterTags[\"r\"] = \"r\";\n    KanaLetterTags[\"s\"] = \"s\";\n    KanaLetterTags[\"v\"] = \"v\";\n    KanaLetterTags[\"z\"] = \"z\";\n    KanaLetterTags[\"p\"] = \"p\";\n    KanaLetterTags[\"t\"] = \"t\";\n    KanaLetterTags[\"w\"] = \"w\";\n    KanaLetterTags[\"y\"] = \"y\";\n    KanaLetterTags[\"n\"] = \"n\";\n    KanaLetterTags[\"ng\"] = \"ng\";\n})(KanaLetterTags || (KanaLetterTags = {}));\nclass LettersOfKana extends grapheme_1.Letters {\n}\nexports.LettersOfKana = LettersOfKana;\nexports.lowerLettersOfKana = new LettersOfKana([\n    KanaLetterTags.a,\n    KanaLetterTags.e,\n    KanaLetterTags.i,\n    KanaLetterTags.o,\n    KanaLetterTags.u,\n    KanaLetterTags.b,\n    KanaLetterTags.c,\n    KanaLetterTags.ch,\n    KanaLetterTags.d,\n    KanaLetterTags.f,\n    KanaLetterTags.g,\n    KanaLetterTags.h,\n    KanaLetterTags.j,\n    KanaLetterTags.k,\n    KanaLetterTags.l,\n    KanaLetterTags.m,\n    KanaLetterTags.r,\n    KanaLetterTags.s,\n    KanaLetterTags.v,\n    KanaLetterTags.z,\n    KanaLetterTags.p,\n    KanaLetterTags.t,\n    KanaLetterTags.w,\n    KanaLetterTags.y,\n    KanaLetterTags.n,\n    KanaLetterTags.ng,\n]);\n//------------------------------------------------------------------------------\nvar KanaSoundTags;\n(function (KanaSoundTags) {\n    KanaSoundTags[\"germinatedConsonant\"] = \"germinatedConsonant\";\n    KanaSoundTags[\"initialConsonant\"] = \"initialConsonant\";\n    KanaSoundTags[\"semivowel\"] = \"semivowel\";\n    KanaSoundTags[\"vowel\"] = \"vowel\";\n    KanaSoundTags[\"finalConsonant\"] = \"finalConsonant\";\n})(KanaSoundTags = exports.KanaSoundTags || (exports.KanaSoundTags = {}));\nclass GerminatedConsonant extends grapheme_1.Sound {\n    constructor() {\n        super(...arguments);\n        this.name = KanaSoundTags.germinatedConsonant;\n    }\n}\nclass InitialConsonant extends grapheme_1.Sound {\n    constructor() {\n        super(...arguments);\n        this.name = KanaSoundTags.initialConsonant;\n    }\n}\nclass Semivowel extends grapheme_1.Sound {\n    constructor() {\n        super(...arguments);\n        this.name = KanaSoundTags.semivowel;\n    }\n}\nclass Vowel extends grapheme_1.Sound {\n    constructor() {\n        super(...arguments);\n        this.name = KanaSoundTags.vowel;\n    }\n}\nclass FinalConsonant extends grapheme_1.Sound {\n    constructor() {\n        super(...arguments);\n        this.name = KanaSoundTags.finalConsonant;\n    }\n}\nclass InitialConsonantB extends InitialConsonant {\n    constructor() {\n        super(...arguments);\n        this.characters = this.makeCharacters(KanaLetterTags.b);\n    }\n}\nclass InitialConsonantC extends InitialConsonant {\n    constructor() {\n        super(...arguments);\n        this.characters = this.makeCharacters(KanaLetterTags.c);\n    }\n}\nclass InitialConsonantCH extends InitialConsonant {\n    constructor() {\n        super(...arguments);\n        this.characters = this.makeCharacters(KanaLetterTags.ch);\n    }\n}\nclass InitialConsonantD extends InitialConsonant {\n    constructor() {\n        super(...arguments);\n        this.characters = this.makeCharacters(KanaLetterTags.d);\n    }\n}\nclass InitialConsonantF extends InitialConsonant {\n    constructor() {\n        super(...arguments);\n        this.characters = this.makeCharacters(KanaLetterTags.f);\n    }\n}\nclass InitialConsonantG extends InitialConsonant {\n    constructor() {\n        super(...arguments);\n        this.characters = this.makeCharacters(KanaLetterTags.g);\n    }\n}\nclass InitialConsonantH extends InitialConsonant {\n    constructor() {\n        super(...arguments);\n        this.characters = this.makeCharacters(KanaLetterTags.h);\n    }\n}\nclass InitialConsonantJ extends InitialConsonant {\n    constructor() {\n        super(...arguments);\n        this.characters = this.makeCharacters(KanaLetterTags.j);\n    }\n}\nclass InitialConsonantK extends InitialConsonant {\n    constructor() {\n        super(...arguments);\n        this.characters = this.makeCharacters(KanaLetterTags.k);\n    }\n}\nclass InitialConsonantL extends InitialConsonant {\n    constructor() {\n        super(...arguments);\n        this.characters = this.makeCharacters(KanaLetterTags.l);\n    }\n}\nclass InitialConsonantM extends InitialConsonant {\n    constructor() {\n        super(...arguments);\n        this.characters = this.makeCharacters(KanaLetterTags.m);\n    }\n}\nclass InitialConsonantN extends InitialConsonant {\n    constructor() {\n        super(...arguments);\n        this.characters = this.makeCharacters(KanaLetterTags.n);\n    }\n}\nclass InitialConsonantNG extends InitialConsonant {\n    constructor() {\n        super(...arguments);\n        this.characters = this.makeCharacters(KanaLetterTags.ng);\n    }\n}\nclass InitialConsonantP extends InitialConsonant {\n    constructor() {\n        super(...arguments);\n        this.characters = this.makeCharacters(KanaLetterTags.p);\n    }\n}\nclass InitialConsonantR extends InitialConsonant {\n    constructor() {\n        super(...arguments);\n        this.characters = this.makeCharacters(KanaLetterTags.r);\n    }\n}\nclass InitialConsonantS extends InitialConsonant {\n    constructor() {\n        super(...arguments);\n        this.characters = this.makeCharacters(KanaLetterTags.s);\n    }\n}\nclass InitialConsonantT extends InitialConsonant {\n    constructor() {\n        super(...arguments);\n        this.characters = this.makeCharacters(KanaLetterTags.t);\n    }\n}\nclass InitialConsonantV extends InitialConsonant {\n    constructor() {\n        super(...arguments);\n        this.characters = this.makeCharacters(KanaLetterTags.v);\n    }\n}\nclass InitialConsonantW extends InitialConsonant {\n    constructor() {\n        super(...arguments);\n        this.characters = this.makeCharacters(KanaLetterTags.w);\n    }\n}\nclass InitialConsonantY extends InitialConsonant {\n    constructor() {\n        super(...arguments);\n        this.characters = this.makeCharacters(KanaLetterTags.y);\n    }\n}\nclass InitialConsonantZ extends InitialConsonant {\n    constructor() {\n        super(...arguments);\n        this.characters = this.makeCharacters(KanaLetterTags.z);\n    }\n}\nclass SemivowelW extends Semivowel {\n    constructor() {\n        super(...arguments);\n        this.characters = this.makeCharacters(KanaLetterTags.w);\n    }\n}\nclass SemivowelY extends Semivowel {\n    constructor() {\n        super(...arguments);\n        this.characters = this.makeCharacters(KanaLetterTags.y);\n    }\n}\nclass VowelA extends Vowel {\n    constructor() {\n        super(...arguments);\n        this.characters = this.makeCharacters(KanaLetterTags.a);\n    }\n}\nclass VowelE extends Vowel {\n    constructor() {\n        super(...arguments);\n        this.characters = this.makeCharacters(KanaLetterTags.e);\n    }\n}\nclass VowelI extends Vowel {\n    constructor() {\n        super(...arguments);\n        this.characters = this.makeCharacters(KanaLetterTags.i);\n    }\n}\nclass VowelO extends Vowel {\n    constructor() {\n        super(...arguments);\n        this.characters = this.makeCharacters(KanaLetterTags.o);\n    }\n}\nclass VowelU extends Vowel {\n    constructor() {\n        super(...arguments);\n        this.characters = this.makeCharacters(KanaLetterTags.u);\n    }\n}\nclass FinalConsonantB extends FinalConsonant {\n    constructor() {\n        super(...arguments);\n        this.characters = this.makeCharacters(KanaLetterTags.b);\n    }\n}\nclass FinalConsonantD extends FinalConsonant {\n    constructor() {\n        super(...arguments);\n        this.characters = this.makeCharacters(KanaLetterTags.d);\n    }\n}\nclass FinalConsonantG extends FinalConsonant {\n    constructor() {\n        super(...arguments);\n        this.characters = this.makeCharacters(KanaLetterTags.g);\n    }\n}\nclass FinalConsonantK extends FinalConsonant {\n    constructor() {\n        super(...arguments);\n        this.characters = this.makeCharacters(KanaLetterTags.k);\n    }\n}\nclass FinalConsonantH extends FinalConsonant {\n    constructor() {\n        super(...arguments);\n        this.characters = this.makeCharacters(KanaLetterTags.h);\n    }\n}\nclass FinalConsonantN extends FinalConsonant {\n    constructor() {\n        super(...arguments);\n        this.characters = this.makeCharacters(KanaLetterTags.n);\n    }\n}\nclass FinalConsonantP extends FinalConsonant {\n    constructor() {\n        super(...arguments);\n        this.characters = this.makeCharacters(KanaLetterTags.p);\n    }\n}\nclass FinalConsonantS extends FinalConsonant {\n    constructor() {\n        super(...arguments);\n        this.characters = this.makeCharacters(KanaLetterTags.s);\n    }\n}\nclass FinalConsonantT extends FinalConsonant {\n    constructor() {\n        super(...arguments);\n        this.characters = this.makeCharacters(KanaLetterTags.t);\n    }\n}\nclass GerminatedConsonantB extends GerminatedConsonant {\n    constructor() {\n        super(...arguments);\n        this.characters = this.makeCharacters(KanaLetterTags.b);\n    }\n}\nclass GerminatedConsonantC extends GerminatedConsonant {\n    constructor() {\n        super(...arguments);\n        this.characters = this.makeCharacters(KanaLetterTags.c);\n    }\n}\nclass GerminatedConsonantD extends GerminatedConsonant {\n    constructor() {\n        super(...arguments);\n        this.characters = this.makeCharacters(KanaLetterTags.d);\n    }\n}\nclass GerminatedConsonantG extends GerminatedConsonant {\n    constructor() {\n        super(...arguments);\n        this.characters = this.makeCharacters(KanaLetterTags.g);\n    }\n}\nclass GerminatedConsonantK extends GerminatedConsonant {\n    constructor() {\n        super(...arguments);\n        this.characters = this.makeCharacters(KanaLetterTags.k);\n    }\n}\nclass GerminatedConsonantP extends GerminatedConsonant {\n    constructor() {\n        super(...arguments);\n        this.characters = this.makeCharacters(KanaLetterTags.p);\n    }\n}\nclass GerminatedConsonantS extends GerminatedConsonant {\n    constructor() {\n        super(...arguments);\n        this.characters = this.makeCharacters(KanaLetterTags.s);\n    }\n}\nclass GerminatedConsonantT extends GerminatedConsonant {\n    constructor() {\n        super(...arguments);\n        this.characters = this.makeCharacters(KanaLetterTags.t);\n    }\n}\nclass InitialConsonantSet extends grapheme_1.SetOfSounds {\n    constructor() {\n        super();\n        this.sounds.push(new InitialConsonantB());\n        this.sounds.push(new InitialConsonantC());\n        this.sounds.push(new InitialConsonantCH());\n        this.sounds.push(new InitialConsonantD());\n        this.sounds.push(new InitialConsonantF());\n        this.sounds.push(new InitialConsonantG());\n        this.sounds.push(new InitialConsonantH());\n        this.sounds.push(new InitialConsonantJ());\n        this.sounds.push(new InitialConsonantK());\n        this.sounds.push(new InitialConsonantL());\n        this.sounds.push(new InitialConsonantM());\n        this.sounds.push(new InitialConsonantN());\n        this.sounds.push(new InitialConsonantNG());\n        this.sounds.push(new InitialConsonantP());\n        this.sounds.push(new InitialConsonantR());\n        this.sounds.push(new InitialConsonantS());\n        this.sounds.push(new InitialConsonantT());\n        this.sounds.push(new InitialConsonantV());\n        this.sounds.push(new InitialConsonantW());\n        this.sounds.push(new InitialConsonantY());\n        this.sounds.push(new InitialConsonantZ());\n    }\n}\nexports.InitialConsonantSet = InitialConsonantSet;\nclass VowelSet extends grapheme_1.SetOfSounds {\n    constructor() {\n        super();\n        this.sounds.push(new VowelA());\n        this.sounds.push(new VowelI());\n        this.sounds.push(new VowelU());\n        this.sounds.push(new VowelE());\n        this.sounds.push(new VowelO());\n    }\n}\nexports.VowelSet = VowelSet;\nclass GerminatedConsonantSet extends grapheme_1.SetOfSounds {\n    constructor() {\n        super();\n        this.sounds.push(new GerminatedConsonantB());\n        this.sounds.push(new GerminatedConsonantC());\n        this.sounds.push(new GerminatedConsonantD());\n        this.sounds.push(new GerminatedConsonantG());\n        this.sounds.push(new GerminatedConsonantK());\n        this.sounds.push(new GerminatedConsonantP());\n        this.sounds.push(new GerminatedConsonantS());\n        this.sounds.push(new GerminatedConsonantT());\n    }\n}\nexports.GerminatedConsonantSet = GerminatedConsonantSet;\nclass SemivowelSet extends grapheme_1.SetOfSounds {\n    constructor() {\n        super();\n        this.sounds.push(new SemivowelW());\n        this.sounds.push(new SemivowelY());\n    }\n}\nexports.SemivowelSet = SemivowelSet;\nclass FinalConsonantSet extends grapheme_1.SetOfSounds {\n    constructor() {\n        super();\n        this.sounds.push(new FinalConsonantB());\n        this.sounds.push(new FinalConsonantD());\n        this.sounds.push(new FinalConsonantG());\n        this.sounds.push(new FinalConsonantK());\n        this.sounds.push(new FinalConsonantN());\n        this.sounds.push(new FinalConsonantP());\n        this.sounds.push(new FinalConsonantS());\n        this.sounds.push(new FinalConsonantT());\n    }\n}\nexports.FinalConsonantSet = FinalConsonantSet;\nclass Hatsuon extends grapheme_1.SetOfSounds {\n    constructor() {\n        super();\n        this.sounds.push(new FinalConsonantN());\n    }\n}\nexports.Hatsuon = Hatsuon;\n//------------------------------------------------------------------------------\nfunction positionalSound(sounds) {\n    return (t) => {\n        for (let i in sounds) {\n            if (sounds[i].name === t)\n                return sounds[i];\n        }\n        return new grapheme_1.Sound();\n    };\n}\nexports.positionalSound = positionalSound;\nconst ps_a = positionalSound([new VowelA()]);\nconst ps_b = positionalSound([new InitialConsonantB(), new FinalConsonantB(), new GerminatedConsonantB()]);\nconst ps_c = positionalSound([new InitialConsonantC(), new GerminatedConsonantC()]);\nconst ps_ch = positionalSound([new InitialConsonantCH()]);\nconst ps_d = positionalSound([new InitialConsonantD(), new FinalConsonantD(), new GerminatedConsonantD()]);\nconst ps_e = positionalSound([new VowelE()]);\nconst ps_f = positionalSound([new InitialConsonantF()]);\nconst ps_g = positionalSound([new InitialConsonantG(), new FinalConsonantG(), new GerminatedConsonantG()]);\nconst ps_h = positionalSound([new InitialConsonantH()]);\nconst ps_i = positionalSound([new VowelI()]);\nconst ps_j = positionalSound([new InitialConsonantJ()]);\nconst ps_k = positionalSound([new InitialConsonantK(), new FinalConsonantK(), new GerminatedConsonantK()]);\nconst ps_l = positionalSound([new InitialConsonantL()]);\nconst ps_m = positionalSound([new InitialConsonantM()]);\nconst ps_n = positionalSound([new InitialConsonantN(), new FinalConsonantN()]);\nconst ps_ng = positionalSound([new InitialConsonantNG()]);\nconst ps_o = positionalSound([new VowelO()]);\nconst ps_p = positionalSound([new InitialConsonantP(), new FinalConsonantP(), new GerminatedConsonantP()]);\nconst ps_r = positionalSound([new InitialConsonantR()]);\nconst ps_s = positionalSound([new InitialConsonantS(), new FinalConsonantS(), new GerminatedConsonantS()]);\nconst ps_t = positionalSound([new InitialConsonantT(), new FinalConsonantT(), new GerminatedConsonantT()]);\nconst ps_u = positionalSound([new VowelU()]);\nconst ps_v = positionalSound([new InitialConsonantV()]);\nconst ps_w = positionalSound([new InitialConsonantW(), new SemivowelW()]);\nconst ps_y = positionalSound([new InitialConsonantY(), new SemivowelY()]);\nconst ps_z = positionalSound([new InitialConsonantZ()]);\n//------------------------------------------------------------------------------\nexports.kanaPositionalSound = new Map()\n    .set(KanaLetterTags.a, ps_a)\n    .set(KanaLetterTags.b, ps_b)\n    .set(KanaLetterTags.c, ps_c)\n    .set(KanaLetterTags.ch, ps_ch)\n    .set(KanaLetterTags.d, ps_d)\n    .set(KanaLetterTags.e, ps_e)\n    .set(KanaLetterTags.f, ps_f)\n    .set(KanaLetterTags.g, ps_g)\n    .set(KanaLetterTags.h, ps_h)\n    .set(KanaLetterTags.i, ps_i)\n    .set(KanaLetterTags.j, ps_j)\n    .set(KanaLetterTags.k, ps_k)\n    .set(KanaLetterTags.l, ps_l)\n    .set(KanaLetterTags.m, ps_m)\n    .set(KanaLetterTags.n, ps_n)\n    .set(KanaLetterTags.ng, ps_ng)\n    .set(KanaLetterTags.o, ps_o)\n    .set(KanaLetterTags.p, ps_p)\n    .set(KanaLetterTags.r, ps_r)\n    .set(KanaLetterTags.s, ps_s)\n    .set(KanaLetterTags.t, ps_t)\n    .set(KanaLetterTags.u, ps_u)\n    .set(KanaLetterTags.v, ps_v)\n    .set(KanaLetterTags.w, ps_w)\n    .set(KanaLetterTags.y, ps_y)\n    .set(KanaLetterTags.z, ps_z);\n//------------------------------------------------------------------------------\nexports.kogakimoji = new Map().set(KanaLetterTags.ch + KanaLetterTags.u, ['ã£', 'ã']);\nexports.hatsuon = new Map().set(KanaLetterTags.n, ['ã', 'ã³']);\nexports.others = new Map()\n    .set(KanaLetterTags.a, ['ã', 'ã¡'])\n    .set(KanaLetterTags.i, ['ã', 'ã£'])\n    .set(KanaLetterTags.u, ['ã', 'ã¥'])\n    .set(KanaLetterTags.e, ['ã', 'ã§'])\n    .set(KanaLetterTags.o, ['ã', 'ã©'])\n    .set(KanaLetterTags.h + KanaLetterTags.a, ['', 'ãµ'])\n    .set(KanaLetterTags.h + KanaLetterTags.i, ['', 'ã¶'])\n    .set(KanaLetterTags.f + KanaLetterTags.u, ['', 'ã·'])\n    .set(KanaLetterTags.h + KanaLetterTags.e, ['', 'ã¸'])\n    .set(KanaLetterTags.h + KanaLetterTags.o, ['', 'ã¹'])\n    .set(KanaLetterTags.k + KanaLetterTags.a, ['ã', 'ãµ'])\n    .set(KanaLetterTags.k + KanaLetterTags.e, ['ã', 'ã¶'])\n    .set(KanaLetterTags.k + KanaLetterTags.u, ['', 'ã°'])\n    .set(KanaLetterTags.r + KanaLetterTags.a, ['', 'ã»'])\n    .set(KanaLetterTags.r + KanaLetterTags.i, ['', 'ã¼'])\n    .set(KanaLetterTags.r + KanaLetterTags.u, ['', 'ã½'])\n    .set(KanaLetterTags.r + KanaLetterTags.e, ['', 'ã¾'])\n    .set(KanaLetterTags.r + KanaLetterTags.o, ['', 'ã¿'])\n    .set(KanaLetterTags.m + KanaLetterTags.u, ['', 'ãº'])\n    .set(KanaLetterTags.n + KanaLetterTags.u, ['', 'ã´'])\n    .set(KanaLetterTags.p + KanaLetterTags.u, ['', 'ã·ã'])\n    .set(KanaLetterTags.s + KanaLetterTags.i, ['', 'ã±'])\n    .set(KanaLetterTags.s + KanaLetterTags.u, ['', 'ã²'])\n    .set(KanaLetterTags.t + KanaLetterTags.o, ['', 'ã³'])\n    .set(KanaLetterTags.y + KanaLetterTags.a, ['ã', 'ã£'])\n    .set(KanaLetterTags.y + KanaLetterTags.u, ['ã', 'ã¥'])\n    .set(KanaLetterTags.y + KanaLetterTags.o, ['ã', 'ã§'])\n    .set(KanaLetterTags.w + KanaLetterTags.a, ['ã', 'ã®']);\nexports.hiragana_katakana = new Map()\n    .set(KanaLetterTags.a, ['ã', 'ã¢'])\n    .set(KanaLetterTags.i, ['ã', 'ã¤'])\n    .set(KanaLetterTags.u, ['ã', 'ã¦'])\n    .set(KanaLetterTags.e, ['ã', 'ã¨'])\n    .set(KanaLetterTags.o, ['ã', 'ãª'])\n    .set(KanaLetterTags.k + KanaLetterTags.a, ['ã', 'ã«'])\n    .set(KanaLetterTags.k + KanaLetterTags.i, ['ã', 'ã­'])\n    .set(KanaLetterTags.k + KanaLetterTags.u, ['ã', 'ã¯'])\n    .set(KanaLetterTags.k + KanaLetterTags.e, ['ã', 'ã±'])\n    .set(KanaLetterTags.k + KanaLetterTags.o, ['ã', 'ã³'])\n    .set(KanaLetterTags.s + KanaLetterTags.a, ['ã', 'ãµ'])\n    .set(KanaLetterTags.s + KanaLetterTags.i, ['ã', 'ã·'])\n    .set(KanaLetterTags.s + KanaLetterTags.u, ['ã', 'ã¹'])\n    .set(KanaLetterTags.s + KanaLetterTags.e, ['ã', 'ã»'])\n    .set(KanaLetterTags.s + KanaLetterTags.o, ['ã', 'ã½'])\n    .set(KanaLetterTags.t + KanaLetterTags.a, ['ã', 'ã¿'])\n    .set(KanaLetterTags.c + KanaLetterTags.i, ['ã¡', 'ã'])\n    .set(KanaLetterTags.ch + KanaLetterTags.u, ['ã¤', 'ã'])\n    .set(KanaLetterTags.t + KanaLetterTags.e, ['ã¦', 'ã'])\n    .set(KanaLetterTags.t + KanaLetterTags.o, ['ã¨', 'ã'])\n    .set(KanaLetterTags.n + KanaLetterTags.a, ['ãª', 'ã'])\n    .set(KanaLetterTags.n + KanaLetterTags.i, ['ã«', 'ã'])\n    .set(KanaLetterTags.n + KanaLetterTags.u, ['ã¬', 'ã'])\n    .set(KanaLetterTags.n + KanaLetterTags.e, ['ã­', 'ã'])\n    .set(KanaLetterTags.n + KanaLetterTags.o, ['ã®', 'ã'])\n    .set(KanaLetterTags.h + KanaLetterTags.a, ['ã¯', 'ã'])\n    .set(KanaLetterTags.h + KanaLetterTags.i, ['ã²', 'ã'])\n    .set(KanaLetterTags.f + KanaLetterTags.u, ['ãµ', 'ã'])\n    .set(KanaLetterTags.h + KanaLetterTags.e, ['ã¸', 'ã'])\n    .set(KanaLetterTags.h + KanaLetterTags.o, ['ã»', 'ã'])\n    .set(KanaLetterTags.m + KanaLetterTags.a, ['ã¾', 'ã'])\n    .set(KanaLetterTags.m + KanaLetterTags.i, ['ã¿', 'ã'])\n    .set(KanaLetterTags.m + KanaLetterTags.u, ['ã', 'ã '])\n    .set(KanaLetterTags.m + KanaLetterTags.e, ['ã', 'ã¡'])\n    .set(KanaLetterTags.m + KanaLetterTags.o, ['ã', 'ã¢'])\n    .set(KanaLetterTags.y + KanaLetterTags.a, ['ã', 'ã¤'])\n    .set(KanaLetterTags.y + KanaLetterTags.u, ['ã', 'ã¦'])\n    .set(KanaLetterTags.y + KanaLetterTags.o, ['ã', 'ã¨'])\n    .set(KanaLetterTags.r + KanaLetterTags.a, ['ã', 'ã©'])\n    .set(KanaLetterTags.r + KanaLetterTags.i, ['ã', 'ãª'])\n    .set(KanaLetterTags.r + KanaLetterTags.u, ['ã', 'ã«'])\n    .set(KanaLetterTags.r + KanaLetterTags.e, ['ã', 'ã¬'])\n    .set(KanaLetterTags.r + KanaLetterTags.o, ['ã', 'ã­'])\n    .set(KanaLetterTags.w + KanaLetterTags.a, ['ã', 'ã¯'])\n    .set(KanaLetterTags.w + KanaLetterTags.i, ['ã', 'ã°'])\n    .set(KanaLetterTags.w + KanaLetterTags.e, ['ã', 'ã±'])\n    .set(KanaLetterTags.w + KanaLetterTags.o, ['ã', 'ã²'])\n    .set(KanaLetterTags.g + KanaLetterTags.a, ['ã', 'ã¬'])\n    .set(KanaLetterTags.g + KanaLetterTags.i, ['ã', 'ã®'])\n    .set(KanaLetterTags.g + KanaLetterTags.u, ['ã', 'ã°'])\n    .set(KanaLetterTags.g + KanaLetterTags.e, ['ã', 'ã²'])\n    .set(KanaLetterTags.g + KanaLetterTags.o, ['ã', 'ã´'])\n    .set(KanaLetterTags.z + KanaLetterTags.a, ['ã', 'ã¶'])\n    .set(KanaLetterTags.j + KanaLetterTags.i, ['ã', 'ã¸'])\n    .set(KanaLetterTags.z + KanaLetterTags.u, ['ã', 'ãº'])\n    .set(KanaLetterTags.z + KanaLetterTags.e, ['ã', 'ã¼'])\n    .set(KanaLetterTags.z + KanaLetterTags.o, ['ã', 'ã¾'])\n    .set(KanaLetterTags.d + KanaLetterTags.a, ['ã ', 'ã'])\n    .set(KanaLetterTags.d + KanaLetterTags.e, ['ã§', 'ã'])\n    .set(KanaLetterTags.d + KanaLetterTags.o, ['ã©', 'ã'])\n    .set(KanaLetterTags.b + KanaLetterTags.a, ['ã°', 'ã'])\n    .set(KanaLetterTags.b + KanaLetterTags.i, ['ã³', 'ã'])\n    .set(KanaLetterTags.b + KanaLetterTags.u, ['ã¶', 'ã'])\n    .set(KanaLetterTags.b + KanaLetterTags.e, ['ã¹', 'ã'])\n    .set(KanaLetterTags.b + KanaLetterTags.o, ['ã¼', 'ã'])\n    .set(KanaLetterTags.p + KanaLetterTags.a, ['ã±', 'ã'])\n    .set(KanaLetterTags.p + KanaLetterTags.i, ['ã´', 'ã'])\n    .set(KanaLetterTags.p + KanaLetterTags.u, ['ã·', 'ã'])\n    .set(KanaLetterTags.p + KanaLetterTags.e, ['ãº', 'ã'])\n    .set(KanaLetterTags.p + KanaLetterTags.o, ['ã½', 'ã'])\n    .set(KanaLetterTags.k + KanaLetterTags.y + KanaLetterTags.a, ['ãã', 'ã­ã£'])\n    .set(KanaLetterTags.k + KanaLetterTags.y + KanaLetterTags.u, ['ãã', 'ã­ã¥'])\n    .set(KanaLetterTags.k + KanaLetterTags.y + KanaLetterTags.o, ['ãã', 'ã­ã§'])\n    .set(KanaLetterTags.s + KanaLetterTags.y + KanaLetterTags.a, ['ãã', 'ã·ã£'])\n    .set(KanaLetterTags.s + KanaLetterTags.y + KanaLetterTags.u, ['ãã', 'ã·ã¥'])\n    .set(KanaLetterTags.s + KanaLetterTags.y + KanaLetterTags.o, ['ãã', 'ã·ã§'])\n    .set(KanaLetterTags.c + KanaLetterTags.y + KanaLetterTags.a, ['ã¡ã', 'ãã£'])\n    .set(KanaLetterTags.c + KanaLetterTags.y + KanaLetterTags.u, ['ã¡ã', 'ãã¥'])\n    .set(KanaLetterTags.c + KanaLetterTags.y + KanaLetterTags.o, ['ã¡ã', 'ãã§'])\n    .set(KanaLetterTags.n + KanaLetterTags.y + KanaLetterTags.a, ['ã«ã', 'ãã£'])\n    .set(KanaLetterTags.n + KanaLetterTags.y + KanaLetterTags.u, ['ã«ã', 'ãã¥'])\n    .set(KanaLetterTags.n + KanaLetterTags.y + KanaLetterTags.o, ['ã«ã', 'ãã§'])\n    .set(KanaLetterTags.h + KanaLetterTags.y + KanaLetterTags.a, ['ã²ã', 'ãã£'])\n    .set(KanaLetterTags.h + KanaLetterTags.y + KanaLetterTags.u, ['ã²ã', 'ãã¥'])\n    .set(KanaLetterTags.h + KanaLetterTags.y + KanaLetterTags.o, ['ã²ã', 'ãã§'])\n    .set(KanaLetterTags.m + KanaLetterTags.y + KanaLetterTags.a, ['ã¿ã', 'ãã£'])\n    .set(KanaLetterTags.m + KanaLetterTags.y + KanaLetterTags.u, ['ã¿ã', 'ã¿ã'])\n    .set(KanaLetterTags.m + KanaLetterTags.y + KanaLetterTags.o, ['ãã¥', 'ãã§'])\n    .set(KanaLetterTags.r + KanaLetterTags.y + KanaLetterTags.a, ['ãã', 'ãªã£'])\n    .set(KanaLetterTags.r + KanaLetterTags.y + KanaLetterTags.u, ['ãã', 'ãªã¥'])\n    .set(KanaLetterTags.r + KanaLetterTags.y + KanaLetterTags.o, ['ãã', 'ãªã§'])\n    .set(KanaLetterTags.g + KanaLetterTags.y + KanaLetterTags.a, ['ãã', 'ã®ã£'])\n    .set(KanaLetterTags.g + KanaLetterTags.y + KanaLetterTags.u, ['ãã', 'ã®ã¥'])\n    .set(KanaLetterTags.g + KanaLetterTags.y + KanaLetterTags.o, ['ãã', 'ã®ã§'])\n    .set(KanaLetterTags.j + KanaLetterTags.a, ['ãã', 'ã¸ã£'])\n    .set(KanaLetterTags.j + KanaLetterTags.u, ['ãã', 'ã¸ã¥'])\n    .set(KanaLetterTags.j + KanaLetterTags.o, ['ãã', 'ã¸ã§'])\n    .set(KanaLetterTags.j + KanaLetterTags.y + KanaLetterTags.a, ['ã¢ã', 'ãã£'])\n    .set(KanaLetterTags.j + KanaLetterTags.y + KanaLetterTags.u, ['ã¢ãã', 'ãã¥'])\n    .set(KanaLetterTags.j + KanaLetterTags.y + KanaLetterTags.o, ['ã¢ãã', 'ãã§'])\n    .set(KanaLetterTags.b + KanaLetterTags.y + KanaLetterTags.a, ['ã³ã', 'ãã£'])\n    .set(KanaLetterTags.b + KanaLetterTags.y + KanaLetterTags.u, ['ã³ã', 'ãã¥'])\n    .set(KanaLetterTags.b + KanaLetterTags.y + KanaLetterTags.o, ['ã³ã', 'ãã§'])\n    .set(KanaLetterTags.p + KanaLetterTags.y + KanaLetterTags.a, ['ã´ã', 'ãã£'])\n    .set(KanaLetterTags.p + KanaLetterTags.y + KanaLetterTags.u, ['ã´ã', 'ãã¥'])\n    .set(KanaLetterTags.p + KanaLetterTags.y + KanaLetterTags.o, ['ã´ã', 'ãã§']);\nexports.gailaigo = new Map()\n    .set(KanaLetterTags.s + KanaLetterTags.i, ['', 'ã¹ã£'])\n    .set(KanaLetterTags.s + KanaLetterTags.y + KanaLetterTags.e, ['', 'ã·ã§'])\n    .set(KanaLetterTags.z + KanaLetterTags.i, ['', 'ãºã£'])\n    .set(KanaLetterTags.j + KanaLetterTags.e, ['', 'ã¸ã§'])\n    .set(KanaLetterTags.j + KanaLetterTags.w + KanaLetterTags.a, ['', 'ã¸ã¥ã¡'])\n    .set(KanaLetterTags.j + KanaLetterTags.w + KanaLetterTags.i, ['', 'ã¸ã¥ã£'])\n    .set(KanaLetterTags.j + KanaLetterTags.w + KanaLetterTags.e, ['', 'ã¸ã¥ã§'])\n    .set(KanaLetterTags.j + KanaLetterTags.w + KanaLetterTags.o, ['', 'ã¸ã¥ã©'])\n    .set(KanaLetterTags.t + KanaLetterTags.i, ['', 'ãã£'])\n    .set(KanaLetterTags.t + KanaLetterTags.u, ['', 'ãã¥'])\n    .set(KanaLetterTags.c + KanaLetterTags.y + KanaLetterTags.e, ['', 'ãã§'])\n    .set(KanaLetterTags.j + KanaLetterTags.y + KanaLetterTags.e, ['', 'ãã§'])\n    .set(KanaLetterTags.c + KanaLetterTags.w + KanaLetterTags.a, ['', 'ãã¥ã¡'])\n    .set(KanaLetterTags.c + KanaLetterTags.w + KanaLetterTags.i, ['', 'ãã¥ã£'])\n    .set(KanaLetterTags.c + KanaLetterTags.w + KanaLetterTags.e, ['', 'ãã¥ã§'])\n    .set(KanaLetterTags.c + KanaLetterTags.w + KanaLetterTags.o, ['', 'ãã¥ã©'])\n    .set(KanaLetterTags.ch + KanaLetterTags.a, ['', 'ãã¡'])\n    .set(KanaLetterTags.ch + KanaLetterTags.i, ['', 'ãã£'])\n    .set(KanaLetterTags.ch + KanaLetterTags.e, ['', 'ãã§'])\n    .set(KanaLetterTags.ch + KanaLetterTags.o, ['', 'ãã©'])\n    .set(KanaLetterTags.d + KanaLetterTags.i, ['', 'ãã£'])\n    .set(KanaLetterTags.d + KanaLetterTags.u, ['', 'ãã¥'])\n    .set(KanaLetterTags.f + KanaLetterTags.a, ['', 'ãã¡'])\n    .set(KanaLetterTags.f + KanaLetterTags.i, ['', 'ãã£'])\n    .set(KanaLetterTags.f + KanaLetterTags.e, ['', 'ãã§'])\n    .set(KanaLetterTags.f + KanaLetterTags.o, ['', 'ãã©'])\n    .set(KanaLetterTags.y + KanaLetterTags.i, ['', 'ã¤ã£'])\n    .set(KanaLetterTags.y + KanaLetterTags.e, ['', 'ã¤ã§'])\n    .set(KanaLetterTags.w + KanaLetterTags.a, ['', 'ã¦ã¡'])\n    .set(KanaLetterTags.w + KanaLetterTags.a, ['', 'ã¦ã£'])\n    .set(KanaLetterTags.w + KanaLetterTags.a, ['', 'ã¦ã§'])\n    .set(KanaLetterTags.w + KanaLetterTags.a, ['', 'ã¦ã©'])\n    .set(KanaLetterTags.v + KanaLetterTags.a, ['', 'ã´ã¡'])\n    .set(KanaLetterTags.v + KanaLetterTags.i, ['', 'ã´ã£'])\n    .set(KanaLetterTags.v + KanaLetterTags.u, ['', 'ã´'])\n    .set(KanaLetterTags.v + KanaLetterTags.e, ['', 'ã´ã§'])\n    .set(KanaLetterTags.v + KanaLetterTags.o, ['', 'ã´ã©']);\nexports.gailaigo_y = new Map()\n    .set(KanaLetterTags.k + KanaLetterTags.y + KanaLetterTags.i, ['', 'ã­ã£'])\n    .set(KanaLetterTags.k + KanaLetterTags.y + KanaLetterTags.e, ['', 'ã­ã§'])\n    .set(KanaLetterTags.g + KanaLetterTags.y + KanaLetterTags.i, ['', 'ã®ã£'])\n    .set(KanaLetterTags.g + KanaLetterTags.y + KanaLetterTags.e, ['', 'ã®ã§'])\n    .set(KanaLetterTags.s + KanaLetterTags.y + KanaLetterTags.a, ['', 'ã¹ã£'])\n    .set(KanaLetterTags.s + KanaLetterTags.y + KanaLetterTags.u, ['', 'ã¹ã¥'])\n    .set(KanaLetterTags.s + KanaLetterTags.y + KanaLetterTags.e, ['', 'ã¹ã£ã§'])\n    .set(KanaLetterTags.s + KanaLetterTags.y + KanaLetterTags.o, ['', 'ã¹ã§'])\n    .set(KanaLetterTags.z + KanaLetterTags.y + KanaLetterTags.a, ['', 'ãºã£'])\n    .set(KanaLetterTags.z + KanaLetterTags.y + KanaLetterTags.u, ['', 'ãºã¥'])\n    .set(KanaLetterTags.z + KanaLetterTags.y + KanaLetterTags.e, ['', 'ãºã£ã§'])\n    .set(KanaLetterTags.z + KanaLetterTags.y + KanaLetterTags.o, ['', 'ãºã§'])\n    .set(KanaLetterTags.t + KanaLetterTags.y + KanaLetterTags.a, ['', 'ãã£'])\n    .set(KanaLetterTags.t + KanaLetterTags.y + KanaLetterTags.u, ['', 'ãã¥'])\n    .set(KanaLetterTags.t + KanaLetterTags.y + KanaLetterTags.e, ['', 'ãã£ã§'])\n    .set(KanaLetterTags.t + KanaLetterTags.y + KanaLetterTags.o, ['', 'ãã§'])\n    .set(KanaLetterTags.d + KanaLetterTags.y + KanaLetterTags.a, ['', 'ãã£'])\n    .set(KanaLetterTags.d + KanaLetterTags.y + KanaLetterTags.u, ['', 'ãã¥'])\n    .set(KanaLetterTags.d + KanaLetterTags.y + KanaLetterTags.e, ['', 'ãã§', 'ãã£ã§'])\n    .set(KanaLetterTags.d + KanaLetterTags.y + KanaLetterTags.o, ['', 'ãã§'])\n    .set(KanaLetterTags.n + KanaLetterTags.y + KanaLetterTags.i, ['', 'ãã£'])\n    .set(KanaLetterTags.n + KanaLetterTags.y + KanaLetterTags.e, ['', 'ãã§'])\n    .set(KanaLetterTags.h + KanaLetterTags.y + KanaLetterTags.i, ['', 'ãã£'])\n    .set(KanaLetterTags.h + KanaLetterTags.y + KanaLetterTags.e, ['', 'ãã§'])\n    .set(KanaLetterTags.f + KanaLetterTags.y + KanaLetterTags.a, ['', 'ãã£'])\n    .set(KanaLetterTags.f + KanaLetterTags.y + KanaLetterTags.u, ['', 'ãã¥'])\n    .set(KanaLetterTags.f + KanaLetterTags.y + KanaLetterTags.e, ['', 'ãã£ã§'])\n    .set(KanaLetterTags.f + KanaLetterTags.y + KanaLetterTags.o, ['', 'ãã§'])\n    .set(KanaLetterTags.b + KanaLetterTags.y + KanaLetterTags.e, ['', 'ãã§'])\n    .set(KanaLetterTags.p + KanaLetterTags.y + KanaLetterTags.e, ['', 'ãã§'])\n    .set(KanaLetterTags.m + KanaLetterTags.y + KanaLetterTags.i, ['', 'ãã£'])\n    .set(KanaLetterTags.m + KanaLetterTags.y + KanaLetterTags.e, ['', 'ãã§'])\n    .set(KanaLetterTags.r + KanaLetterTags.y + KanaLetterTags.i, ['', 'ãªã£'])\n    .set(KanaLetterTags.r + KanaLetterTags.y + KanaLetterTags.e, ['', 'ãªã§'])\n    .set(KanaLetterTags.w + KanaLetterTags.y + KanaLetterTags.a, ['', 'ã¦ã£'])\n    .set(KanaLetterTags.w + KanaLetterTags.y + KanaLetterTags.u, ['', 'ã¦ã¥'])\n    .set(KanaLetterTags.w + KanaLetterTags.y + KanaLetterTags.o, ['', 'ã¦ã§'])\n    .set(KanaLetterTags.v + KanaLetterTags.y + KanaLetterTags.a, ['', 'ã´ã£'])\n    .set(KanaLetterTags.v + KanaLetterTags.y + KanaLetterTags.u, ['', 'ã´ã¥'])\n    .set(KanaLetterTags.v + KanaLetterTags.y + KanaLetterTags.e, ['', 'ã´ã£ã§'])\n    .set(KanaLetterTags.v + KanaLetterTags.y + KanaLetterTags.o, ['', 'ã´ã§']);\nexports.gailaigo_w = new Map()\n    .set(KanaLetterTags.k + KanaLetterTags.w + KanaLetterTags.a, ['', 'ã¯ã¡'])\n    .set(KanaLetterTags.k + KanaLetterTags.w + KanaLetterTags.i, ['', 'ã¯ã£'])\n    .set(KanaLetterTags.k + KanaLetterTags.w + KanaLetterTags.u, ['', 'ã¯ã¥'])\n    .set(KanaLetterTags.k + KanaLetterTags.w + KanaLetterTags.e, ['', 'ã¯ã§'])\n    .set(KanaLetterTags.k + KanaLetterTags.w + KanaLetterTags.o, ['', 'ã¯ã©'])\n    .set(KanaLetterTags.g + KanaLetterTags.w + KanaLetterTags.a, ['', 'ã°ã¡'])\n    .set(KanaLetterTags.g + KanaLetterTags.w + KanaLetterTags.i, ['', 'ã°ã£'])\n    .set(KanaLetterTags.g + KanaLetterTags.w + KanaLetterTags.u, ['', 'ã°ã¥'])\n    .set(KanaLetterTags.g + KanaLetterTags.w + KanaLetterTags.e, ['', 'ã°ã§'])\n    .set(KanaLetterTags.g + KanaLetterTags.w + KanaLetterTags.o, ['', 'ã°ã©'])\n    .set(KanaLetterTags.s + KanaLetterTags.w + KanaLetterTags.a, ['', 'ã¹ã¡'])\n    .set(KanaLetterTags.s + KanaLetterTags.w + KanaLetterTags.i, ['', 'ã¹ã¥ã£'])\n    .set(KanaLetterTags.s + KanaLetterTags.w + KanaLetterTags.e, ['', 'ã¹ã§'])\n    .set(KanaLetterTags.s + KanaLetterTags.w + KanaLetterTags.o, ['', 'ã¹ã©'])\n    .set(KanaLetterTags.z + KanaLetterTags.w + KanaLetterTags.e, ['', 'ãºã§'])\n    .set(KanaLetterTags.t + KanaLetterTags.w + KanaLetterTags.a, ['', 'ãã¡'])\n    .set(KanaLetterTags.t + KanaLetterTags.w + KanaLetterTags.i, ['', 'ãã£'])\n    .set(KanaLetterTags.t + KanaLetterTags.w + KanaLetterTags.e, ['', 'ãã§'])\n    .set(KanaLetterTags.t + KanaLetterTags.w + KanaLetterTags.o, ['', 'ãã©'])\n    .set(KanaLetterTags.d + KanaLetterTags.w + KanaLetterTags.a, ['', 'ãã¡'])\n    .set(KanaLetterTags.d + KanaLetterTags.w + KanaLetterTags.i, ['', 'ãã£'])\n    .set(KanaLetterTags.d + KanaLetterTags.w + KanaLetterTags.e, ['', 'ãã§'])\n    .set(KanaLetterTags.d + KanaLetterTags.w + KanaLetterTags.o, ['', 'ãã©'])\n    .set(KanaLetterTags.n + KanaLetterTags.w + KanaLetterTags.a, ['', 'ãã¡'])\n    .set(KanaLetterTags.n + KanaLetterTags.w + KanaLetterTags.i, ['', 'ãã£'])\n    .set(KanaLetterTags.n + KanaLetterTags.w + KanaLetterTags.e, ['', 'ãã§'])\n    .set(KanaLetterTags.n + KanaLetterTags.w + KanaLetterTags.o, ['', 'ãã©'])\n    .set(KanaLetterTags.b + KanaLetterTags.w + KanaLetterTags.a, ['', 'ãã¡'])\n    .set(KanaLetterTags.b + KanaLetterTags.w + KanaLetterTags.i, ['', 'ãã£'])\n    .set(KanaLetterTags.b + KanaLetterTags.w + KanaLetterTags.e, ['', 'ãã§'])\n    .set(KanaLetterTags.b + KanaLetterTags.w + KanaLetterTags.o, ['', 'ãã©'])\n    .set(KanaLetterTags.p + KanaLetterTags.w + KanaLetterTags.a, ['', 'ãã¡'])\n    .set(KanaLetterTags.p + KanaLetterTags.w + KanaLetterTags.i, ['', 'ãã£'])\n    .set(KanaLetterTags.p + KanaLetterTags.w + KanaLetterTags.e, ['', 'ãã§'])\n    .set(KanaLetterTags.p + KanaLetterTags.w + KanaLetterTags.o, ['', 'ãã©'])\n    .set(KanaLetterTags.m + KanaLetterTags.w + KanaLetterTags.a, ['', 'ã ã¡'])\n    .set(KanaLetterTags.m + KanaLetterTags.w + KanaLetterTags.i, ['', 'ã ã£'])\n    .set(KanaLetterTags.m + KanaLetterTags.w + KanaLetterTags.e, ['', 'ã ã§'])\n    .set(KanaLetterTags.m + KanaLetterTags.w + KanaLetterTags.o, ['', 'ã ã©'])\n    .set(KanaLetterTags.r + KanaLetterTags.w + KanaLetterTags.a, ['', 'ã«ã¡'])\n    .set(KanaLetterTags.r + KanaLetterTags.w + KanaLetterTags.i, ['', 'ã«ã£'])\n    .set(KanaLetterTags.r + KanaLetterTags.w + KanaLetterTags.e, ['', 'ã«ã§'])\n    .set(KanaLetterTags.r + KanaLetterTags.w + KanaLetterTags.o, ['', 'ã«ã©']);\nexports.special = new Map()\n    .set(KanaLetterTags.ng + KanaLetterTags.a, ['', 'ã«ã'])\n    .set(KanaLetterTags.ng + KanaLetterTags.i, ['', 'ã­ã'])\n    .set(KanaLetterTags.ng + KanaLetterTags.u, ['', 'ã¯ã'])\n    .set(KanaLetterTags.ng + KanaLetterTags.e, ['', 'ã±ã'])\n    .set(KanaLetterTags.ng + KanaLetterTags.o, ['', 'ã³ã'])\n    .set(KanaLetterTags.s + KanaLetterTags.i, ['', 'ã»ã£'])\n    .set(KanaLetterTags.z + KanaLetterTags.i, ['', 'ã¼ã£'])\n    .set(KanaLetterTags.s + KanaLetterTags.y + KanaLetterTags.i, ['', 'ã·ã£'])\n    .set(KanaLetterTags.j + KanaLetterTags.i, ['', 'ã¸ã£'])\n    .set(KanaLetterTags.c + KanaLetterTags.y + KanaLetterTags.i, ['', 'ãã£'])\n    .set(KanaLetterTags.ch + KanaLetterTags.u, ['', 'ãã¥'])\n    .set(KanaLetterTags.j + KanaLetterTags.y + KanaLetterTags.i, ['', 'ãã£'])\n    .set(KanaLetterTags.h + KanaLetterTags.u, ['', 'ãã¥'])\n    .set(KanaLetterTags.f + KanaLetterTags.u, ['', 'ãã¥'])\n    .set(KanaLetterTags.y + KanaLetterTags.e, ['', 'ã¦ã§'])\n    .set(KanaLetterTags.l + KanaLetterTags.a, ['', 'ã©ã'])\n    .set(KanaLetterTags.l + KanaLetterTags.i, ['', 'ãªã'])\n    .set(KanaLetterTags.l + KanaLetterTags.u, ['', 'ã«ã'])\n    .set(KanaLetterTags.l + KanaLetterTags.e, ['', 'ã¬ã'])\n    .set(KanaLetterTags.l + KanaLetterTags.o, ['', 'ã­ã'])\n    .set(KanaLetterTags.w + KanaLetterTags.u, ['', 'ã¦ã¥'])\n    .set(KanaLetterTags.v + KanaLetterTags.a, ['', 'ã·'])\n    .set(KanaLetterTags.v + KanaLetterTags.i, ['', 'ã¸'])\n    .set(KanaLetterTags.v + KanaLetterTags.e, ['', 'ã¹'])\n    .set(KanaLetterTags.v + KanaLetterTags.o, ['', 'ãº']);\nexports.special_y = new Map()\n    .set(KanaLetterTags.ng + KanaLetterTags.y + KanaLetterTags.a, ['', 'ã­ãã£'])\n    .set(KanaLetterTags.ng + KanaLetterTags.y + KanaLetterTags.u, ['', 'ã­ãã¥'])\n    .set(KanaLetterTags.ng + KanaLetterTags.y + KanaLetterTags.o, ['', 'ã­ãã§'])\n    .set(KanaLetterTags.t + KanaLetterTags.y + KanaLetterTags.e, ['', 'ãã§'])\n    .set(KanaLetterTags.ch + KanaLetterTags.y + KanaLetterTags.a, ['', 'ãã£'])\n    .set(KanaLetterTags.ch + KanaLetterTags.y + KanaLetterTags.u, ['', 'ãã¥'])\n    .set(KanaLetterTags.ch + KanaLetterTags.y + KanaLetterTags.o, ['', 'ãã§'])\n    .set(KanaLetterTags.b + KanaLetterTags.y + KanaLetterTags.i, ['', 'ãã£'])\n    .set(KanaLetterTags.p + KanaLetterTags.y + KanaLetterTags.i, ['', 'ãã£'])\n    .set(KanaLetterTags.l + KanaLetterTags.y + KanaLetterTags.a, ['', 'ãªãã£'])\n    .set(KanaLetterTags.l + KanaLetterTags.y + KanaLetterTags.u, ['', 'ãªãã¥'])\n    .set(KanaLetterTags.l + KanaLetterTags.y + KanaLetterTags.o, ['', 'ãªãã§'])\n    .set(KanaLetterTags.w + KanaLetterTags.y + KanaLetterTags.a, ['', 'ã°ã£'])\n    .set(KanaLetterTags.w + KanaLetterTags.y + KanaLetterTags.u, ['', 'ã°ã¥'])\n    .set(KanaLetterTags.w + KanaLetterTags.y + KanaLetterTags.o, ['', 'ã°ã§']);\nexports.special_w = new Map()\n    .set(KanaLetterTags.k + KanaLetterTags.w + KanaLetterTags.a, ['', 'ã¯ã®'])\n    .set(KanaLetterTags.g + KanaLetterTags.w + KanaLetterTags.a, ['', 'ã°ã®'])\n    .set(KanaLetterTags.s + KanaLetterTags.w + KanaLetterTags.u, ['', 'ã¹ã¥'])\n    .set(KanaLetterTags.z + KanaLetterTags.w + KanaLetterTags.a, ['', 'ãºã¡'])\n    .set(KanaLetterTags.z + KanaLetterTags.w + KanaLetterTags.i, ['', 'ãºã¥ã£'])\n    .set(KanaLetterTags.z + KanaLetterTags.w + KanaLetterTags.e, ['', 'ãºã¥'])\n    .set(KanaLetterTags.z + KanaLetterTags.w + KanaLetterTags.o, ['', 'ãºã©'])\n    .set(KanaLetterTags.t + KanaLetterTags.w + KanaLetterTags.a, ['', 'ãã¥ã¡'])\n    .set(KanaLetterTags.t + KanaLetterTags.w + KanaLetterTags.i, ['', 'ãã¥ã£'])\n    .set(KanaLetterTags.t + KanaLetterTags.w + KanaLetterTags.u, ['', 'ãã¥ã¥'])\n    .set(KanaLetterTags.t + KanaLetterTags.w + KanaLetterTags.e, ['', 'ãã¥ã§'])\n    .set(KanaLetterTags.t + KanaLetterTags.w + KanaLetterTags.o, ['', 'ãã¥ã©'])\n    .set(KanaLetterTags.d + KanaLetterTags.w + KanaLetterTags.a, ['', 'ãã¥ã¡'])\n    .set(KanaLetterTags.d + KanaLetterTags.w + KanaLetterTags.i, ['', 'ãã¥ã£'])\n    .set(KanaLetterTags.d + KanaLetterTags.w + KanaLetterTags.u, ['', 'ãã¥ã¥'])\n    .set(KanaLetterTags.d + KanaLetterTags.w + KanaLetterTags.e, ['', 'ãã¥ã§'])\n    .set(KanaLetterTags.d + KanaLetterTags.w + KanaLetterTags.o, ['', 'ãã¥ã©'])\n    .set(KanaLetterTags.n + KanaLetterTags.w + KanaLetterTags.u, ['', 'ãã¥'])\n    .set(KanaLetterTags.h + KanaLetterTags.w + KanaLetterTags.a, ['', 'ãã¥ã¡'])\n    .set(KanaLetterTags.h + KanaLetterTags.w + KanaLetterTags.i, ['', 'ãã¥ã£'])\n    .set(KanaLetterTags.h + KanaLetterTags.w + KanaLetterTags.u, ['', 'ãã¥ã¥'])\n    .set(KanaLetterTags.h + KanaLetterTags.w + KanaLetterTags.e, ['', 'ãã¥ã§'])\n    .set(KanaLetterTags.h + KanaLetterTags.w + KanaLetterTags.o, ['', 'ãã¥ã©'])\n    .set(KanaLetterTags.b + KanaLetterTags.w + KanaLetterTags.u, ['', 'ãã¥'])\n    .set(KanaLetterTags.p + KanaLetterTags.w + KanaLetterTags.u, ['', 'ãã¥'])\n    .set(KanaLetterTags.m + KanaLetterTags.w + KanaLetterTags.u, ['', 'ã ã¥'])\n    .set(KanaLetterTags.v + KanaLetterTags.w + KanaLetterTags.a, ['', 'ã´ã¥ã¡'])\n    .set(KanaLetterTags.v + KanaLetterTags.w + KanaLetterTags.i, ['', 'ã´ã¥ã£'])\n    .set(KanaLetterTags.v + KanaLetterTags.w + KanaLetterTags.u, ['', 'ã´ã¥ã¥'])\n    .set(KanaLetterTags.v + KanaLetterTags.w + KanaLetterTags.e, ['', 'ã´ã¥ã§'])\n    .set(KanaLetterTags.v + KanaLetterTags.w + KanaLetterTags.o, ['', 'ã´ã¥ã©']);\nexports.special_h = new Map()\n    .set(KanaLetterTags.t + KanaLetterTags.h + KanaLetterTags.a, ['', 'ãã¡'])\n    .set(KanaLetterTags.t + KanaLetterTags.h + KanaLetterTags.u, ['', 'ãã¥'])\n    .set(KanaLetterTags.t + KanaLetterTags.h + KanaLetterTags.o, ['', 'ãã©'])\n    .set(KanaLetterTags.d + KanaLetterTags.h + KanaLetterTags.a, ['', 'ãã¡'])\n    .set(KanaLetterTags.d + KanaLetterTags.h + KanaLetterTags.u, ['', 'ãã¥'])\n    .set(KanaLetterTags.d + KanaLetterTags.h + KanaLetterTags.o, ['', 'ãã©']);\n//# sourceMappingURL=kana.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst morpheme_1 = require(\"../morpheme\");\nconst morpheme_2 = require(\"../morpheme\");\nconst kana_1 = require(\"./kana\");\nconst soundgen_1 = require(\"./soundgen\");\n//------------------------------------------------------------------------------\nclass KanaSyllable extends morpheme_1.Syllable {\n}\nexports.KanaSyllable = KanaSyllable;\n//------------------------------------------------------------------------------\nclass KanaUncombiningMorpheme extends morpheme_1.Morpheme {\n    constructor(syllable, sounds, kcm) {\n        super();\n        this.syllable = syllable;\n        this.metaplasm = kcm;\n        this.sounds = new Array();\n        this.sounds = sounds;\n    }\n}\nexports.KanaUncombiningMorpheme = KanaUncombiningMorpheme;\n//------------------------------------------------------------------------------\nfunction syllabifyKana(letters, beginOfSyllable) {\n    let literal = '';\n    let matched = '';\n    let lookahead = '';\n    let ltrs = new Array();\n    let matchedLtrs = new Array();\n    const sov = new kana_1.VowelSet();\n    for (let i = beginOfSyllable; i < letters.length; i++) {\n        literal = literal + letters[i].literal;\n        ltrs.push(letters[i].literal);\n        if (kana_1.hiragana_katakana.has(literal) || kana_1.gailaigo.has(literal)) {\n            matched = literal;\n            Object.assign(matchedLtrs, ltrs);\n            if (i + 1 < letters.length)\n                lookahead = letters[i + 1].literal; // look-ahead\n        }\n        else {\n            if (literal.length == 3 && literal[0] === literal[1] && sov.includes(literal[2])) {\n                // for consonant germination of sokuon\n                matched = literal;\n                ltrs.shift(); // shift the germinated consonants\n                Object.assign(matchedLtrs, ltrs);\n            }\n        }\n    }\n    let list = new Array();\n    if (matched.length > 0) {\n        //console.log(matchedLtrs, lookahead)\n        const ksg = new soundgen_1.KanaSoundGenerator();\n        list = ksg.generate(matchedLtrs, lookahead);\n        // console.log(list)\n    }\n    let arraysOfLetters = new Array();\n    let mp = new morpheme_1.MatchedPattern();\n    let sounds = new Array();\n    for (let m in list) {\n        let min = Math.min(letters.length - beginOfSyllable, list[m].length);\n        if (list[m].length == min) {\n            for (let n = 0; n < min; n++) {\n                if (list[m][n] != undefined) {\n                    if (letters[beginOfSyllable + n].literal === list[m][n].toString()) {\n                        if (n + 1 == min) {\n                            // copy the matched letters\n                            let arr = new Array();\n                            for (let q = 0; q < min; q++) {\n                                arr[q] = letters[beginOfSyllable + q];\n                            }\n                            arraysOfLetters.push(arr);\n                            sounds = list[m];\n                        }\n                    }\n                    else {\n                        break;\n                    }\n                }\n            }\n        }\n    }\n    if (arraysOfLetters.length == 1) {\n        // only one matched\n        // copy the matched letters\n        for (let q = 0; q < arraysOfLetters[0].length; q++) {\n            mp.letters[q] = letters[beginOfSyllable + q];\n            mp.pattern[q] = sounds[q];\n        }\n        return mp;\n    }\n    if (arraysOfLetters.length > 1) {\n        let longerEntry = -1; // length of the longest matched entry\n        let shorterEntry = -1;\n        let index = 0;\n        for (let j = 0; j < arraysOfLetters.length; j++) {\n            if (arraysOfLetters[j].length > arraysOfLetters[index].length) {\n                index = j;\n            }\n        }\n        if (index > 0) {\n            longerEntry = index;\n            shorterEntry = 0;\n        }\n        else {\n            longerEntry = 0;\n            shorterEntry = 1;\n        }\n        if (letters.length - beginOfSyllable == arraysOfLetters[longerEntry].length) {\n            if (new kana_1.Hatsuon().includes(arraysOfLetters[longerEntry][arraysOfLetters[longerEntry].length - 1].literal)) {\n                // return the longer one\n                for (let q = 0; q < arraysOfLetters[longerEntry].length; q++) {\n                    mp.letters[q] = letters[beginOfSyllable + q];\n                    mp.pattern[q] = sounds[q];\n                }\n                return mp;\n            }\n            // return the shorter one\n            for (let q = 0; q < arraysOfLetters[shorterEntry].length; q++) {\n                mp.letters[q] = letters[beginOfSyllable + q];\n                mp.pattern[q] = sounds[q];\n            }\n            return mp;\n        }\n        // look ahead for 1 letter\n        if (letters.length - beginOfSyllable == arraysOfLetters[longerEntry].length + 1) {\n            if (new kana_1.InitialConsonantSet().includes(letters[beginOfSyllable + arraysOfLetters[longerEntry].length].literal) == true) {\n                // consonant-ending\n                // return the longer one\n                for (let q = 0; q < arraysOfLetters[longerEntry].length; q++) {\n                    mp.letters[q] = letters[beginOfSyllable + q];\n                    mp.pattern[q] = sounds[q];\n                }\n            }\n            else {\n                // vowel ending\n                // return the shorter one\n                for (let q = 0; q < arraysOfLetters[shorterEntry].length; q++) {\n                    mp.letters[q] = letters[beginOfSyllable + q];\n                    mp.pattern[q] = sounds[q];\n                }\n            }\n            return mp;\n        }\n        // look ahead for 2 letters\n        if (letters.length - beginOfSyllable > arraysOfLetters[longerEntry].length + 1) {\n            if (new kana_1.VowelSet().includes(letters[beginOfSyllable + arraysOfLetters[longerEntry].length].literal) ==\n                true ||\n                new kana_1.SemivowelSet().includes(letters[beginOfSyllable + arraysOfLetters[longerEntry].length].literal) ==\n                    true) {\n                // return the shorter one\n                for (let q = 0; q < arraysOfLetters[shorterEntry].length; q++) {\n                    mp.letters[q] = letters[beginOfSyllable + q];\n                    mp.pattern[q] = sounds[q];\n                }\n                return mp;\n            }\n            // return the longer one\n            for (let q = 0; q < arraysOfLetters[longerEntry].length; q++) {\n                mp.letters[q] = letters[beginOfSyllable + q];\n                mp.pattern[q] = sounds[q];\n            }\n        }\n    }\n    return mp;\n}\n//------------------------------------------------------------------------------\nclass KanaUncombiningMorphemeMaker extends morpheme_2.MorphemeMaker {\n    constructor(kcm) {\n        super();\n        this.metaplasm = kcm;\n    }\n    createMorphemes() {\n        return new Array();\n    }\n    createMorpheme(msp) {\n        return new KanaUncombiningMorpheme(new KanaSyllable(msp.letters), msp.pattern, this.metaplasm);\n    }\n    postprocess(patterns) {\n        let morphemes = this.createMorphemes();\n        for (let i in patterns) {\n            morphemes.push(this.createMorpheme(patterns[i]));\n        }\n        return morphemes;\n    }\n    makeInputingMorphemes(gs) {\n        const ltrs = gs.map(it => it.letter);\n        const ptrns = this.make(ltrs, syllabifyKana);\n        const ms = this.postprocess(ptrns);\n        return ms;\n    }\n}\nexports.KanaUncombiningMorphemeMaker = KanaUncombiningMorphemeMaker;\n//# sourceMappingURL=morpheme.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst grapheme_1 = require(\"../grapheme\");\nconst kana_1 = require(\"./kana\");\nfunction initialConsonant(sg) {\n    const sics = new kana_1.InitialConsonantSet();\n    if (sics.includes(sg.letters[sg.sounds.length])) {\n        const ps = kana_1.kanaPositionalSound.get(sg.letters[sg.sounds.length]);\n        if (ps) {\n            const s = ps(kana_1.KanaSoundTags.initialConsonant);\n            if (s)\n                sg.sounds.push(s);\n        }\n    }\n    else\n        sg.matching = false;\n    return sg;\n}\nfunction semivowel(sg) {\n    const ssvs = new kana_1.SemivowelSet();\n    if (ssvs.includes(sg.letters[sg.sounds.length])) {\n        const ps = kana_1.kanaPositionalSound.get(sg.letters[sg.sounds.length]);\n        if (ps) {\n            const s = ps(kana_1.KanaSoundTags.semivowel);\n            if (s)\n                sg.sounds.push(s);\n        }\n    }\n    return sg;\n}\nfunction vowel(sg) {\n    const svs = new kana_1.VowelSet();\n    if (svs.includes(sg.letters[sg.sounds.length])) {\n        const ps = kana_1.kanaPositionalSound.get(sg.letters[sg.sounds.length]);\n        if (ps) {\n            const s = ps(kana_1.KanaSoundTags.vowel);\n            if (s)\n                sg.sounds.push(s);\n        }\n    }\n    return sg;\n}\nfunction finalConsonant(sg) {\n    const sfcs = new kana_1.FinalConsonantSet();\n    if (sfcs.includes(sg.letters[sg.sounds.length])) {\n        const ps = kana_1.kanaPositionalSound.get(sg.letters[sg.sounds.length]);\n        if (ps) {\n            const s = ps(kana_1.KanaSoundTags.finalConsonant);\n            if (s)\n                sg.sounds.push(s);\n        }\n    }\n    return sg;\n}\nfunction germinatedConsonant(sg) {\n    const sgcs = new kana_1.GerminatedConsonantSet();\n    if (sgcs.includes(sg.letters[sg.sounds.length])) {\n        const ps = kana_1.kanaPositionalSound.get(sg.letters[sg.sounds.length]);\n        if (ps) {\n            const s = ps(kana_1.KanaSoundTags.germinatedConsonant);\n            if (s)\n                sg.sounds.push(s);\n        }\n    }\n    return sg;\n}\nconst sc_v = grapheme_1.pipe(vowel);\nconst sc_cv = grapheme_1.pipe(initialConsonant, vowel);\nconst sc_cvc = grapheme_1.pipe(initialConsonant, vowel, finalConsonant);\nconst sc_csv = grapheme_1.pipe(initialConsonant, semivowel, vowel);\nconst sc_ccv = grapheme_1.pipe(germinatedConsonant, initialConsonant, vowel);\nclass KanaSoundGenerator {\n    constructor() {\n        this.sylCompositions = [sc_v, sc_cv, sc_cvc, sc_csv, sc_ccv];\n    }\n    genSokuonAndGerminated(letters, lookahead) {\n        let strs = new Array();\n        strs.push(letters);\n        // consonant germination\n        if (new kana_1.GerminatedConsonantSet().includes(letters[0]) == true) {\n            let syl = new Array();\n            syl.push(letters[0].charAt(0));\n            for (let e of letters) {\n                syl.push(e);\n            }\n            strs.push(syl);\n        }\n        // sokuon\n        let fcs = new kana_1.FinalConsonantSet();\n        for (let e of fcs.sounds) {\n            let syl = new Array();\n            Object.assign(syl, letters);\n            syl.push(e.toString());\n            if (e.toString() === lookahead)\n                strs.push(syl);\n        }\n        return strs;\n    }\n    generate(letters, lookahead) {\n        let strs = new Array();\n        let sequences = new Array(); // to be returned\n        strs = this.genSokuonAndGerminated(letters, lookahead);\n        //console.log(strs)\n        for (let i in strs) {\n            // generates all needed sounds to be processed\n            for (let j = 0; j < this.sylCompositions.length; j++) {\n                let sg = new grapheme_1.SoundGeneration();\n                sg.letters = strs[i];\n                //console.log(`j: ${j}`)\n                sg = this.sylCompositions[j](sg);\n                if (sg.letters.length == sg.sounds.length && sg.matching == true) {\n                    sequences.push(sg.sounds);\n                    break;\n                }\n            }\n        }\n        //console.log(sequences)\n        return sequences;\n    }\n}\nexports.KanaSoundGenerator = KanaSoundGenerator;\n//# sourceMappingURL=soundgen.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n//------------------------------------------------------------------------------\nclass Metaplasm {\n}\nexports.Metaplasm = Metaplasm;\nclass TonalInflectionMetaplasm extends Metaplasm {\n    apply(morphemes) {\n        return [];\n    }\n}\nexports.TonalInflectionMetaplasm = TonalInflectionMetaplasm;\nclass TonalZeroInflection extends TonalInflectionMetaplasm {\n}\nexports.TonalZeroInflection = TonalZeroInflection;\nclass TonalLemmatizationMetaplasm extends Metaplasm {\n    apply(morphemes, inflectionalEnding) { }\n}\nexports.TonalLemmatizationMetaplasm = TonalLemmatizationMetaplasm;\n//------------------------------------------------------------------------------\nclass Lexeme {\n}\nexports.Lexeme = Lexeme;\n//------------------------------------------------------------------------------\nclass Word {\n    constructor(syllables) {\n        this.literal = '';\n        if (syllables) {\n            this.syllables = syllables;\n        }\n        else {\n            this.syllables = new Array();\n        }\n    }\n    popSyllable() {\n        this.syllables = this.syllables.slice(0, this.syllables.length - 1);\n        this.concat();\n    }\n    pushSyllable(syl) {\n        this.syllables.push(syl);\n        this.concat();\n    }\n    replaceSyllable(i, syl) {\n        if (i < this.syllables.length) {\n            this.syllables.splice(i, 1, syl);\n        }\n        this.concat();\n    }\n    concat() {\n        this.literal = this.syllables.map(x => (x ? x.literal : '')).join('');\n    }\n}\nexports.Word = Word;\n//------------------------------------------------------------------------------\nclass LexemeMaker {\n}\nexports.LexemeMaker = LexemeMaker;\n//# sourceMappingURL=lexeme.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nclass CombiningMetaplasm {\n}\nexports.CombiningMetaplasm = CombiningMetaplasm;\nclass TonalCombiningMetaplasm extends CombiningMetaplasm {\n    apply(sounds, allomorph) {\n        return [];\n    }\n}\nexports.TonalCombiningMetaplasm = TonalCombiningMetaplasm;\nclass TonalZeroCombining extends TonalCombiningMetaplasm {\n    apply(sounds, allomorph) {\n        return [];\n    }\n}\nexports.TonalZeroCombining = TonalZeroCombining;\nclass RemovingEpenthesisOfAy extends TonalCombiningMetaplasm {\n    applyToLetters(letters) {\n        letters.shift();\n        return letters;\n    }\n    applyToString(str) {\n        return str.slice(1, 2);\n    }\n}\nexports.RemovingEpenthesisOfAy = RemovingEpenthesisOfAy;\nclass RemovingNasalizationOfAy extends TonalCombiningMetaplasm {\n}\nexports.RemovingNasalizationOfAy = RemovingNasalizationOfAy;\nclass KanaCombiningMetaplasm extends CombiningMetaplasm {\n}\nexports.KanaCombiningMetaplasm = KanaCombiningMetaplasm;\n//------------------------------------------------------------------------------\nclass Morpheme {\n}\nexports.Morpheme = Morpheme;\n//------------------------------------------------------------------------------\nclass MatchedPattern {\n    constructor() {\n        this.letters = new Array();\n        this.pattern = new Array();\n    }\n    get matchedLength() {\n        return this.letters.length;\n    } // length of pattern can be optionally returned\n}\nexports.MatchedPattern = MatchedPattern;\n//------------------------------------------------------------------------------\nclass Syllable {\n    constructor(letters) {\n        this.literal = '';\n        this.letters = new Array();\n        if (letters != undefined) {\n            let len = letters.length;\n            for (let i = 0; i < len; i++) {\n                this.pushLetter(letters[i]);\n            }\n        }\n    }\n    pushLetter(l) {\n        this.letters.push(l);\n        this.concat();\n    }\n    replaceLetter(i, l) {\n        this.letters.splice(i, 1, l);\n        this.concat();\n    }\n    insertLetter(i, l) {\n        this.letters.splice(i, 0, l);\n        this.concat();\n    }\n    concat() {\n        this.literal = this.letters.map(x => (x ? x.literal : '')).join('');\n    }\n}\nexports.Syllable = Syllable;\n//------------------------------------------------------------------------------\nclass MorphemeMaker {\n    make(letters, syllabify) {\n        let patterns = new Array();\n        let beginOfSyllable = 0;\n        for (let i = 0; i < letters.length; i++) {\n            let msp = new MatchedPattern();\n            if (i - beginOfSyllable == 0) {\n                msp = syllabify(letters, beginOfSyllable);\n                if (msp.matchedLength == 0) {\n                    //console.log('no matched syllables found. the syllable might need to be added')\n                }\n                //console.log(\"matchedLen: %d\", msp.matchedLength);\n                //console.log(msp.pattern);\n                //console.log(msp.letters)\n                if (msp.letters.length > 0) {\n                    for (let j in msp.letters) {\n                        //console.log(\"msp.letters: %s\", msp.letters[j].literal)\n                    }\n                    patterns.push(msp);\n                }\n                beginOfSyllable += msp.matchedLength;\n            }\n            if (patterns.length == 0) {\n                //console.log('nothing matched')\n            }\n            else if (patterns.length >= 1) {\n                if (msp == undefined)\n                    break;\n                if (msp.matchedLength > 0) {\n                    i += beginOfSyllable - i - 1;\n                }\n            }\n        }\n        return patterns;\n    }\n}\nexports.MorphemeMaker = MorphemeMaker;\n//# sourceMappingURL=morpheme.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nclass PhrasalMetaplasm {\n}\nexports.PhrasalMetaplasm = PhrasalMetaplasm;\nclass TonalPhrasalInflectionMetaplasm extends PhrasalMetaplasm {\n    apply(lexemeOne, lexemeTwo) {\n        return [];\n    }\n}\nexports.TonalPhrasalInflectionMetaplasm = TonalPhrasalInflectionMetaplasm;\n// -----------------------------------------------------------------------------\nclass ToneGroup {\n    constructor() {\n        this.inflectionalEndings = new Array();\n    }\n}\nexports.ToneGroup = ToneGroup;\nclass ToneSandhiGroup extends ToneGroup {\n}\n// -----------------------------------------------------------------------------\nclass Phraseme {\n}\nexports.Phraseme = Phraseme;\n// -----------------------------------------------------------------------------\nclass Phrase {\n    constructor() {\n        this.literal = '';\n    }\n}\nclass TonalPhrase extends Phrase {\n    constructor(words) {\n        super();\n        this.words = new Array();\n        if (words != undefined) {\n            let len = words.length;\n            for (var i = 0; i < len; i++) {\n                if (i > 0)\n                    this.literal += ' ';\n                this.pushWord(words[i]);\n            }\n            this.concat();\n        }\n    }\n    popWord() {\n        // get rid off the last word from array\n        this.words = this.words.slice(0, this.words.length - 1);\n        this.concat();\n    }\n    pushWord(w) {\n        this.words.push(w);\n        this.concat();\n    }\n    concat() {\n        if (this.words.length > 0) {\n            if (this.words.filter(x => x && x.literal.length > 0).length == 0) {\n                this.literal = '';\n            }\n            else\n                this.literal = this.words.map(x => (x ? x.literal : '')).join(' ');\n        }\n    }\n}\nexports.TonalPhrase = TonalPhrase;\n//# sourceMappingURL=phraseme.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst analyzer_1 = require(\"./tonal/analyzer\");\nconst symbols_1 = require(\"./dparser/symbols\");\nconst rules_1 = require(\"./dparser/rules\");\nconst lexeme_1 = require(\"./lexeme\");\nclass Token {\n    constructor(text) {\n        this.text = text;\n        this.pos = '';\n        this.tag = '';\n        this.lemma = '';\n        this.dep = '';\n        this.head = null;\n    }\n}\nexports.Token = Token;\nclass TokenAnalysis {\n    constructor() {\n        this.word = new lexeme_1.Word();\n        this.lemmata = new Array();\n        this.inflectionalEnding = ''; // inflectinal ending\n        this.soundSequences = new Array(); // sound sequences\n        this.blockSequences = []; // block sequences\n    }\n}\nexports.TokenAnalysis = TokenAnalysis;\nclass TokenLemmatizer {\n    getTonalLemmas(doc) {\n        const tla = new analyzer_1.TonalLemmatizationAnalyzer();\n        const lmtzr = new analyzer_1.TonalLemmatizer();\n        const sophv = new rules_1.SetOfPhrasalVerbs();\n        let j = 0;\n        let k = 0;\n        let len = 0;\n        for (let i = 0; i < doc.tokens.length; i++) {\n            if (len == i) {\n                // loop over the doc.speeches sequence\n                if (j < doc.speeches.length) {\n                    len += doc.speeches[j].elements.length;\n                    if (j + 1 < doc.speeches.length)\n                        j++;\n                    k = 0;\n                }\n            }\n            else {\n                k++;\n            }\n            if (doc.tokens[i].text === 'che' || doc.tokens[i].text === 'he') {\n                doc.tokens[i].lemma = doc.tokens[i].text;\n                continue; // defective\n            }\n            if (doc.tokens[i].tag === symbols_1.Tagset.AUXN || doc.tokens[i].tag === symbols_1.Tagset.AUX) {\n                doc.tokens[i].lemma = doc.tokens[i].text;\n                continue;\n            }\n            if (doc.tokens[i].tag === symbols_1.Tagset.VB && i + 1 < doc.tokens.length) {\n                if (doc.tokens[i + 1].tag === symbols_1.Tagset.PPV || doc.tokens[i + 1].tag === symbols_1.Tagset.APPR) {\n                    for (let j in sophv.phrms) {\n                        if (doc.tokens[i].text === sophv.phrms[j].phrase.words[0].literal &&\n                            doc.tokens[i + 1].text === sophv.phrms[j].phrase.words[1].literal) {\n                            doc.tokens[i].lemma = sophv.phrms[j].phrase.words[0].literal;\n                            doc.tokens[i + 1].lemma = sophv.phrms[j].phrase.words[1].literal;\n                            i++;\n                            break;\n                        }\n                        else if (doc.tokens[i].text === sophv.phrms[j].getProceedingForms()[0].words[0].literal &&\n                            doc.tokens[i + 1].text === sophv.phrms[j].phrase.words[1].literal) {\n                            doc.tokens[i].lemma = sophv.phrms[j].phrase.words[0].literal;\n                            doc.tokens[i + 1].lemma = sophv.phrms[j].phrase.words[1].literal;\n                            i++;\n                            break;\n                        }\n                    }\n                    continue;\n                }\n            }\n            if (doc.tokens[i].tag === symbols_1.Tagset.VB) {\n                if (i + 1 < doc.tokens.length && doc.tokens[i + 1].tag === symbols_1.Tagset.AUXN) {\n                    doc.tokens[i].lemma = doc.tokens[i].text; // copy the base form\n                    continue;\n                }\n            }\n            if (k + 1 == doc.speeches[j].elements.length) {\n                // at the end of a speech\n                // need to further check if the speech is a noun chunk or verb phrase\n                doc.tokens[i].lemma = doc.tokens[i].text; // copy the base form\n                continue;\n            }\n            let lemmas = [];\n            lemmas = lmtzr.lemmatize(doc.tokens[i].text).getLemmata();\n            if (lemmas.length > 0)\n                doc.tokens[i].lemma = lemmas[0].literal;\n        }\n        return doc;\n    }\n}\nexports.TokenLemmatizer = TokenLemmatizer;\n//# sourceMappingURL=token.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst analyzer_1 = require(\"../analyzer\");\nconst lexeme_1 = require(\"./lexeme\");\nconst grapheme_1 = require(\"../grapheme\");\nconst version2_1 = require(\"./version2\");\nconst morpheme_1 = require(\"./morpheme\");\n//------------------------------------------------------------------------------\nclass TonalLemmatizationAnalyzer extends analyzer_1.Analyzer {\n    graphAnalyze(str) {\n        // graphemic analysis\n        const gm = new grapheme_1.GraphemeMaker(version2_1.lowerLettersOfTonal);\n        return gm.makeGraphemes(str);\n    }\n    morphAnalyze(x) {\n        // morphological analysis\n        let graphemes = [];\n        if (typeof x == 'object') {\n            graphemes = x;\n        }\n        else if (typeof x == 'string') {\n            graphemes = this.graphAnalyze(x);\n        }\n        const mm = new morpheme_1.TonalUncombiningMorphemeMaker(new morpheme_1.TonalUncombiningForms());\n        return mm.makeMorphemes(graphemes);\n    }\n    lexAnalyze(x) {\n        // lexical analysis\n        let morphemes = [];\n        if (typeof x == 'object') {\n            morphemes = x;\n        }\n        else if (typeof x == 'string') {\n            morphemes = this.morphAnalyze(x);\n        }\n        const lm = new lexeme_1.TonalLemmatizationLexemeMaker();\n        return lm.makeLexemes(morphemes);\n    }\n}\nexports.TonalLemmatizationAnalyzer = TonalLemmatizationAnalyzer;\nclass TonalLemmatizer {\n    lemmatize(str) {\n        const tia = new TonalLemmatizationAnalyzer();\n        const mrphs = tia.morphAnalyze(str);\n        const lx = tia.lexAnalyze(mrphs);\n        return lx;\n    }\n}\nexports.TonalLemmatizer = TonalLemmatizer;\nclass Unassimilator {\n    unassimilate(str) { }\n}\n//# sourceMappingURL=analyzer.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst version2_1 = require(\"./version2\");\nfunction checkLetterSizeTonal() {\n    if (version2_1.tonalPositionalSound.size !== version2_1.lowerLettersOfTonal.size) {\n        console.log('sizes unmatched');\n    }\n}\nexports.checkLetterSizeTonal = checkLetterSizeTonal;\n//# sourceMappingURL=init.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst lexeme_1 = require(\"../lexeme\");\nconst version2_1 = require(\"./version2\");\nconst version2_2 = require(\"./version2\");\nclass TonalZeroLemmatization extends lexeme_1.TonalLemmatizationMetaplasm {\n}\nclass TonalLemmatization extends lexeme_1.TonalLemmatizationMetaplasm {\n    apply(morphemes, inflectionalEnding) {\n        return this.populateLemmata(morphemes, inflectionalEnding);\n    }\n    getLemmas(morphemes, inflectionalEnding) {\n        if (inflectionalEnding) {\n            if (inflectionalEnding instanceof FreeInflectionalEnding) {\n                const ret = [];\n                const arr = morphemes[morphemes.length - 1].getForms();\n                for (let key in arr) {\n                    const wrd = new TonalWord(morphemes.map(x => x.syllable));\n                    wrd.popSyllable();\n                    wrd.pushSyllable(arr[key]);\n                    ret.push(wrd);\n                }\n                return ret;\n            }\n            else if (inflectionalEnding instanceof CheckedInflectionalEnding) {\n                if (morphemes[morphemes.length - 1].getForms().length == 0)\n                    return [];\n                const wrd = new TonalWord(morphemes.map(x => x.syllable));\n                wrd.popSyllable();\n                wrd.pushSyllable(morphemes[morphemes.length - 1].getForms()[0]);\n                return [wrd];\n            }\n        }\n        return [];\n    }\n    populateLemmata(morphemes, inflectionalEnding) {\n        let lemmata = new Array();\n        // turn morphemes into lemmas\n        let lms = this.getLemmas(morphemes, inflectionalEnding);\n        if (lms.length > 0) {\n            for (let key in lms) {\n                lemmata.push(lms[key]);\n            }\n        }\n        return lemmata;\n    }\n}\nexports.TonalLemmatization = TonalLemmatization;\n//------------------------------------------------------------------------------\nclass Ending {\n}\nclass InflectionalEnding extends Ending {\n    constructor() {\n        super(...arguments);\n        this.affix = new version2_2.TonalAffix(); // the affix of this word\n    }\n    toString() {\n        return this.affix.toString();\n    }\n}\nexports.InflectionalEnding = InflectionalEnding;\nclass FreeInflectionalEnding extends InflectionalEnding {\n}\nexports.FreeInflectionalEnding = FreeInflectionalEnding;\nclass CheckedInflectionalEnding extends InflectionalEnding {\n}\nexports.CheckedInflectionalEnding = CheckedInflectionalEnding;\nclass TonalSymbolEnding extends Ending {\n    constructor() {\n        super(...arguments);\n        this.allomorph = new version2_1.Allomorph();\n    }\n    toString() {\n        return this.allomorph.toString();\n    }\n}\nexports.TonalSymbolEnding = TonalSymbolEnding;\nclass FreeTonalEnding extends TonalSymbolEnding {\n}\nexports.FreeTonalEnding = FreeTonalEnding;\nclass CheckedTonalEnding extends TonalSymbolEnding {\n}\nexports.CheckedTonalEnding = CheckedTonalEnding;\n//------------------------------------------------------------------------------\nclass TonalWord extends lexeme_1.Word {\n    constructor(syllables) {\n        super();\n        this.syllables = new Array();\n        if (syllables != undefined) {\n            let len = syllables.length;\n            for (let i = 0; i < len; i++) {\n                this.pushSyllable(syllables[i]);\n            }\n        }\n    }\n}\nexports.TonalWord = TonalWord;\n//------------------------------------------------------------------------------\nclass TonalLemmatizationLexeme extends lexeme_1.Lexeme {\n    constructor(ms, tl) {\n        super();\n        this.lemmata = new Array(); // lexical forms. underlying forms\n        let isIStemWithX = false; // inflectional stem with x in the middle\n        for (let i = 0; i < ms.length; i++) {\n            if (ms[i] && ms[i].syllable.lastLetter.literal === version2_1.TonalLetterTags.x) {\n                if (i < ms.length - 1 &&\n                    ms[ms.length - 1].syllable.lastLetter.literal !== version2_1.TonalLetterTags.y &&\n                    ms[ms.length - 1].syllable.lastSecondLetter.literal !== version2_1.TonalLetterTags.a) {\n                    if (ms[ms.length - 1].syllable.lastLetter.literal === version2_1.TonalLetterTags.a) {\n                        break;\n                    }\n                    else {\n                        // tonal x can't not appear in them middle of an inflectional stem\n                        // if it is not preceding an ay or a\n                        isIStemWithX = true;\n                        break;\n                    }\n                }\n            }\n        }\n        if (isIStemWithX)\n            this.word = new TonalWord([]);\n        else\n            this.word = new TonalWord(ms.map(x => x.syllable));\n        if (ms.length > 0) {\n            if (ms[ms.length - 1].allomorph) {\n                this.inflectionalEnding = this.assignInflectionalEnding(ms[ms.length - 1].allomorph);\n            }\n            else {\n                this.inflectionalEnding = new InflectionalEnding();\n            }\n        }\n        else {\n            this.inflectionalEnding = new InflectionalEnding();\n        }\n        if (!isIStemWithX) {\n            this.lemmata = tl.apply(ms, this.inflectionalEnding);\n        }\n    }\n    getLemmata() {\n        // this must be called after populateLemmata is called\n        return this.lemmata;\n    }\n    getInflectionalEnding() {\n        if (this.inflectionalEnding)\n            return this.inflectionalEnding.toString();\n        return '';\n    }\n    assignInflectionalEnding(allomorph) {\n        let infe = new InflectionalEnding();\n        // change allomorph to affix\n        if (allomorph instanceof version2_1.FreeAllomorph) {\n            let fie = new FreeInflectionalEnding();\n            fie.affix.tonal = allomorph.tonal;\n            infe = fie;\n        }\n        else if (allomorph instanceof version2_1.CheckedAllomorph) {\n            let cie = new CheckedInflectionalEnding();\n            cie.affix.tonal = allomorph.tonal;\n            infe = cie;\n        }\n        // this word is already in base form, and its last syllable is checked tone\n        return infe;\n    }\n}\nexports.TonalLemmatizationLexeme = TonalLemmatizationLexeme;\n//------------------------------------------------------------------------------\nclass TonalLemmatizationLexemeMaker extends lexeme_1.LexemeMaker {\n    constructor() {\n        super();\n    }\n    makeLexemes(ms) {\n        return this.make(ms);\n    }\n    make(ms) {\n        return new TonalLemmatizationLexeme(ms, new TonalLemmatization());\n    }\n}\nexports.TonalLemmatizationLexemeMaker = TonalLemmatizationLexemeMaker;\n//# sourceMappingURL=lexeme.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// prettier-ignore\nconst to_be_verified = [\n    'hioh',\n    'jih', 'jirnx', 'jirtt',\n    'na',\n    'qoaiz'\n];\n// prettier-ignore\nconst new_lexical_roots = [\n    'coaih',\n    'choa',\n    'dngh', 'dom',\n    'gehh',\n    'hoang', 'homz',\n    'jex', 'jek', 'jeng', 'jip',\n    'kiaih', 'kuih',\n    'laih', 'langh', 'lirey', 'lih', 'lit', 'loaih', 'loaiz', 'loeh', 'loeih', 'lurih',\n    'mah', 'mnghh',\n    'n',\n    'qanh', 'qngh',\n    'oehh',\n    'sangh', 'sennh', 'sienh', 'simh', 'sinnh',\n    'tom', 'tomz',\n    'virt',\n];\n// prettier-ignore\nconst addon_lexical_roots = [\n    'ainn', 'ainny', 'ainnx', 'anny', 'aunn', 'aunny', 'aunnz',\n    'borh', 'borhh', 'borx', 'bory', 'borz',\n    'cainn', 'cainny', 'cainnw', 'cainnx', 'cannh', 'cennh', 'cennx', 'cennz', 'cennhh', 'cor', 'corh', 'corw', 'corx', 'cory', 'corz', 'cinnw', 'cinnh', 'cinnz', 'cir', 'cirinn', 'cirinny', 'cirw', 'ciry', 'cirx', 'coanny', 'coannw', 'coannz', 'cuinn', 'cuinny', 'cuinnw',\n    'chainn', 'chainnw', 'chainnx', 'channw', 'channx', 'chennx', 'chor', 'choreh', 'chorehh', 'chorew', 'chorex', 'chorez', 'chorh', 'chorhh', 'chorw', 'chorz', 'chir', 'chirinny', 'chirinnx', 'chirm', 'chirw', 'chiry', 'chirx', 'chirz', 'chiunnx', 'chm', 'chuinn', 'chuinny', 'chuinnw', 'chuinnx', 'chuinnz',\n    'dainyy', 'dainnw', 'dainnx', 'dainnz', 'dainnhh', 'denny', 'dennx', 'dorex', 'dorey', 'dorez', 'dorh', 'dorhh', 'dorw', 'dory', 'dorz', 'diann', 'diannw', 'dinnh', 'dinnw', 'dir', 'dirinnw', 'dirinnz', 'dirw', 'dirx', 'dirz', 'dirng', 'doanny', 'duinny', 'duinnw', 'duinnx', 'duinnz',\n    'enny', 'ennh', 'ennz', 'ennhh', 'or', 'ore', 'orehh', 'orex', 'orey', 'orez', 'orh', 'orw', 'orx', 'orz', 'orehh',\n    'goreh', 'gorehh', 'gorhh', 'gorex', 'gorez', 'gorx', 'giauh', 'girnx', 'girnz', 'girt', 'girx', 'giry', 'girz',\n    'hainny', 'hainnh', 'hainnz', 'hann', 'hannhh', 'henny', 'hennz', 'hennhh', 'hor', 'horez', 'horw', 'horx', 'hory', 'horz', 'haunn', 'haunny', 'haunnw', 'haunnh', 'haunnx', 'haunnhh', 'hinnh', 'hinnx', 'hio', 'hir', 'hirinnx', 'hirinnz', 'hirny', 'hirnz', 'hirw', 'hirx', 'hiry', 'hirtt', 'hirk', 'hiunny', 'hiunnw', 'hiunnz', 'hmhh', 'hmz', 'hngw', 'hoainnh', 'hoannw', 'honnz', 'hop', 'huinn', 'huinnh', 'huinnx', 'huinnz',\n    'ionn', 'innh', 'innhh', 'ir', 'irinnx', 'irn', 'irny', 'irpp', 'irw', 'irx', 'iry', 'irz',\n    'jiaunny', 'jiaunnw', 'jiaunnx', 'jinny', 'jiry', 'jirx', 'jorx',\n    'kannx', 'kainnh', 'kainnw', 'kaunnhh', 'kennh', 'kennx', 'kor', 'kore', 'koreh', 'korew', 'korw', 'korh', 'korx', 'kiann', 'kiannw', 'kinn', 'kir', 'kirnx', 'kirny', 'kirw', 'kngz', 'koainn', 'koainnw', 'konny', 'kuinnw',\n    'lorehh', 'lorex', 'lorh', 'lorx', 'liry', 'lirx', 'lirz',\n    'maix', 'mih', 'mihh', 'mng', 'moaix', 'moaiz', 'moex', 'moez', 'mui', 'muiz',\n    'naih', 'naix', 'ney', 'new', 'nez', 'nehh', 'niauw', 'niauh', 'niaw', 'nirix', 'niriz', 'niu', 'nngh', 'nox', 'nui', 'nuiy', 'nuiw', 'nuix', 'nuiz',\n    'ngai', 'ngaiy', 'ngauy', 'ngauh', 'ngauhh', 'ngaw', 'ngaz', 'nge', 'ngh', 'nghh', 'ngiahh', 'ngiriy', 'ngiuy', 'ngiux', 'ngiz', 'ngoeh', 'ngoehh',\n    'oainn', 'oainnh', 'oainnz', 'oainnhh', 'oannx',\n    'painn', 'pennw', 'por', 'porhh', 'porw', 'porx', 'porz', 'pinny', 'pinnhh', 'png', 'pngy', 'pngw', 'pngz', 'pnghh', 'poannx', 'ponn', 'puinn', 'puinnw', 'puinnx',\n    'qainny', 'qainnw', 'qainnz', 'qannhh', 'qore', 'qoreh', 'qorew', 'qorex', 'qorey', 'qorez', 'qorh', 'qorw', 'qory', 'qiaunnhh', 'qinny', 'qinnh', 'qinnhh', 'qir', 'qirinn', 'qirinny', 'qirn', 'qirnw', 'qirnz', 'qirw', 'qirx', 'qiry', 'qirz', 'qiunnx', 'qiunnz', 'qnghh', 'qoainnw', 'qoainnx', 'qoainnhh', 'qoannw', 'qoenny', 'qonnz', 'quinn', 'quinny', 'quinnw',\n    'sainn', 'sanny', 'sannw', 'sannx', 'sore', 'sorew', 'sorew', 'sorh', 'sorhh', 'sorx', 'sorw', 'sorz', 'sinnx', 'sinnhh', 'sir', 'sirinn', 'sirm', 'sirp', 'sirw', 'sirx', 'siry', 'sirz', 'sm', 'smw', 'smh', 'snghh', 'soainn', 'soainnh', 'soainnx', 'soainnhh', 'soenn', 'soenny', 'soennw', 'suinn', 'suinny', 'suinnw',\n    'tainnw', 'tainnz', 'tannx', 'tannz', 'tenn', 'tor', 'tore', 'torehh', 'torew', 'torhh', 'torw', 'tinnw', 'tinnx', 'tirx', 'tiry', 'tiunny', 'toannx', 'tuinnw', 'tuinnx', 'tuinnz',\n    'uihh', 'uinn', 'uinny', 'uinnx', 'uinnz',\n    'vainny', 'vainnx', 'vainnz', 'vor', 'vory', 'vorw', 'vorx', 'vorz', 'vinnx', 'vngx', 'vuinn', 'vuinny', 'vuinnx', 'vuinnz',\n];\n// prettier-ignore\nexports.lexical_roots = [\n    'a', 'ay', 'az', 'ah', 'ahh', 'ai', 'aiy', 'aiw', 'ainnz', 'ak', 'am',\n    'amy', 'amw', 'amx', 'amz', 'an', 'any', 'anw', 'anx', 'anz', 'ang',\n    'angw', 'angx', 'angz', 'annw', 'annx', 'annz', 'ap', 'app', 'at', 'au',\n    'auy', 'auw', 'aux', 'auz',\n    'ba', 'bax', 'baz', 'bah', 'bai', 'baiy', 'baix', 'bak', 'bakk', 'ban',\n    'bany', 'banx', 'banz', 'bangy', 'bangw', 'bangx', 'bangz', 'bat', 'batt',\n    'bauy', 'bauz', 'bey', 'bex', 'bez', 'beh', 'behh', 'biy', 'bix', 'biz',\n    'bieny', 'bienx', 'bienz', 'biett', 'biauy', 'biaux', 'biauz', 'bih',\n    'bihh', 'bekk', 'biny', 'binx', 'binz', 'bengy', 'bengx', 'bengz', 'biury',\n    'biurx', 'biurz', 'bitt', 'biuz', 'bury', 'burx', 'burz', 'bok', 'bokk',\n    'bong', 'bongy', 'bongw', 'bongx', 'bongz', 'boy', 'box', 'boz', 'buy',\n    'bux', 'buz', 'boax', 'boah', 'boahh', 'boany', 'boatt', 'boey', 'boex',\n    'boez', 'boehh', 'bui', 'buny', 'bunw', 'bunx', 'bunz', 'but', 'butt',\n    'ca', 'cay', 'cax', 'caz', 'cah', 'cai', 'caiy', 'caiw', 'caix', 'caiz',\n    'cak', 'cakk', 'cam', 'camy', 'camw', 'camx', 'can', 'canw', 'canx',\n    'cang', 'cangy', 'cangw', 'canny', 'cannz', 'cap', 'capp', 'cat', 'catt',\n    'cau', 'cauy', 'cauw', 'cauhh', 'ce', 'cey', 'cew', 'cex', 'cez', 'ceh',\n    'cenn', 'cenny', 'cennw', 'ci', 'ciy', 'ciw', 'cix', 'ciz', 'cia', 'ciax',\n    'ciah', 'ciakk', 'ciam', 'ciamy', 'cien', 'cieny', 'cienx', 'ciangy',\n    'ciangw', 'ciangx', 'ciangz', 'ciann', 'cianny', 'ciannw', 'ciannx', 'ciap',\n    'ciet', 'ciau', 'ciauw', 'ciaux', 'cih', 'cihh', 'cek', 'cekk', 'cim',\n    'cimy', 'cin', 'cinw', 'ceng', 'cengy', 'cengw', 'cengx', 'cengz', 'cinn',\n    'cinny', 'cinnx', 'ciur', 'ciurw', 'ciurz', 'ciurh', 'ciurhh', 'ciok',\n    'ciokk', 'ciong', 'ciongw', 'cip', 'cit', 'ciu', 'ciuy', 'ciux', 'ciuz',\n    'ciunn', 'ciunny', 'ciunnw', 'ciunnx', 'ciunnz', 'cng', 'cngy', 'cngw',\n    'cngx', 'cngh', 'cnghh', 'cur', 'cury', 'curw', 'curh', 'cok', 'cokk',\n    'cong', 'congy', 'congw', 'congx', 'co', 'coy', 'cow', 'cu', 'cuy', 'cuw',\n    'cuz', 'coaw', 'coaz', 'coah', 'coahh', 'coan', 'coan', 'coanw', 'coanx',\n    'coangw', 'coann', 'coannw', 'coe', 'coey', 'coex', 'coez', 'cuh', 'cuhh',\n    'cui', 'cuiy', 'cuiw', 'cun', 'cuny', 'cunw', 'cunx', 'cunz', 'cut',\n    'cha', 'chay', 'chaw', 'chah', 'chahh', 'chai', 'chaiy', 'chaiw', 'chaix',\n    'chaiz', 'chainny', 'chak', 'chakk', 'cham', 'chamy', 'chamw', 'chamz',\n    'chan', 'chany', 'chanw', 'chanx', 'chanz', 'chang', 'changy', 'changw',\n    'changx', 'channy', 'channz', 'chapp', 'chat', 'chatt', 'chau', 'chauy',\n    'chauw', 'chaux', 'chauz', 'che', 'chey', 'chew', 'chex', 'chez', 'cheh',\n    'chehh', 'chenn', 'chenny', 'chennw', 'chennz', 'chi', 'chiy', 'chiw',\n    'chix', 'chiz', 'chia', 'chiay', 'chiaw', 'chiaz', 'chiah', 'chiahh',\n    'chiam', 'chiamw', 'chiamx', 'chiamz', 'chien', 'chieny', 'chienw',\n    'chienx', 'chienz', 'chiang', 'chiangy', 'chiangw', 'chiann', 'chianny',\n    'chiannw', 'chiannx', 'chiannz', 'chiap', 'chiapp', 'chiet', 'chiett',\n    'chiau', 'chiauy', 'chiauw', 'chiaux', 'chih', 'chihh', 'chek', 'chekk',\n    'chim', 'chimy', 'chimw', 'chimx', 'chin', 'chiny', 'chinw', 'chinx',\n    'chinz', 'cheng', 'chengy', 'chengw', 'chengx', 'chengz', 'chinn',\n    'chinny', 'chinnw', 'chinnx', 'chinnz', 'chiur', 'chiury', 'chiurw',\n    'chiurh', 'chiurhh', 'chiok', 'chiong', 'chiongy', 'chiongw', 'chiongx',\n    'chiongz', 'chip', 'chipp', 'chit', 'chitt', 'chiu', 'chiuy', 'chiuw',\n    'chiuz', 'chiunn', 'chiunny', 'chiunnw', 'chiunnz', 'chng', 'chngy',\n    'chngw', 'chngx', 'chngz', 'chur', 'chury', 'churw', 'churx', 'churz',\n    'churh', 'chok', 'chokk', 'chong', 'chongy', 'chongw', 'chongx', 'chongz',\n    'cho', 'choy', 'choz', 'chu', 'chuy', 'chuw', 'chux', 'chuxz', 'choay',\n    'choax', 'choaz', 'choah', 'choahh', 'choainnz', 'choan', 'choany',\n    'choanw', 'choanx', 'choanz', 'choann', 'choanny', 'choannw', 'choannx',\n    'choannz', 'chutt', 'choew', 'choez', 'chuh', 'chui', 'chuiy', 'chuiw',\n    'chuix', 'chuiz', 'chun', 'chuny', 'chunw', 'chunx', 'chunz', 'chut',\n    'chutt',\n    'da', 'day', 'daw', 'dah', 'dahh', 'dai', 'daiy', 'daiw', 'daix', 'daiz',\n    'dainn', 'dainny', 'dak', 'dakk', 'dam', 'damy', 'damw', 'damx', 'damz',\n    'dan', 'dany', 'danw', 'danx', 'danz', 'dang', 'dangy', 'dangw', 'dangx',\n    'dangz', 'dann', 'danny', 'dannw', 'dannx', 'dannz', 'dap', 'dapp', 'dat',\n    'datt', 'dau', 'dauy', 'dauw', 'daux', 'dauz', 'dauh', 'dauhh', 'de', 'dey',\n    'dew', 'dex', 'dez', 'deh', 'denn', 'dennw', 'dennz', 'di', 'diy', 'diw',\n    'dix', 'diz', 'dia', 'diah', 'diahh', 'diak', 'diakk', 'diam', 'diamy',\n    'diamw', 'diamx', 'diamz', 'dien', 'dieny', 'dienx', 'dienz', 'dianny',\n    'diannx', 'diannz', 'diap', 'diapp', 'diet', 'diett', 'diau', 'diauw',\n    'diaux', 'diauz', 'dih', 'dihh', 'dek', 'dekk', 'dimw', 'dimx', 'dimz',\n    'din', 'diny', 'dinw', 'dinx', 'dinz', 'deng', 'dengy', 'dengw', 'dengx',\n    'dengz', 'dinn', 'dinnx', 'dinnz', 'dinnhh', 'diurw', 'diurx', 'diurz',\n    'diurh', 'diurhh', 'diok', 'diokk', 'diong', 'diongy', 'diongw', 'diongx',\n    'diongz', 'dit', 'ditt', 'diu', 'diuy', 'diuw', 'diux', 'diuz', 'diuh',\n    'diunn', 'diunny', 'diunnw', 'diunnx', 'diunnz', 'dng', 'dngy', 'dngw',\n    'dngx', 'dngz', 'dur', 'dury', 'durw', 'durx', 'durz', 'durh', 'durhh',\n    'dok', 'dokk', 'domx', 'dong', 'dongy', 'dongw', 'dongx', 'dongz', 'do',\n    'doy', 'dow', 'dox', 'doz', 'du', 'duy', 'duw', 'dux', 'duz', 'doaw',\n    'doaz', 'doan', 'doany', 'doanw', 'doanz', 'doann', 'doannw', 'doannx',\n    'doannz', 'doat', 'doatt', 'doew', 'doex', 'doez', 'duh', 'duhh', 'dui',\n    'duiw', 'duix', 'duiz', 'dun', 'duny', 'dunw', 'dunz', 'dutt',\n    'e', 'ey', 'ew', 'ex', 'ez', 'eh', 'ehh', 'enn', 'ennx',\n    'ek', 'ekk', 'eng', 'engy', 'engw', 'engx', 'engz',\n    'gax', 'gaz', 'gaix', 'gaiz', 'gakk', 'gamy', 'gamx', 'gamz', 'gany',\n    'ganw', 'ganx', 'ganz', 'gangz', 'gaux', 'gew', 'gex', 'gez', 'giy', 'gix',\n    'giz', 'giax', 'giah', 'giahh', 'giamy', 'giamx', 'giamz', 'gieny', 'gienw',\n    'gienx', 'gienz', 'giang', 'giangw', 'giangz', 'giap', 'giapp', 'giet',\n    'giett', 'giaux', 'gekk', 'gimy', 'gimx', 'gimz', 'giny', 'ginx', 'ginz',\n    'gengy', 'gengx', 'giury', 'giurx', 'giurhh', 'giok', 'giokk', 'giongy',\n    'giuy', 'giux', 'gurx', 'gurz', 'gokk', 'gongx', 'gongz', 'gox', 'goz',\n    'guy', 'gux', 'guz', 'goay', 'goaz', 'goany', 'goanx', 'goanz', 'goatt',\n    'goez', 'goehh', 'guix', 'guiz',\n    'ha', 'haw', 'hax', 'haz', 'hah', 'hahh', 'hai', 'haiy', 'haix', 'haiz',\n    'hainn', 'hainnw', 'hainnx', 'hak', 'hakk', 'ham', 'hamy', 'hamw', 'hamx',\n    'hamz', 'han', 'hany', 'hanw', 'hanx', 'hanz', 'hang', 'hangw', 'hangx',\n    'hangz', 'hanny', 'hannx', 'hannz', 'hannh', 'hap', 'happ', 'hat', 'hatt',\n    'hau', 'hauy', 'hauw', 'haux', 'hauz', 'he', 'hey', 'hew', 'hex', 'hez',\n    'heh', 'hennw', 'hennx', 'hennh', 'hi', 'hiy', 'hiw', 'hix', 'hia', 'hiaz',\n    'hiah', 'hiahh', 'hiam', 'hiamy', 'hiamw', 'hiamx', 'hien', 'hieny',\n    'hienw', 'hienx', 'hienz', 'hiang', 'hiangy', 'hiangw', 'hiann', 'hianny',\n    'hiannw', 'hiannx', 'hiannz', 'hiannh', 'hiapp', 'hiet', 'hiett', 'hiau',\n    'hiauy', 'hiaux', 'hiauh', 'hek', 'hekk', 'him', 'himx', 'hin', 'hinx',\n    'hinz', 'heng', 'hengw', 'hengx', 'hengz', 'hinn', 'hinnw', 'hinnz',\n    'hiurx', 'hiurz', 'hiurh', 'hiurhh', 'hiok', 'hiong', 'hiongy', 'hiongw',\n    'hiongx', 'hip', 'hit', 'hitt', 'hiu', 'hiuy', 'hiuw', 'hiux', 'hiunn',\n    'hiunnhh', 'hmy', 'hmx', 'hmh', 'hmhh', 'hng', 'hngy', 'hngx', 'hngz',\n    'hngh', 'hnghh', 'hury', 'hurx', 'hurz', 'hurhh', 'hok', 'hokk', 'hong',\n    'hongy', 'hongw', 'hongx', 'hongz', 'honn', 'honny', 'honnw', 'honnh', 'ho',\n    'hoy', 'how', 'hox', 'hoz', 'hu', 'huy', 'huw', 'hux', 'huz', 'hoa', 'hoaw',\n    'hoax', 'hoaz', 'hoah', 'hoahh', 'hoaix', 'hoaiz', 'hoainnx', 'hoan',\n    'hoany', 'hoanw', 'hoanx', 'hoanz', 'hoann', 'hoanny', 'hoannx', 'hoannz',\n    'hoat', 'hoatt', 'hoe', 'hoey', 'hoew', 'hoex', 'hoez', 'hoeh', 'hui',\n    'huiy', 'huiw', 'huix', 'huiz', 'hun', 'huny', 'hunw', 'hunx', 'hunz',\n    'hut', 'hutt',\n    'i', 'iy', 'iw', 'ix', 'iz', 'ia', 'iay', 'iaw', 'iax', 'iaz', 'iah',\n    'iahh', 'iam', 'iamy', 'iamx', 'iamz', 'ien', 'ieny', 'ienw', 'ienx',\n    'iang', 'iangz', 'iann', 'ianny', 'iannw', 'iannx', 'iannz', 'iap', 'iapp',\n    'iet', 'iett', 'iau', 'iauy', 'iauw', 'iaux', 'iauz', 'iaunn', 'im', 'imy',\n    'imw', 'imx', 'in', 'iny', 'inw', 'inx', 'inz', 'inn', 'inny', 'innw',\n    'innx', 'innz', 'iur', 'iury', 'iurx', 'iurh', 'iurhh', 'iok', 'iokk',\n    'iong', 'iongy', 'iongw', 'iongx', 'iongz', 'ip', 'it', 'itt', 'iu', 'iuy',\n    'iuw', 'iux', 'iuz', 'iunn', 'iunny', 'iunnx', 'iunnz',\n    'jiy', 'jix', 'jiz', 'jia', 'jiay', 'jiamy', 'jienx', 'jiangy', 'jiapp',\n    'jiett', 'jiauy', 'jiauw', 'jiaux', 'jimy', 'jimx', 'jimz', 'jinx', 'jinz',\n    'jiurz', 'jiok', 'jiokk', 'jiongy', 'jiongx', 'jiongz', 'jipp', 'jitt',\n    'jiux', 'juy', 'jux', 'juz', 'joahh', 'joex', 'joez', 'junz',\n    'ka', 'kay', 'kaw', 'kah', 'kahh', 'kai', 'kaiy', 'kaiw', 'kainn', 'kainny',\n    'kak', 'kakk', 'kam', 'kamy', 'kamw', 'kan', 'kanw', 'kang', 'kangy',\n    'kangw', 'kann', 'kap', 'kapp', 'kat', 'kau', 'kauy', 'kauw', 'ke', 'key',\n    'kew', 'kex', 'keh', 'kehh', 'kenn', 'kennhh', 'ki', 'kiy', 'kiw', 'kix',\n    'kiz', 'kia', 'kiax', 'kiaz', 'kiah', 'kiakk', 'kiam', 'kiamw', 'kiamx',\n    'kiamz', 'kien', 'kieny', 'kienw', 'kienx', 'kiang', 'kiangw', 'kiap',\n    'kiet', 'kiett', 'kiau', 'kiauy', 'kiauw', 'kiauh', 'kih', 'kek', 'kim',\n    'kimy', 'kimx', 'kin', 'kiny', 'kinx', 'keng', 'kengy', 'kengw', 'kengx',\n    'kengz', 'kinnx', 'kiury', 'kiurw', 'kiurh', 'kiok', 'kiong', 'kiongy',\n    'kiongx', 'kip', 'kipp', 'kit', 'kitt', 'kiu', 'kiuy', 'kiux', 'kiuz',\n    'kiunn', 'kiunnz', 'kng', 'kngw', 'kur', 'kury', 'kurw', 'kurx', 'kok',\n    'kokk', 'kong', 'kongy', 'kongw', 'kongz', 'ko', 'koy', 'kow', 'ku', 'kux',\n    'kuz', 'koa', 'koay', 'koaw', 'koah', 'koaiw', 'koan', 'koany', 'koanw',\n    'koanx', 'koann', 'koanny', 'koannw', 'koat', 'koe', 'koew', 'koex', 'koeh',\n    'kuh', 'kui', 'kuiy', 'kuiw', 'kun', 'kuny', 'kunw', 'kunx', 'kut', 'kutt',\n    'la', 'lax', 'laz', 'lah', 'lahh', 'laix', 'laiz', 'lak', 'lakk', 'lam',\n    'lamy', 'lamw', 'lamx', 'lamz', 'lan', 'lany', 'lanx', 'lanz', 'lang',\n    'langy', 'langw', 'langx', 'langz', 'lap', 'lapp', 'latt', 'lauy', 'lauw',\n    'laux', 'lauz', 'lauhh', 'le', 'ley', 'lew', 'lex', 'lez', 'leh', 'lehh',\n    'li', 'liy', 'liw', 'lix', 'liz', 'liah', 'liahh', 'liam', 'liamy', 'liamw',\n    'liamx', 'liamz', 'lien', 'lieny', 'lienx', 'lienz', 'liang', 'liangy',\n    'liangx', 'liangz', 'liap', 'liapp', 'liett', 'liauy', 'liauw', 'liaux',\n    'liauz', 'lihh', 'lek', 'lekk', 'lim', 'limy', 'limx', 'limz', 'lin',\n    'liny', 'linw', 'linx', 'limz', 'leng', 'lengy', 'lengw', 'lengx', 'lengz',\n    'liury', 'liurx', 'liurz', 'liurhh', 'liok', 'liokk', 'liongy', 'liongw',\n    'liongx', 'liongz', 'lipp', 'liu', 'liuy', 'liuw', 'liux', 'liuz', 'lur',\n    'lury', 'lurw', 'lurx', 'lurz', 'lurh', 'lurhh', 'lok', 'lokk', 'long',\n    'longy', 'longw', 'longx', 'longz', 'loy', 'lox', 'loz', 'lu', 'luy',\n    'luw', 'lux', 'luz', 'loax', 'loaz', 'loah', 'loahh', 'loany', 'loanx',\n    'loanz', 'loatt', 'loex', 'loez', 'lui', 'luiy', 'luiw', 'luix', 'luiz',\n    'lun', 'luny', 'lunx', 'lunz', 'lut', 'lutt',\n    'my', 'mx', 'mz', 'ma', 'may', 'maw', 'max', 'maz', 'mai', 'maiy', 'maiw',\n    'maiz', 'mau', 'maux', 'mauz', 'mauh', 'me', 'mey', 'mex', 'mez', 'meh',\n    'mehh', 'mi', 'miy', 'mix', 'miz', 'miax', 'miaz', 'miauz', 'mih', 'mihh',\n    'mngy', 'mngx', 'mngz', 'mo', 'moy', 'mox', 'moz', 'moh', 'mohh', 'moa',\n    'moay', 'moax', 'moaz', 'muiy', 'muix',\n    'nay', 'naw', 'nax', 'naz', 'nah', 'nai', 'naiy', 'naiz', 'nauy', 'nauz',\n    'nauh', 'ne', 'nex', 'neh', 'ni', 'niy', 'nix', 'niz', 'niay', 'niax',\n    'niaz', 'niau', 'niauy', 'nih', 'niuy', 'niux', 'niuz', 'nng', 'nngy',\n    'nngw', 'nngx', 'nngz', 'noy', 'noz', 'noay', 'noaw', 'noax', 'noaz',\n    'ng', 'ngy', 'ngw', 'ngx', 'ngz', 'ngay', 'ngaiz', 'ngaux', 'ngauz', 'ngey',\n    'ngez', 'ngeh', 'ngehh', 'ngiax', 'ngiau', 'ngiauy', 'ngiauh', 'ngiauhh',\n    'ngoy', 'ngox', 'ngoz',\n    'o', 'oy', 'ox', 'oz', 'ok', 'om', 'omz', 'ong', 'ongy', 'ongx', 'ongz',\n    'onn', 'onnw',\n    'oa', 'oay', 'oax', 'oahh', 'oai', 'oainny', 'oan', 'oany', 'oanw', 'oanx',\n    'oanz', 'oang', 'oann', 'oanny', 'oannw', 'oannz', 'oat', 'oatt', 'oe',\n    'oey', 'oew', 'oex', 'oez', 'oeh',\n    'pa', 'paw', 'paz', 'pah', 'paiw', 'painny', 'painnz', 'pak', 'pakk', 'pan',\n    'pan', 'pang', 'pangy', 'pangw', 'pangx', 'pangz', 'pannw', 'pannz', 'pau',\n    'pauy', 'pauw', 'pauz', 'pauhh', 'pe', 'pey', 'pew', 'pez', 'penn', 'pennx',\n    'pennz', 'pi', 'piy', 'piw', 'pix', 'piz', 'piah', 'piahh', 'piak', 'piakk',\n    'pien', 'pienw', 'pienx', 'piang', 'piangz', 'piann', 'pianny', 'piannx',\n    'piet', 'piau', 'piauw', 'piaux', 'pih', 'pihh', 'pek', 'piny', 'pinx',\n    'pinz', 'peng', 'pengw', 'pengx', 'pengz', 'pinn', 'pinnw', 'pinnx',\n    'pinnz', 'piurw', 'piurx', 'pit', 'pngh', 'pur', 'pury', 'purw', 'purz',\n    'purh', 'pok', 'pokk', 'pong', 'pongy', 'pongw', 'pongx', 'pongz', 'po',\n    'poy', 'pow', 'pox', 'poz', 'puy', 'pux', 'puz', 'poaw', 'poah', 'poahh',\n    'poan', 'poanx', 'poanz', 'poann', 'poannw', 'poannz', 'poat', 'poe',\n    'poey', 'poew', 'poex', 'poez', 'poehh', 'puhh', 'puiy', 'puiw', 'pun',\n    'puny', 'punw', 'punx', 'put', 'putt',\n    'qa', 'qay', 'qaw', 'qaz', 'qah', 'qai', 'qaiy', 'qaiw', 'qainn', 'qainnx',\n    'qak', 'qakk', 'qam', 'qamy', 'qamw', 'qamx', 'qan', 'qany', 'qanw', 'qang',\n    'qangy', 'qangw', 'qangx', 'qangz', 'qann', 'qanny', 'qannw', 'qannx',\n    'qap', 'qat', 'qau', 'qauy', 'qauw', 'qaux', 'qauz', 'qauh', 'qe', 'qey',\n    'qew', 'qez', 'qeh', 'qehh', 'qenn', 'qenny', 'qennw', 'qi', 'qiy', 'qiw',\n    'qix', 'qiz', 'qia', 'qiaw', 'qiaz', 'qiahh', 'qiam', 'qiamy', 'qiamw',\n    'qiamx', 'qien', 'qieny', 'qienw', 'qienz', 'qiann', 'qianny', 'qiannw',\n    'qiannx', 'qiannz', 'qiap', 'qiet', 'qiett', 'qiau', 'qiauy', 'qiaux',\n    'qiauz', 'qek', 'qekk', 'qim', 'qimy', 'qimw', 'qimz', 'qin', 'qiny',\n    'qinw', 'qinz', 'qeng', 'qengy', 'qengw', 'qengx', 'qengz', 'qinn', 'qinnw',\n    'qinnx', 'qiurw', 'qiurx', 'qiurz', 'qiurh', 'qiok', 'qiokk', 'qiong',\n    'qiongy', 'qiongx', 'qiongz', 'qip', 'qipp', 'qitt', 'qiu', 'qiuy', 'qiuw',\n    'qiux', 'qiuz', 'qiunn', 'qng', 'qngy', 'qngw', 'qur', 'qury', 'qurw',\n    'qurx', 'qurz', 'qurh', 'qok', 'qokk', 'qong', 'qongy', 'qongw', 'qongx',\n    'qonnx', 'qo', 'qoy', 'qow', 'qox', 'qoz', 'qu', 'quy', 'quw', 'quz', 'qoa',\n    'qoay', 'qoaw', 'qoaz', 'qoah', 'qoai', 'qoaiy', 'qoaiw', 'qoainn',\n    'qoainny', 'qoainnz', 'qoan', 'qoany', 'qoanw', 'qoanx', 'qoanz', 'qoann',\n    'qoanny', 'qoannx', 'qoannz', 'qoat', 'qoe', 'qoey', 'qoew', 'qoeh', 'qui',\n    'quiy', 'quiw', 'quix', 'quiz', 'qun', 'quny', 'qunw', 'qunx', 'qunz',\n    'qut', 'qutt',\n    'sa', 'say', 'saw', 'sah', 'sahh', 'sai', 'saiy', 'saiw', 'saix', 'saiz',\n    'sak', 'sam', 'samy', 'samw', 'samx', 'san', 'sany', 'sanw', 'sang',\n    'sangy', 'sangw', 'sann', 'sannh', 'sap', 'sat', 'sau', 'sauw', 'se', 'sey',\n    'sew', 'sex', 'seh', 'sehh', 'senn', 'senny', 'sennw', 'si', 'siy', 'siw',\n    'six', 'siz', 'sia', 'siay', 'siaw', 'siax', 'siaz', 'siah', 'siahh',\n    'siak', 'siam', 'siamy', 'siamw', 'siamx', 'sien', 'sieny', 'sienw',\n    'sienx', 'sienz', 'siang', 'siangy', 'siangw', 'siangx', 'siangz', 'siann',\n    'sianny', 'siannw', 'siannx', 'siannz', 'siap', 'siapp', 'siet', 'siett',\n    'siau', 'siauy', 'siauw', 'siaux', 'siauz', 'sih', 'sihh', 'sek', 'sekk',\n    'sim', 'simy', 'simw', 'simx', 'simz', 'sin', 'sinw', 'sinx', 'sinz',\n    'seng', 'sengy', 'sengw', 'sengx', 'sengz', 'sinn', 'sinnw', 'sinnz',\n    'siur', 'siury', 'siurx', 'siurh', 'siurhh', 'siok', 'siokk', 'siong',\n    'siongy', 'siongw', 'siongx', 'siongz', 'sip', 'sipp', 'sit', 'sitt', 'siu',\n    'siuy', 'siuw', 'siux', 'siuz', 'siunn', 'siunny', 'siunnw', 'siunnx',\n    'siunnz', 'sng', 'sngy', 'sngw', 'sngx', 'sngh', 'sur', 'sury', 'surw',\n    'surx', 'surz', 'surh', 'sok', 'som', 'song', 'songy', 'songw', 'songx',\n    'so', 'soy', 'sow', 'su', 'suy', 'suw', 'sux', 'suz', 'soa', 'soay', 'soaw',\n    'soah', 'soai', 'soainnz', 'soan', 'soany', 'soanw', 'soanx', 'soanz',\n    'soann', 'soanny', 'soannw', 'soat', 'soe', 'soey', 'soew', 'soex', 'soeh',\n    'suh', 'sui', 'suiy', 'suiw', 'suix', 'suiz', 'sun', 'suny', 'sunw', 'sunx',\n    'sunz', 'sut', 'sutt',\n    'taw', 'tah', 'tahh', 'tai', 'taiy', 'taiw', 'taix', 'taiz', 'tak', 'takk',\n    'tam', 'tamw', 'tamx', 'tamz', 'tan', 'tany', 'tanw', 'tanx', 'tang',\n    'tangy', 'tangw', 'tangx', 'tann', 'tanny', 'tap', 'tat', 'tau', 'tauy',\n    'tauw', 'taux', 'tauz', 'te', 'tey', 'tew', 'tex', 'tez', 'teh', 'tehh',\n    'tennw', 'tennx', 'ti', 'tiy', 'tiw', 'tix', 'tiz', 'tiah', 'tiam', 'tiamy',\n    'tiamz', 'tien', 'tieny', 'tiann', 'tiannw', 'tiannx', 'tiannz', 'tiap',\n    'tiapp', 'tiet', 'tiau', 'tiauy', 'tiauw', 'tiaux', 'tiauz', 'tih', 'tihh',\n    'tek', 'tekk', 'tim', 'tin', 'tinx', 'tinz', 'teng', 'tengy', 'tengw',\n    'tengx', 'tinn', 'tinnz', 'tiur', 'tiurw', 'tiurx', 'tiok', 'tiong',\n    'tiongy', 'tiongw', 'tiongx', 'tiu', 'tiuy', 'tng', 'tngw', 'tngx', 'tngz',\n    'tur', 'tury', 'turw', 'turx', 'turh', 'turhh', 'tok', 'tokk', 'tong',\n    'tongy', 'tongw', 'tongz', 'toy', 'tow', 'tox', 'tuy', 'toa', 'toaz',\n    'toah', 'toanx', 'toann', 'toanny', 'toannw', 'toat', 'tuh', 'tui', 'tuiy',\n    'tuiw', 'tuix', 'tun', 'tuny', 'tunx', 'tunz', 'tut', 'tutt',\n    'u', 'uy', 'uw', 'ux', 'uz', 'uh', 'ui', 'uiy', 'uiw', 'uix', 'uiz', 'un',\n    'uny', 'unw', 'unx', 'unz', 'ut',\n    'ur', 'urw', 'urx', 'urh', 'urhh',\n    'va', 'vay', 'vaw', 'vax', 'vaz', 'vah', 'vai', 'vaiy', 'vaiw', 'vaix',\n    'vaiz', 'vak', 'vakk', 'van', 'vany', 'vanx', 'vanz', 'vang', 'vangy',\n    'vangw', 'vangx', 'vat', 'vatt', 'vau', 'vauy', 'vaux', 'vauz', 've', 'vey',\n    'vew', 'vex', 'vez', 'veh', 'vehh', 'venn', 'vennw', 'vennx', 'vennz', 'vi',\n    'viy', 'viw', 'vix', 'viz', 'viah', 'viak', 'viakk', 'vien', 'vieny',\n    'vienw', 'vienz', 'viangw', 'viangz', 'viann', 'vianny', 'viannw', 'viannx',\n    'viet', 'viett', 'viau', 'viauy', 'vih', 'vek', 'vekk', 'vin', 'viny',\n    'vinw', 'vinx', 'veng', 'vengy', 'vengw', 'vengx', 'vengz', 'vinn', 'vinny',\n    'vinnw', 'vinnz', 'viur', 'viury', 'viurz', 'vit', 'vitt', 'viu', 'vng',\n    'vngy', 'vngz', 'vur', 'vury', 'vurw', 'vurx', 'vurz', 'vurh', 'vurhh',\n    'vok', 'vokk', 'vongy', 'vongw', 'vongx', 'vongz', 'vo', 'voy', 'vow',\n    'vox', 'voz', 'vu', 'vuw', 'vux', 'vuz', 'voaw', 'voah', 'voahh',\n    'voan', 'voanw', 'voanx', 'voanz', 'voann', 'voanny', 'voannw', 'voannx',\n    'voannz', 'voat', 'voatt', 'voe', 'voey', 'voew', 'voex', 'voez', 'voeh',\n    'poehh', 'vuh', 'vui', 'vuix', 'vuiz', 'vun', 'vuny', 'vunw', 'vunx',\n    'vunz', 'vut', 'vutt',\n];\n//# sourceMappingURL=lexicalroots2.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst version2_1 = require(\"./version2\");\nexports.regex_mnng_h_f = /(m|ng?)hf/g;\nexports.sm_mnng_h_f = function (nasalFinal, neutralFinalH, firstTonalF) {\n    const snfs = new version2_1.NasalFinalSounds();\n    const nf_h = new version2_1.NeutralFinalH();\n    const ft_f = new version2_1.FirstTonalF();\n    if (snfs.includes(nasalFinal) && nf_h.includes(neutralFinalH) && ft_f.includes(firstTonalF))\n        return true;\n    return false;\n};\nexports.regex_mnng_hh_wx = /(m|ng?)hh(w|x)/g;\nexports.sm_m_hh_w = function (nasalFinal, neutralFinalHH, thirdTonalW) {\n    if (nasalFinal === version2_1.TonalLetterTags.m && neutralFinalHH === version2_1.TonalLetterTags.hh && thirdTonalW === version2_1.TonalLetterTags.w)\n        return true;\n    return false;\n};\nexports.sm_mnng_hh_wx = function (nasalFinal, neutralFinalHH, thirdFifthTonalWX) {\n    const snfs = new version2_1.NasalFinalSounds();\n    const nf_hh = new version2_1.NeutralFinalHH();\n    const fts_wx = new version2_1.ThirdFifthTonalsWX();\n    if (snfs.includes(nasalFinal) && nf_hh.includes(neutralFinalHH) && fts_wx.includes(thirdFifthTonalWX))\n        return true;\n    return false;\n};\nexports.regex_jls_f = /(j|l|s)f/g;\nexports.sm_jls_f = function (euphonicFinalJLS, firstTonalF) {\n    const efs = new version2_1.EuphonicFinalsJLS();\n    const ft_f = new version2_1.FirstTonalF();\n    if (efs.includes(euphonicFinalJLS) && ft_f.includes(firstTonalF))\n        return true;\n    return false;\n};\nexports.sm_bgkp_f = function (euphonicFinalBGJKLPS, firstTonalF) {\n    const efs = new version2_1.EuphonicFinalsBGKP();\n    const ft_f = new version2_1.FirstTonalF();\n    if (efs.includes(euphonicFinalBGJKLPS) && ft_f.includes(firstTonalF))\n        return true;\n    return false;\n};\nexports.regex_jjllss_wx = /(jj|ll|ss)(w|x)/g;\nexports.sm_jjllss_wx = function (euphonicFinalJJLLSS, thirdFifthTonalWX) {\n    const efs = new version2_1.EuphonicFinalsJJLLSS();\n    const fts_wx = new version2_1.ThirdFifthTonalsWX();\n    if (efs.includes(euphonicFinalJJLLSS) && fts_wx.includes(thirdFifthTonalWX))\n        return true;\n    return false;\n};\nexports.sm_bbggkkpp_wx = function (euphonicFinalBBGGJJKKLLPPSS, thirdFifthTonalWX) {\n    const efs = new version2_1.EuphonicFinalsBBGGKKPP();\n    const fts_wx = new version2_1.ThirdFifthTonalsWX();\n    if (efs.includes(euphonicFinalBBGGJJKKLLPPSS) && fts_wx.includes(thirdFifthTonalWX))\n        return true;\n    return false;\n};\nexports.sm_bgjklps_f = function (euphonicFinalBGJKLPS, firstTonalF) {\n    const efs = new version2_1.EuphonicFinalsBGJKLPS();\n    const ft_f = new version2_1.FirstTonalF();\n    if (efs.includes(euphonicFinalBGJKLPS) && ft_f.includes(firstTonalF))\n        return true;\n    return false;\n};\nexports.sm_bbggjjkkllppss_wx = function (euphonicFinalBBGGJJKKLLPPSS, thirdFifthTonalWX) {\n    const efs = new version2_1.EuphonicFinalsBBGGJJKKLLPPSS();\n    const fts_wx = new version2_1.ThirdFifthTonalsWX();\n    if (efs.includes(euphonicFinalBBGGJJKKLLPPSS) && fts_wx.includes(thirdFifthTonalWX))\n        return true;\n    return false;\n};\n//# sourceMappingURL=matcher.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst morpheme_1 = require(\"../morpheme\");\nconst version2_1 = require(\"./version2\");\nconst version2_2 = require(\"./version2\");\nconst grapheme_1 = require(\"../grapheme\");\nconst soundgen_1 = require(\"./soundgen\");\nconst lexicalroots2_1 = require(\"./lexicalroots2\");\nconst matcher_1 = require(\"./matcher\");\nconst version2_3 = require(\"./version2\");\n//------------------------------------------------------------------------------\nclass TonalUncombiningForms extends morpheme_1.TonalCombiningMetaplasm {\n    apply(sounds, allomorph) {\n        // get base forms as strings\n        if (allomorph) {\n            // member variable allomorph is not null\n            if (allomorph instanceof version2_2.FreeAllomorph) {\n                if (allomorph instanceof version2_1.ZeroAllomorph) {\n                    // no need to pop letter\n                    // push letter to make tone 2\n                    // the base tone of the first tone is the second tone\n                    // 1 to 2\n                    const s = new TonalSyllable(sounds.map(x => new grapheme_1.AlphabeticLetter(x.characters)));\n                    s.pushLetter(new grapheme_1.AlphabeticLetter(version2_1.freeAllomorphUncombiningRules.get('zero')[0].characters));\n                    // console.log(s)\n                    return [s];\n                }\n                else {\n                    // the 7th tone has two baseforms\n                    const ret = [];\n                    for (let i in version2_1.freeAllomorphUncombiningRules.get(allomorph.toString())) {\n                        // pop letter\n                        // push letter\n                        let s = new TonalSyllable(sounds.map(x => new grapheme_1.AlphabeticLetter(x.characters)));\n                        if (!(version2_1.freeAllomorphUncombiningRules.get(allomorph.toString())[i] instanceof version2_1.ZeroAllomorph)) {\n                            // when there is allomorph\n                            // 2 to 3. 3 to 7. 7 to 5. 3 to 5.\n                            s.popLetter();\n                            // there are base tonals\n                            // includes ss and x, exclude zero allomorph\n                            s.pushLetter(new grapheme_1.AlphabeticLetter(version2_1.freeAllomorphUncombiningRules.get(allomorph.toString())[i].characters));\n                            ret.push(s);\n                        }\n                        else {\n                            // include zero suffix. the base tone of the seventh tone.\n                            // exclude ss and x.\n                            // 7 to 1\n                            // tone 1 has no allomorph\n                            s.popLetter();\n                            ret.push(s);\n                        }\n                    }\n                    //console.log(ret)\n                    return ret;\n                }\n            }\n            else if (allomorph instanceof version2_2.CheckedAllomorph) {\n                // pop the last letter\n                // no need to push letter\n                // 1 to 4. 3 to 8. 2 to 4. 5 to 8.\n                if (allomorph.tonal.toString() === '')\n                    return [];\n                const s = new TonalSyllable(sounds.map(x => new grapheme_1.AlphabeticLetter(x.characters)));\n                s.popLetter();\n                //console.log(s.literal)\n                return [s];\n            }\n        }\n        return []; // return empty array\n    }\n}\nexports.TonalUncombiningForms = TonalUncombiningForms;\n//------------------------------------------------------------------------------\nfunction syllabifyTonal(letters, beginOfSyllable) {\n    // get the longest matched syllable pattern\n    let literal = '';\n    let matched = '';\n    let begin = 0;\n    let ltrs = new Array();\n    let matchedLtrs = new Array();\n    const sft = new version2_1.FreeTonalSounds();\n    const ssf = new version2_1.StopFinalSounds();\n    const faurs = version2_1.freeAllomorphUncombiningRules;\n    const ursa = version2_1.uncombiningRulesAy;\n    for (let i = beginOfSyllable; i < letters.length; i++) {\n        literal = literal + letters[i].literal;\n        ltrs.push(letters[i].literal);\n        //console.log(`begining of the loop: ${literal}. ${ltrs}`)\n        if (lexicalroots2_1.lexical_roots.includes(literal) && sft.includes(letters[i].literal)) {\n            //console.log(`i: ${i}, literal: ${literal}, tone: ${letters[i].literal}, letters[i+1]: ${letters[i + 1].literal}`)\n            if (begin === beginOfSyllable) {\n                matched = literal;\n                Object.assign(matchedLtrs, ltrs);\n            }\n            break;\n        }\n        else if (lexicalroots2_1.lexical_roots.includes(literal) && ssf.includes(letters[i].literal)) {\n            //console.log(`i: ${i}, literal: ${literal}, stopFinal: ${letters[i].literal}`)\n            //console.log(`begin: ${begin}, beginOfSyllable: ${beginOfSyllable}`)\n            if (begin === beginOfSyllable) {\n                matched = literal;\n                Object.assign(matchedLtrs, ltrs);\n            }\n            break;\n        }\n        else if (sft.includes(letters[i].literal)) {\n            // check tonals is the subset of free tonals\n            // console.log('i: %d', i)\n            // console.log(`i: ${i}, literal: ${literal}, letters[i].literal, ${letters[i].literal}`)\n            // when there are tonals\n            if ((literal.length > 1 &&\n                letters[i] &&\n                letters[i - 1] &&\n                matcher_1.sm_bgkp_f(letters[i - 1].literal, letters[i].literal)) ||\n                (literal.length > 1 && matcher_1.sm_bbggkkpp_wx(letters[i - 1].literal, letters[i].literal))) {\n                // this combining form is not present in the pool.\n                matched = literal;\n                Object.assign(matchedLtrs, ltrs);\n                break;\n            }\n            else if (literal.length > 2 &&\n                letters[i] &&\n                letters[i - 1] &&\n                letters[i - 2] &&\n                matcher_1.sm_m_hh_w(letters[i - 2].literal, letters[i - 1].literal, letters[i].literal)) {\n                // for lexical roots end with ~mhhw.\n                matched = literal;\n                Object.assign(matchedLtrs, ltrs);\n                break;\n            }\n            // tone sandhi of free allomorph\n            const tnls_fa = faurs.get(letters[i].literal).map(x => x.toString());\n            // tone sandhi of ay\n            const tnls_ay = ursa.get(letters[i].literal).map(x => x.toString());\n            // merge the above twoo arrays\n            const tnls = tnls_fa.concat(tnls_ay.filter(item => tnls_fa.indexOf(item) < 0));\n            //console.log(ts)\n            if (tnls.length > 0) {\n                for (let t of tnls) {\n                    //console.log(lit + t.toString())\n                    if (lexicalroots2_1.lexical_roots.includes(letters\n                        .slice(beginOfSyllable, i)\n                        .map(x => x.literal)\n                        .join('') + t)) {\n                        // this combining form is not present in the pool,\n                        // but its uncombining forms are. e.g. aw.\n                        matched = literal;\n                        //begin = beginOfSyllable;\n                        Object.assign(matchedLtrs, ltrs);\n                        break;\n                    }\n                }\n                if (matched.length > 0 && matchedLtrs.length > 0)\n                    break;\n            }\n            else {\n                // no uncombining forms for this combining form. e.g. ax.\n                matched = '';\n                matchedLtrs = [];\n            }\n        }\n        else if (lexicalroots2_1.lexical_roots.includes(literal)) {\n            matched = literal;\n            Object.assign(matchedLtrs, ltrs);\n            begin = beginOfSyllable;\n            //console.log(matched)\n        }\n        else {\n            //console.log('no matched for syllabifyTonal:' + ltrs)\n            // when there are no tonals\n            if (letters[i].literal === version2_1.TonalLetterTags.gg) {\n                // for surface form gg whose underlying form could be tt or kk.\n                matched = literal;\n                Object.assign(matchedLtrs, ltrs);\n            }\n            else if (!sft.includes(letters[i].literal)) {\n                // free first tone without a free tonal\n                const ts = faurs.get(version2_1.TonalLetterTags.zero);\n                for (let t of ts) {\n                    // append second tonal letter\n                    // check the uncombining forms\n                    if (lexicalroots2_1.lexical_roots.includes(literal + t.toString())) {\n                        // if the free first tone's lemma is included\n                        matched = literal;\n                        Object.assign(matchedLtrs, ltrs);\n                        //break;\n                    }\n                }\n            }\n            // when there is no matched lexcial roots for this syllable, we still assign begin\n            begin = beginOfSyllable;\n        }\n    }\n    // console.log(`literal: ${literal}. matched: ${matched}`)\n    // console.log(matchedLtrs)\n    if (matched.length > 0 && literal.length > matched.length) {\n        // when ~ay is longer than ~a by one letter y\n        // for those first tone lexcial roots that are present\n        matched = '';\n        matchedLtrs = [];\n    }\n    //console.log('matched: ' + matched)\n    const tsg = new soundgen_1.TonalSoundGenerator();\n    //console.log('matched: ' + matched)\n    let list = new Array();\n    if (matched.length > 0) {\n        list = tsg.generate(matchedLtrs);\n    }\n    else {\n        if (ltrs.length == 3 && ltrs[1] === 'a' && ltrs[2] === 'y') {\n            const ep = new version2_1.EpenthesisSounds();\n            const rea = new morpheme_1.RemovingEpenthesisOfAy();\n            const done = rea.applyToString(literal);\n            //console.log(done.toString())\n            if (ep.includes(ltrs[0]) && lexicalroots2_1.lexical_roots.includes(done)) {\n                list = tsg.generate(ltrs);\n            }\n        }\n    }\n    //console.log(list)\n    let matchedLen = 0;\n    let mp = new morpheme_1.MatchedPattern();\n    for (let m in list) {\n        const min = Math.min(letters.length - beginOfSyllable, list[m].length);\n        if (list[m].length == min) {\n            for (let n = 0; n < min; n++) {\n                if (list[m][n] != undefined) {\n                    if (letters[beginOfSyllable + n].literal === list[m][n].toString()) {\n                        //console.log(syllabary[m])\n                        if (n + 1 == min && min > matchedLen) {\n                            // to make sure it is longer than previous patterns\n                            // last letter matched for the pattern\n                            matchedLen = min;\n                            // copy the matched letters\n                            for (let q = 0; q < matchedLen; q++) {\n                                mp.letters[q] = letters[beginOfSyllable + q];\n                            }\n                            // copy the pattern of sounds\n                            mp.pattern = list[m];\n                            //console.log(syllabary.list[m])\n                            //console.log(mp.letters)\n                        }\n                    }\n                    else {\n                        break;\n                    }\n                }\n            }\n        }\n    }\n    return mp;\n}\nexports.syllabifyTonal = syllabifyTonal;\n//------------------------------------------------------------------------------\nclass TonalSyllable extends morpheme_1.Syllable {\n    popLetter() {\n        this.letters = this.letters.slice(0, this.letters.length - 1);\n        this.concat();\n    }\n    get lastLetter() {\n        if (this.letters.length >= 1)\n            return this.letters[this.letters.length - 1];\n        return new grapheme_1.AlphabeticLetter();\n    }\n    get lastSecondLetter() {\n        if (this.letters.length >= 2)\n            return this.letters[this.letters.length - 2];\n        return new grapheme_1.AlphabeticLetter();\n    }\n}\nexports.TonalSyllable = TonalSyllable;\n//------------------------------------------------------------------------------\nclass TonalUncombiningMorpheme extends morpheme_1.Morpheme {\n    constructor(syllable, sounds, tcm) {\n        super();\n        this.syllable = syllable;\n        this.metaplasm = tcm;\n        // assign allomorph for each syllable\n        this.allomorph = this.assignAllomorph(this.syllable);\n        this.sounds = new Array();\n        this.sounds = sounds;\n    }\n    getForms() {\n        return this.metaplasm.apply(this.sounds, this.allomorph);\n    }\n    assignAllomorph(syllable) {\n        let allomorph = new version2_1.ZeroAllomorph();\n        // assign the matched allomorph for this syllable\n        let aoas = []; // array of allomorphs\n        let keys = Array.from(version2_1.checkedAllomorphs.keys());\n        for (let k = 0; k < keys.length; k++) {\n            let am = version2_1.checkedAllomorphs.get(keys[k]);\n            if (am instanceof version2_2.CheckedAllomorph) {\n                if (am.tonal) {\n                    if (am.tonal.toString() === syllable.lastLetter.literal &&\n                        am.final.toString() === syllable.lastSecondLetter.literal) {\n                        aoas.push(version2_1.checkedAllomorphs.get(keys[k]));\n                        break;\n                    }\n                    else {\n                        if (am.final.toString() === syllable.lastLetter.literal) {\n                            aoas.push(version2_1.checkedAllomorphs.get(keys[k]));\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n        if (aoas.length > 0) {\n            // there is only one match after processing, we just assign it\n            let ret = aoas.shift();\n            if (ret)\n                return ret;\n        }\n        // after matching with checked allomorphs, we go on matching free allomorphs\n        aoas = [];\n        if (version2_1.freeAllomorphs.has(syllable.lastLetter.literal)) {\n            aoas.push(version2_1.freeAllomorphs.get(syllable.lastLetter.literal));\n        }\n        if (aoas.length == 0) {\n            // tone 1 has no allomorph\n            allomorph = new version2_1.ZeroAllomorph();\n        }\n        else if (aoas.length == 1) {\n            // are there multiple allomorphs? there should be only one.\n            for (let i = 0; i < aoas.length; i++) {\n                if (aoas[i].tonal.isEqualToTonal(new version2_1.AllomorphX().tonal)) {\n                    // this syllable is already in base form\n                    // in order to display this inflectional ending, we have to assign\n                    allomorph = aoas[i];\n                }\n                else {\n                    allomorph = aoas[i];\n                }\n            }\n        }\n        return allomorph;\n    }\n}\nexports.TonalUncombiningMorpheme = TonalUncombiningMorpheme;\n//------------------------------------------------------------------------------\nclass TonalUncombiningMorphemeMaker extends morpheme_1.MorphemeMaker {\n    constructor(tcm) {\n        super();\n        this.euphonicFinals = new Array();\n        this.euphonicFinalTonals = new Array();\n        this.metaplasm = tcm;\n    }\n    createMorphemes() {\n        return new Array();\n    }\n    createMorpheme(msp) {\n        const tum = new TonalUncombiningMorpheme(new TonalSyllable(msp.letters), msp.pattern, this.metaplasm);\n        return tum;\n    }\n    preprocessEuphonicFinal(letters) {\n        this.euphonicFinals.push(letters[letters.length - 1]);\n        return letters.slice(0, letters.length - 1);\n    }\n    preprocessEuphonicFinalTonal(letters, literal, regex, len) {\n        const arr = literal.match(regex);\n        // console.log(arr)\n        let indx = -1;\n        if (len == 1) {\n            for (let i = 0; i < letters.length - 1; i++) {\n                if (matcher_1.sm_jls_f(letters[i].literal, letters[i + 1].literal) ||\n                    matcher_1.sm_jjllss_wx(letters[i].literal, letters[i + 1].literal)) {\n                    indx = i;\n                    break;\n                }\n            }\n        }\n        else if (len == 2) {\n            for (let i = 0; i < letters.length - 2; i++) {\n                if (matcher_1.sm_mnng_h_f(letters[i].literal, letters[i + 1].literal, letters[i + 2].literal) ||\n                    matcher_1.sm_mnng_hh_wx(letters[i].literal, letters[i + 1].literal, letters[i + 2].literal)) {\n                    indx = i;\n                    break;\n                }\n            }\n        }\n        if (arr) {\n            for (let i in arr) {\n                const idxl = literal.search(arr[i]);\n                const sub1 = literal.substring(0, idxl);\n                const sub2 = literal.substring(idxl + arr[i].length);\n                // in case of hmhhw or hmhhwhmhhw\n                // check if the previous letter is a consonant\n                if (new version2_3.InitialSounds().includes(sub1))\n                    return letters;\n                let fnl;\n                if (new version2_1.FirstTonalF().includes(arr[i].charAt(arr[i].length - 1))) {\n                    literal = sub1.concat(version2_1.TonalLetterTags.t + version2_1.TonalLetterTags.f, sub2);\n                    fnl = letters.splice(indx, len, version2_1.lowerLettersOfTonal.get(version2_1.TonalLetterTags.t));\n                }\n                else if (new version2_1.ThirdFifthTonalsWX().includes(arr[i].charAt(arr[i].length - 1))) {\n                    if (arr[i].charAt(arr[i].length - 1) === version2_1.TonalLetterTags.w)\n                        literal = sub1.concat(version2_1.TonalLetterTags.tt + version2_1.TonalLetterTags.w, sub2);\n                    else if (arr[i].charAt(arr[i].length - 1) === version2_1.TonalLetterTags.x)\n                        literal = sub1.concat(version2_1.TonalLetterTags.tt + version2_1.TonalLetterTags.x, sub2);\n                    fnl = letters.splice(indx, len, version2_1.lowerLettersOfTonal.get(version2_1.TonalLetterTags.tt));\n                }\n                // console.log(literal)\n                if (fnl && len == 1)\n                    this.euphonicFinalTonals.push({ index: indx, letters: [fnl[0]] });\n                else if (fnl && len == 2)\n                    this.euphonicFinalTonals.push({ index: indx, letters: [fnl[0], fnl[1]] });\n            }\n            // console.log(this.euphonicFinalTonals[0].letters)\n        }\n        return letters;\n    }\n    replaceEuphonicFinal(letters) {\n        const slicedLetters = letters.slice(0, letters.length - 1);\n        const literal = slicedLetters.map(it => it.literal).join('');\n        if (letters.length > 0 &&\n            letters[letters.length - 1].literal === version2_1.TonalLetterTags.gg &&\n            lexicalroots2_1.lexical_roots.includes(literal + version2_1.TonalLetterTags.tt) &&\n            !lexicalroots2_1.lexical_roots.includes(literal + version2_1.TonalLetterTags.kk)) {\n            // for surface form gg whose underlying form is tt but not kk\n            const ls = this.preprocessEuphonicFinal(letters);\n            ls.push(version2_1.lowerLettersOfTonal.get(version2_1.TonalLetterTags.tt));\n            return ls;\n        }\n        return letters;\n    }\n    replaceEuphonicFinalTonal(letters) {\n        let literal = letters.map(x => x.literal).join('');\n        if (literal.length > 1 && matcher_1.regex_jls_f.test(literal)) {\n            const ls = this.preprocessEuphonicFinalTonal(letters, literal, matcher_1.regex_jls_f, 1);\n            return ls;\n        }\n        else if (literal.length > 1 && matcher_1.regex_jjllss_wx.test(literal)) {\n            const ls = this.preprocessEuphonicFinalTonal(letters, literal, matcher_1.regex_jjllss_wx, 1);\n            return ls;\n        }\n        else if (literal.length > 2 && matcher_1.regex_mnng_h_f.test(literal)) {\n            const ls = this.preprocessEuphonicFinalTonal(letters, literal, matcher_1.regex_mnng_h_f, 2);\n            return ls;\n        }\n        else if (literal.length > 2 && matcher_1.regex_mnng_hh_wx.test(literal)) {\n            const ls = this.preprocessEuphonicFinalTonal(letters, literal, matcher_1.regex_mnng_hh_wx, 2);\n            return ls;\n        }\n        return letters;\n    }\n    replaceInitial() {\n        return [];\n    }\n    replaceMedial() {\n        return [];\n    }\n    preprocess(gs) {\n        let ltrs = new Array();\n        ltrs = gs.map(it => it.letter);\n        ltrs = this.replaceEuphonicFinal(ltrs);\n        ltrs = this.replaceEuphonicFinalTonal(ltrs);\n        return ltrs;\n    }\n    postprocess_euphonic_t_or_tt(pattern) {\n        if ((pattern.letters[pattern.letters.length - 1].literal === version2_1.TonalLetterTags.t ||\n            pattern.letters[pattern.letters.length - 1].literal === version2_1.TonalLetterTags.tt) &&\n            this.euphonicFinals.length > 0) {\n            pattern.letters.pop();\n            pattern.pattern.pop();\n            const fnl = this.euphonicFinals.pop();\n            if (fnl) {\n                pattern.letters.push(fnl);\n                const snd = version2_1.tonalPositionalSound.get(fnl.literal);\n                if (snd)\n                    pattern.pattern.push(snd(version2_1.TonalSoundTags.stopFinal));\n            }\n        }\n        else if (this.euphonicFinalTonals.length > 0) {\n            const fnl = this.euphonicFinalTonals.pop();\n            if (fnl) {\n                if (fnl.letters.length == 1) {\n                    pattern.letters.splice(fnl.index, 1, fnl.letters[0]);\n                    const snd = version2_1.tonalPositionalSound.get(fnl.letters[0].literal);\n                    if (snd)\n                        pattern.pattern.splice(fnl.index, 1, snd(version2_1.TonalSoundTags.stopFinal));\n                }\n                else if (fnl.letters.length == 2) {\n                    // console.log(pattern)\n                    pattern.letters.splice(fnl.index, 1, fnl.letters[0], fnl.letters[1]);\n                    const snd1 = version2_1.tonalPositionalSound.get(fnl.letters[0].literal);\n                    const snd2 = version2_1.tonalPositionalSound.get(fnl.letters[1].literal);\n                    if (snd1 && snd2)\n                        pattern.pattern.splice(fnl.index, 1, snd1(version2_1.TonalSoundTags.nasalFinal), snd2(version2_1.TonalSoundTags.stopFinal));\n                    // console.log(pattern)\n                }\n            }\n        }\n        return pattern;\n    }\n    postprocess(patterns) {\n        let morphemes = this.createMorphemes();\n        for (let i in patterns) {\n            const pat = this.postprocess_euphonic_t_or_tt(patterns[i]);\n            morphemes.push(this.createMorpheme(pat));\n        }\n        return morphemes;\n    }\n    makeMorphemes(gs) {\n        const ltrs = this.preprocess(gs);\n        const ptrns = this.make(ltrs, syllabifyTonal);\n        const ms = this.postprocess(ptrns);\n        return ms;\n    }\n}\nexports.TonalUncombiningMorphemeMaker = TonalUncombiningMorphemeMaker;\n//# sourceMappingURL=morpheme.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst grapheme_1 = require(\"../grapheme\");\nconst version2_1 = require(\"./version2\");\nfunction initialConsonant(sg) {\n    const sis = new version2_1.InitialSounds();\n    if (sis.includes(sg.letters[sg.sounds.length])) {\n        const ps = version2_1.tonalPositionalSound.get(sg.letters[sg.sounds.length]);\n        if (ps) {\n            const s = ps(version2_1.TonalSoundTags.initial);\n            if (s)\n                sg.sounds.push(s);\n        }\n    }\n    else\n        sg.matching = false;\n    return sg;\n}\nfunction stopFinalConsonant(sg) {\n    if (!sg.matching)\n        return sg;\n    const ssfs = new version2_1.StopFinalSounds();\n    if (ssfs.includes(sg.letters[sg.sounds.length])) {\n        const ps = version2_1.tonalPositionalSound.get(sg.letters[sg.sounds.length]);\n        if (ps) {\n            const s = ps(version2_1.TonalSoundTags.stopFinal);\n            if (s)\n                sg.sounds.push(s);\n        }\n    }\n    else {\n        sg.matching = false;\n        if (sg.letters.length == sg.sounds.length && sg.prompt)\n            sg.prompts.push(ssfs.sounds);\n    }\n    return sg;\n}\nfunction neutralFinalConsonant(sg) {\n    if (!sg.matching)\n        return sg;\n    const snfs = new version2_1.NeutralFinalSounds();\n    if (snfs.includes(sg.letters[sg.sounds.length])) {\n        const ps = version2_1.tonalPositionalSound.get(sg.letters[sg.sounds.length]);\n        if (ps) {\n            const s = ps(version2_1.TonalSoundTags.stopFinal);\n            if (s)\n                sg.sounds.push(s);\n        }\n    }\n    else {\n        sg.matching = false;\n        if (sg.letters.length == sg.sounds.length && sg.prompt)\n            sg.prompts.push(snfs.sounds);\n    }\n    return sg;\n}\nfunction nasalFinalConsonant(sg) {\n    if (!sg.matching)\n        return sg;\n    const snfs = new version2_1.NasalFinalSounds();\n    if (snfs.includes(sg.letters[sg.sounds.length])) {\n        const ps = version2_1.tonalPositionalSound.get(sg.letters[sg.sounds.length]);\n        if (ps) {\n            const s = ps(version2_1.TonalSoundTags.nasalFinal);\n            if (s)\n                sg.sounds.push(s);\n        }\n    }\n    else {\n        sg.matching = false;\n        if (sg.letters.length == sg.sounds.length && sg.prompt)\n            sg.prompts.push(snfs.sounds);\n    }\n    return sg;\n}\nfunction vowel(sg) {\n    const sms = new version2_1.MedialSounds();\n    // const len = sg.sounds.length;\n    let toBePrompted = true;\n    let matches = 0;\n    for (let i = sg.sounds.length; i < sg.letters.length; i++) {\n        // console.log(`sg.sounds.length: ${sg.sounds.length}`);\n        if (sms.includes(sg.letters[i])) {\n            toBePrompted = false;\n            const ps = version2_1.tonalPositionalSound.get(sg.letters[i]);\n            if (ps) {\n                const s = ps(version2_1.TonalSoundTags.medial);\n                matches++;\n                if (s)\n                    sg.sounds.push(s);\n            }\n        }\n        else {\n            toBePrompted = false;\n            if (matches == 0)\n                sg.matching = false;\n            break;\n        }\n    }\n    if (toBePrompted) {\n        if (sg.prompt && sg.letters.length > 0)\n            sg.prompts.push(sms.sounds);\n        sg.matching = false;\n    }\n    return sg;\n}\nfunction materLectionis(sg) {\n    const sml = new version2_1.MaterLectionisSounds();\n    if (sml.includes(sg.letters[sg.sounds.length])) {\n        const ps = version2_1.tonalPositionalSound.get(sg.letters[sg.sounds.length]);\n        if (ps) {\n            const s = ps(version2_1.TonalSoundTags.medial);\n            if (s)\n                sg.sounds.push(s);\n        }\n    }\n    else\n        sg.matching = false;\n    return sg;\n}\nfunction nasalization(sg) {\n    if (!sg.matching)\n        return sg;\n    const sns = new version2_1.NasalizationSound();\n    if (sns.includes(sg.letters[sg.sounds.length])) {\n        const ps = version2_1.tonalPositionalSound.get(sg.letters[sg.sounds.length]);\n        if (ps) {\n            const s = ps(version2_1.TonalSoundTags.nasalization);\n            if (s)\n                sg.sounds.push(s);\n        }\n    }\n    else {\n        sg.matching = false;\n        if (sg.letters.length == sg.sounds.length && sg.prompt)\n            sg.prompts.push(sns.sounds);\n    }\n    return sg;\n}\nfunction freeTone(sg) {\n    if (!sg.matching)\n        return sg;\n    const sfts = new version2_1.FreeTonalSounds();\n    if (sfts.includes(sg.letters[sg.sounds.length])) {\n        const ps = version2_1.tonalPositionalSound.get(sg.letters[sg.sounds.length]);\n        if (ps) {\n            const s = ps(version2_1.TonalSoundTags.freeTonal);\n            if (s)\n                sg.sounds.push(s);\n        }\n    }\n    else {\n        sg.matching = false;\n        if (sg.letters.length == sg.sounds.length && sg.prompt)\n            sg.prompts.push(sfts.sounds);\n    }\n    return sg;\n}\nfunction checkedTone(sg) {\n    if (!sg.matching)\n        return sg;\n    const scts = new version2_1.CheckedTonalSounds();\n    if (scts.includes(sg.letters[sg.sounds.length])) {\n        const ps = version2_1.tonalPositionalSound.get(sg.letters[sg.sounds.length]);\n        if (ps) {\n            const s = ps(version2_1.TonalSoundTags.checkedTonal);\n            if (s)\n                sg.sounds.push(s);\n        }\n    }\n    else {\n        sg.matching = false;\n        if (sg.letters.length == sg.sounds.length && sg.prompt)\n            sg.prompts.push(scts.sounds);\n    }\n    return sg;\n}\nfunction euphonicFinalConsonant(sg) {\n    if (!sg.matching)\n        return sg;\n    const ef_bgjklps = new version2_1.EuphonicFinalsBGJKLPS();\n    const ef_bbggjjkkllppss = new version2_1.EuphonicFinalsBBGGJJKKLLPPSS();\n    if (ef_bgjklps.includes(sg.letters[sg.sounds.length]) || ef_bbggjjkkllppss.includes(sg.letters[sg.sounds.length])) {\n        const ps = version2_1.tonalPositionalSound.get(sg.letters[sg.sounds.length]);\n        if (ps) {\n            const s = ps(version2_1.TonalSoundTags.stopFinal);\n            if (s)\n                sg.sounds.push(s);\n        }\n    }\n    else {\n        sg.matching = false;\n        if (sg.letters.length == sg.sounds.length && sg.prompt && sg.promptEuphonicFinal) {\n            sg.prompts.push(ef_bgjklps.sounds);\n            sg.prompts.push(ef_bbggjjkkllppss.sounds);\n        }\n    }\n    return sg;\n}\n// common syllables\nconst sc_v = grapheme_1.pipe(vowel);\nconst sc_m = grapheme_1.pipe(materLectionis);\nconst sc_vt = grapheme_1.pipe(vowel, freeTone);\nconst sc_mt = grapheme_1.pipe(materLectionis, freeTone);\n//const sc_mc = pipe(materLectionis, neutralFinalConsonant);\nconst sc_cv = grapheme_1.pipe(initialConsonant, vowel);\nconst sc_vc1 = grapheme_1.pipe(vowel, stopFinalConsonant);\nconst sc_vc2 = grapheme_1.pipe(vowel, nasalFinalConsonant);\nconst sc_vct1 = grapheme_1.pipe(vowel, stopFinalConsonant, checkedTone);\nconst sc_vct2 = grapheme_1.pipe(vowel, nasalFinalConsonant, freeTone);\nconst sc_cvt = grapheme_1.pipe(initialConsonant, vowel, freeTone);\nconst sc_cvc1 = grapheme_1.pipe(initialConsonant, vowel, stopFinalConsonant);\nconst sc_cvc2 = grapheme_1.pipe(initialConsonant, vowel, nasalFinalConsonant);\nconst sc_cvct1 = grapheme_1.pipe(initialConsonant, vowel, stopFinalConsonant, checkedTone);\nconst sc_cvct2 = grapheme_1.pipe(initialConsonant, vowel, nasalFinalConsonant, freeTone);\n//const sc_cvcc = pipe(initialConsonant, vowel, nasalFinalConsonant, neutralFinalConsonant);\n// consonant syllables\nconst sc_cc = grapheme_1.pipe(initialConsonant, nasalFinalConsonant);\nconst sc_cct = grapheme_1.pipe(initialConsonant, nasalFinalConsonant, freeTone);\nconst sc_ccc = grapheme_1.pipe(initialConsonant, nasalFinalConsonant, neutralFinalConsonant);\nconst sc_ccct = grapheme_1.pipe(initialConsonant, nasalFinalConsonant, neutralFinalConsonant, checkedTone);\n// nasalization syllables\nconst sc_vn = grapheme_1.pipe(vowel, nasalization);\nconst sc_vnt = grapheme_1.pipe(vowel, nasalization, freeTone);\nconst sc_cvn = grapheme_1.pipe(initialConsonant, vowel, nasalization);\nconst sc_cvnt = grapheme_1.pipe(initialConsonant, vowel, nasalization, freeTone);\n//const sc_vnc = pipe(vowel, nasalization, neutralFinalConsonant);\n//const sc_vnct = pipe(vowel, nasalization, neutralFinalConsonant, checkedTone);\nconst sc_cvnc = grapheme_1.pipe(initialConsonant, vowel, nasalization, neutralFinalConsonant);\nconst sc_cvnct = grapheme_1.pipe(initialConsonant, vowel, nasalization, neutralFinalConsonant, checkedTone);\n// euphonic syllables\nconst sc_vc3 = grapheme_1.pipe(vowel, euphonicFinalConsonant);\nconst sc_vct3 = grapheme_1.pipe(vowel, euphonicFinalConsonant, checkedTone);\nconst sc_cvc3 = grapheme_1.pipe(initialConsonant, vowel, euphonicFinalConsonant);\nconst sc_cvct3 = grapheme_1.pipe(initialConsonant, vowel, euphonicFinalConsonant, checkedTone);\nconst sc_cvcct = grapheme_1.pipe(initialConsonant, vowel, nasalFinalConsonant, neutralFinalConsonant, checkedTone);\n// syllable compositions or patterns\nexports.syllable_compositions = [\n    sc_v,\n    sc_m,\n    sc_vt,\n    sc_mt,\n    sc_cv,\n    sc_vc1,\n    sc_vc2,\n    sc_vct1,\n    sc_vct2,\n    sc_cvt,\n    sc_cvc1,\n    sc_cvc2,\n    sc_cvct1,\n    sc_cvct2,\n    sc_cc,\n    sc_cct,\n    sc_ccc,\n    sc_ccct,\n    sc_vn,\n    sc_vnt,\n    sc_cvn,\n    sc_cvnt,\n    sc_cvnc,\n    sc_cvnct,\n    sc_vc3,\n    sc_vct3,\n    sc_cvc3,\n    sc_cvct3,\n    sc_cvcct,\n];\nclass TonalSoundGenerator {\n    isStopFinal(str) {\n        if (new version2_1.StopFinalSounds().includes(str))\n            return true;\n        return false;\n    }\n    genChecked(ltrs) {\n        const to_s = version2_1.combiningRules.get(ltrs[ltrs.length - 1]);\n        let strs = new Array();\n        strs.push(ltrs);\n        //console.debug(to_s)\n        if (to_s) {\n            for (let i in to_s) {\n                let syl = new Array();\n                Object.assign(syl, ltrs);\n                syl.push(to_s[i].toString());\n                strs.push(syl);\n            }\n        }\n        return strs;\n    }\n    generate(letters) {\n        let strs = new Array();\n        const sequences = new Array(); // to be returned\n        if (this.isStopFinal(letters[letters.length - 1])) {\n            strs = this.genChecked(letters);\n        }\n        else {\n            strs.push(letters);\n        }\n        for (let i in strs) {\n            // generates all needed sounds to be processed\n            for (let j = 0; j < exports.syllable_compositions.length; j++) {\n                let sg = new grapheme_1.SoundGeneration();\n                sg.letters = strs[i];\n                //console.log(`j: ${j}`)\n                sg = exports.syllable_compositions[j](sg);\n                if (sg.letters.length == sg.sounds.length && sg.matching == true) {\n                    sequences.push(sg.sounds);\n                    break;\n                }\n            }\n        }\n        //console.log(sequences)\n        return sequences;\n    }\n}\nexports.TonalSoundGenerator = TonalSoundGenerator;\n//# sourceMappingURL=soundgen.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst grapheme_1 = require(\"../grapheme\");\n//------------------------------------------------------------------------------\nclass Morph {\n}\nexports.Morph = Morph;\n//------------------------------------------------------------------------------\nclass Allomorph extends Morph {\n    constructor() {\n        super(...arguments);\n        this.tonal = new Tonal();\n    }\n    toString() {\n        if (this.tonal.toString().length == 0) {\n            // return string 'zero' for first tone. member variable characters of graph is still null.\n            return TonalLetterTags.zero;\n        }\n        else\n            return this.tonal.toString();\n    }\n}\nexports.Allomorph = Allomorph;\nclass FreeAllomorph extends Allomorph {\n}\nexports.FreeAllomorph = FreeAllomorph;\nclass CheckedAllomorph extends Allomorph {\n    constructor() {\n        super(...arguments);\n        this.final = new Final();\n    }\n    toString() {\n        if (this.tonal.toString()) {\n            return this.final.toString() + this.tonal.toString();\n        }\n        return this.final.toString();\n    }\n}\nexports.CheckedAllomorph = CheckedAllomorph;\nclass TonalAffix extends Morph {\n    constructor() {\n        super(...arguments);\n        this.tonal = new Tonal();\n    }\n    toString() {\n        return this.tonal.toString();\n    }\n}\nexports.TonalAffix = TonalAffix;\nclass FreeAffix extends TonalAffix {\n}\nclass CheckedAffix extends TonalAffix {\n}\n//------------------------------------------------------------------------------\nvar TonalLetterTags;\n(function (TonalLetterTags) {\n    TonalLetterTags[\"a\"] = \"a\";\n    TonalLetterTags[\"e\"] = \"e\";\n    TonalLetterTags[\"i\"] = \"i\";\n    TonalLetterTags[\"o\"] = \"o\";\n    TonalLetterTags[\"u\"] = \"u\";\n    TonalLetterTags[\"ur\"] = \"ur\";\n    TonalLetterTags[\"c\"] = \"c\";\n    TonalLetterTags[\"d\"] = \"d\";\n    TonalLetterTags[\"ch\"] = \"ch\";\n    TonalLetterTags[\"j\"] = \"j\";\n    TonalLetterTags[\"q\"] = \"q\";\n    TonalLetterTags[\"s\"] = \"s\";\n    TonalLetterTags[\"v\"] = \"v\";\n    TonalLetterTags[\"m\"] = \"m\";\n    TonalLetterTags[\"n\"] = \"n\";\n    TonalLetterTags[\"ng\"] = \"ng\";\n    TonalLetterTags[\"nn\"] = \"nn\";\n    TonalLetterTags[\"f\"] = \"f\";\n    TonalLetterTags[\"w\"] = \"w\";\n    TonalLetterTags[\"x\"] = \"x\";\n    TonalLetterTags[\"xx\"] = \"xx\";\n    TonalLetterTags[\"xxx\"] = \"xxx\";\n    TonalLetterTags[\"y\"] = \"y\";\n    TonalLetterTags[\"z\"] = \"z\";\n    TonalLetterTags[\"zx\"] = \"zx\";\n    TonalLetterTags[\"b\"] = \"b\";\n    TonalLetterTags[\"g\"] = \"g\";\n    TonalLetterTags[\"l\"] = \"l\";\n    TonalLetterTags[\"k\"] = \"k\";\n    TonalLetterTags[\"p\"] = \"p\";\n    TonalLetterTags[\"t\"] = \"t\";\n    TonalLetterTags[\"kk\"] = \"kk\";\n    TonalLetterTags[\"pp\"] = \"pp\";\n    TonalLetterTags[\"tt\"] = \"tt\";\n    TonalLetterTags[\"hh\"] = \"hh\";\n    TonalLetterTags[\"bb\"] = \"bb\";\n    TonalLetterTags[\"gg\"] = \"gg\";\n    TonalLetterTags[\"jj\"] = \"jj\";\n    TonalLetterTags[\"ll\"] = \"ll\";\n    TonalLetterTags[\"ss\"] = \"ss\";\n    TonalLetterTags[\"h\"] = \"h\";\n    TonalLetterTags[\"zero\"] = \"zero\";\n    TonalLetterTags[\"er\"] = \"er\";\n    TonalLetterTags[\"ir\"] = \"ir\";\n    TonalLetterTags[\"or\"] = \"or\";\n})(TonalLetterTags = exports.TonalLetterTags || (exports.TonalLetterTags = {}));\nclass LettersOfTonal extends grapheme_1.Letters {\n}\nexports.LettersOfTonal = LettersOfTonal;\nexports.lowerLettersOfTonal = new LettersOfTonal([\n    TonalLetterTags.a,\n    TonalLetterTags.e,\n    TonalLetterTags.i,\n    TonalLetterTags.o,\n    TonalLetterTags.u,\n    TonalLetterTags.ur,\n    TonalLetterTags.c,\n    TonalLetterTags.d,\n    TonalLetterTags.ch,\n    TonalLetterTags.j,\n    TonalLetterTags.q,\n    TonalLetterTags.s,\n    TonalLetterTags.v,\n    TonalLetterTags.m,\n    TonalLetterTags.n,\n    TonalLetterTags.ng,\n    TonalLetterTags.nn,\n    TonalLetterTags.w,\n    TonalLetterTags.xx,\n    TonalLetterTags.xxx,\n    TonalLetterTags.z,\n    TonalLetterTags.zx,\n    TonalLetterTags.x,\n    TonalLetterTags.y,\n    TonalLetterTags.b,\n    TonalLetterTags.g,\n    TonalLetterTags.l,\n    TonalLetterTags.k,\n    TonalLetterTags.p,\n    TonalLetterTags.t,\n    TonalLetterTags.kk,\n    TonalLetterTags.pp,\n    TonalLetterTags.tt,\n    TonalLetterTags.hh,\n    TonalLetterTags.bb,\n    TonalLetterTags.gg,\n    TonalLetterTags.jj,\n    TonalLetterTags.ll,\n    TonalLetterTags.ss,\n    TonalLetterTags.f,\n    TonalLetterTags.h,\n    TonalLetterTags.er,\n    TonalLetterTags.ir,\n    TonalLetterTags.or,\n]);\n//------------------------------------------------------------------------------\nvar TonalSoundTags;\n(function (TonalSoundTags) {\n    TonalSoundTags[\"initial\"] = \"initial\";\n    TonalSoundTags[\"medial\"] = \"medial\";\n    TonalSoundTags[\"nasalization\"] = \"nasalization\";\n    TonalSoundTags[\"final\"] = \"final\";\n    TonalSoundTags[\"tonal\"] = \"tonal\";\n    TonalSoundTags[\"stopFinal\"] = \"stopFinal\";\n    TonalSoundTags[\"nasalFinal\"] = \"nasalFinal\";\n    TonalSoundTags[\"checkedTonal\"] = \"checkedTonal\";\n    TonalSoundTags[\"freeTonal\"] = \"freeTonal\";\n})(TonalSoundTags = exports.TonalSoundTags || (exports.TonalSoundTags = {}));\nclass Initial extends grapheme_1.Sound {\n    constructor() {\n        super(...arguments);\n        this.name = TonalSoundTags.initial;\n    }\n}\nexports.Initial = Initial;\nclass Medial extends grapheme_1.Sound {\n    constructor() {\n        super(...arguments);\n        this.name = TonalSoundTags.medial;\n    }\n}\nexports.Medial = Medial;\nclass Final extends grapheme_1.Sound {\n    constructor() {\n        super(...arguments);\n        this.name = TonalSoundTags.final;\n    }\n}\nexports.Final = Final;\nclass Nasalization extends grapheme_1.Sound {\n    constructor() {\n        super(...arguments);\n        this.name = TonalSoundTags.nasalization;\n    }\n}\nexports.Nasalization = Nasalization;\nclass Tonal extends grapheme_1.Sound {\n    constructor() {\n        super(...arguments);\n        this.name = TonalSoundTags.tonal;\n    }\n    isEqualToTonal(tonal) {\n        if (this.toString() === tonal.toString()) {\n            return true;\n        }\n        return false;\n    }\n}\nexports.Tonal = Tonal;\nclass FreeTonal extends Tonal {\n    constructor() {\n        super(...arguments);\n        this.name = TonalSoundTags.freeTonal;\n    }\n}\nexports.FreeTonal = FreeTonal;\nclass CheckedTonal extends Tonal {\n    constructor() {\n        super(...arguments);\n        this.name = TonalSoundTags.checkedTonal;\n    }\n}\nexports.CheckedTonal = CheckedTonal;\nclass StopFinal extends Final {\n    constructor() {\n        super(...arguments);\n        this.name = TonalSoundTags.stopFinal;\n    }\n}\nexports.StopFinal = StopFinal;\nclass NasalFinal extends Final {\n    constructor() {\n        super(...arguments);\n        this.name = TonalSoundTags.nasalFinal;\n    }\n}\nexports.NasalFinal = NasalFinal;\nclass MedialA extends Medial {\n    constructor() {\n        super(...arguments);\n        this.characters = this.makeCharacters(TonalLetterTags.a);\n    }\n}\nclass MedialE extends Medial {\n    constructor() {\n        super(...arguments);\n        this.characters = this.makeCharacters(TonalLetterTags.e);\n    }\n}\nclass MedialI extends Medial {\n    constructor() {\n        super(...arguments);\n        this.characters = this.makeCharacters(TonalLetterTags.i);\n    }\n}\nclass MedialO extends Medial {\n    constructor() {\n        super(...arguments);\n        this.characters = this.makeCharacters(TonalLetterTags.o);\n    }\n}\nclass MedialU extends Medial {\n    constructor() {\n        super(...arguments);\n        this.characters = this.makeCharacters(TonalLetterTags.u);\n    }\n}\nclass MedialUR extends Medial {\n    constructor() {\n        super(...arguments);\n        this.characters = this.makeCharacters(TonalLetterTags.ur);\n    }\n}\nclass MedialER extends Medial {\n    constructor() {\n        super(...arguments);\n        this.characters = this.makeCharacters(TonalLetterTags.er);\n    }\n}\nclass MedialIR extends Medial {\n    constructor() {\n        super(...arguments);\n        this.characters = this.makeCharacters(TonalLetterTags.ir);\n    }\n}\nclass MedialOR extends Medial {\n    constructor() {\n        super(...arguments);\n        this.characters = this.makeCharacters(TonalLetterTags.or);\n    }\n}\nclass MaterLectionisM extends Medial {\n    constructor() {\n        super(...arguments);\n        this.characters = this.makeCharacters(TonalLetterTags.m);\n    }\n}\nclass MaterLectionisN extends Medial {\n    constructor() {\n        super(...arguments);\n        this.characters = this.makeCharacters(TonalLetterTags.n);\n    }\n}\nclass MaterLectionisNG extends Medial {\n    constructor() {\n        super(...arguments);\n        this.characters = this.makeCharacters(TonalLetterTags.ng);\n    }\n}\nclass InitialC extends Initial {\n    constructor() {\n        super(...arguments);\n        this.characters = this.makeCharacters(TonalLetterTags.c);\n    }\n}\nclass InitialCH extends Initial {\n    constructor() {\n        super(...arguments);\n        this.characters = this.makeCharacters(TonalLetterTags.ch);\n    }\n}\nclass InitialJ extends Initial {\n    constructor() {\n        super(...arguments);\n        this.characters = this.makeCharacters(TonalLetterTags.j);\n    }\n}\nclass InitialL extends Initial {\n    constructor() {\n        super(...arguments);\n        this.characters = this.makeCharacters(TonalLetterTags.l);\n    }\n}\nclass InitialQ extends Initial {\n    constructor() {\n        super(...arguments);\n        this.characters = this.makeCharacters(TonalLetterTags.q);\n    }\n}\nclass InitialS extends Initial {\n    constructor() {\n        super(...arguments);\n        this.characters = this.makeCharacters(TonalLetterTags.s);\n    }\n}\nclass InitialV extends Initial {\n    constructor() {\n        super(...arguments);\n        this.characters = this.makeCharacters(TonalLetterTags.v);\n    }\n}\nclass InitialH extends Initial {\n    constructor() {\n        super(...arguments);\n        this.characters = this.makeCharacters(TonalLetterTags.h);\n    }\n}\nclass InitialP extends Initial {\n    constructor() {\n        super(...arguments);\n        this.characters = this.makeCharacters(TonalLetterTags.p);\n    }\n}\nclass InitialT extends Initial {\n    constructor() {\n        super(...arguments);\n        this.characters = this.makeCharacters(TonalLetterTags.t);\n    }\n}\nclass InitialK extends Initial {\n    constructor() {\n        super(...arguments);\n        this.characters = this.makeCharacters(TonalLetterTags.k);\n    }\n}\nclass InitialB extends Initial {\n    constructor() {\n        super(...arguments);\n        this.characters = this.makeCharacters(TonalLetterTags.b);\n    }\n}\nclass InitialD extends Initial {\n    constructor() {\n        super(...arguments);\n        this.characters = this.makeCharacters(TonalLetterTags.d);\n    }\n}\nclass InitialG extends Initial {\n    constructor() {\n        super(...arguments);\n        this.characters = this.makeCharacters(TonalLetterTags.g);\n    }\n}\nclass InitialM extends Initial {\n    constructor() {\n        super(...arguments);\n        this.characters = this.makeCharacters(TonalLetterTags.m);\n    }\n}\nclass InitialN extends Initial {\n    constructor() {\n        super(...arguments);\n        this.characters = this.makeCharacters(TonalLetterTags.n);\n    }\n}\nclass InitialNG extends Initial {\n    constructor() {\n        super(...arguments);\n        this.characters = this.makeCharacters(TonalLetterTags.ng);\n    }\n}\nclass ZeroTonal extends Tonal {\n    constructor() {\n        super(...arguments);\n        this.characters = [];\n    }\n}\nexports.ZeroTonal = ZeroTonal;\nclass FreeTonalZ extends FreeTonal {\n    constructor() {\n        super(...arguments);\n        this.characters = this.makeCharacters(TonalLetterTags.z);\n    }\n}\nexports.FreeTonalZ = FreeTonalZ;\nclass FreeTonalW extends FreeTonal {\n    constructor() {\n        super(...arguments);\n        this.characters = this.makeCharacters(TonalLetterTags.w);\n    }\n}\nexports.FreeTonalW = FreeTonalW;\nclass FreeTonalF extends FreeTonal {\n    constructor() {\n        super(...arguments);\n        this.characters = this.makeCharacters(TonalLetterTags.f);\n    }\n}\nexports.FreeTonalF = FreeTonalF;\nclass FreeTonalXX extends FreeTonal {\n    constructor() {\n        super(...arguments);\n        this.characters = this.makeCharacters(TonalLetterTags.xx);\n    }\n}\nexports.FreeTonalXX = FreeTonalXX;\nclass FreeTonalXXX extends FreeTonal {\n    constructor() {\n        super(...arguments);\n        this.characters = this.makeCharacters(TonalLetterTags.xxx);\n    }\n}\nexports.FreeTonalXXX = FreeTonalXXX;\nclass FreeTonalZX extends FreeTonal {\n    constructor() {\n        super(...arguments);\n        this.characters = this.makeCharacters(TonalLetterTags.zx);\n    }\n}\nexports.FreeTonalZX = FreeTonalZX;\nclass FreeTonalX extends FreeTonal {\n    constructor() {\n        super(...arguments);\n        this.characters = this.makeCharacters(TonalLetterTags.x);\n    }\n}\nexports.FreeTonalX = FreeTonalX;\nclass FreeTonalY extends FreeTonal {\n    constructor() {\n        super(...arguments);\n        this.characters = this.makeCharacters(TonalLetterTags.y);\n    }\n}\nexports.FreeTonalY = FreeTonalY;\nclass CheckedTonalW extends CheckedTonal {\n    constructor() {\n        super(...arguments);\n        this.characters = this.makeCharacters(TonalLetterTags.w);\n    }\n}\nexports.CheckedTonalW = CheckedTonalW;\nclass CheckedTonalF extends CheckedTonal {\n    constructor() {\n        super(...arguments);\n        this.characters = this.makeCharacters(TonalLetterTags.f);\n    }\n}\nexports.CheckedTonalF = CheckedTonalF;\nclass CheckedTonalX extends CheckedTonal {\n    constructor() {\n        super(...arguments);\n        this.characters = this.makeCharacters(TonalLetterTags.x);\n    }\n}\nexports.CheckedTonalX = CheckedTonalX;\nclass CheckedTonalY extends CheckedTonal {\n    constructor() {\n        super(...arguments);\n        this.characters = this.makeCharacters(TonalLetterTags.y);\n    }\n}\nexports.CheckedTonalY = CheckedTonalY;\nclass FinalP extends StopFinal {\n    constructor() {\n        super(...arguments);\n        this.characters = this.makeCharacters(TonalLetterTags.p);\n    }\n}\nexports.FinalP = FinalP;\nclass FinalT extends StopFinal {\n    constructor() {\n        super(...arguments);\n        this.characters = this.makeCharacters(TonalLetterTags.t);\n    }\n}\nexports.FinalT = FinalT;\nclass FinalK extends StopFinal {\n    constructor() {\n        super(...arguments);\n        this.characters = this.makeCharacters(TonalLetterTags.k);\n    }\n}\nexports.FinalK = FinalK;\nclass FinalH extends StopFinal {\n    constructor() {\n        super(...arguments);\n        this.characters = this.makeCharacters(TonalLetterTags.h);\n    }\n}\nexports.FinalH = FinalH;\nclass FinalPP extends StopFinal {\n    constructor() {\n        super(...arguments);\n        this.characters = this.makeCharacters(TonalLetterTags.pp);\n    }\n}\nexports.FinalPP = FinalPP;\nclass FinalTT extends StopFinal {\n    constructor() {\n        super(...arguments);\n        this.characters = this.makeCharacters(TonalLetterTags.tt);\n    }\n}\nexports.FinalTT = FinalTT;\nclass FinalKK extends StopFinal {\n    constructor() {\n        super(...arguments);\n        this.characters = this.makeCharacters(TonalLetterTags.kk);\n    }\n}\nexports.FinalKK = FinalKK;\nclass FinalHH extends StopFinal {\n    constructor() {\n        super(...arguments);\n        this.characters = this.makeCharacters(TonalLetterTags.hh);\n    }\n}\nexports.FinalHH = FinalHH;\nclass FinalB extends StopFinal {\n    constructor() {\n        super(...arguments);\n        this.characters = this.makeCharacters(TonalLetterTags.b);\n    }\n}\nclass FinalL extends StopFinal {\n    constructor() {\n        super(...arguments);\n        this.characters = this.makeCharacters(TonalLetterTags.l);\n    }\n}\nclass FinalG extends StopFinal {\n    constructor() {\n        super(...arguments);\n        this.characters = this.makeCharacters(TonalLetterTags.g);\n    }\n}\nclass FinalJ extends StopFinal {\n    constructor() {\n        super(...arguments);\n        this.characters = this.makeCharacters(TonalLetterTags.j);\n    }\n}\nclass FinalS extends StopFinal {\n    constructor() {\n        super(...arguments);\n        this.characters = this.makeCharacters(TonalLetterTags.s);\n    }\n}\nclass FinalBB extends StopFinal {\n    constructor() {\n        super(...arguments);\n        this.characters = this.makeCharacters(TonalLetterTags.bb);\n    }\n}\nclass FinalLL extends StopFinal {\n    constructor() {\n        super(...arguments);\n        this.characters = this.makeCharacters(TonalLetterTags.ll);\n    }\n}\nclass FinalGG extends StopFinal {\n    constructor() {\n        super(...arguments);\n        this.characters = this.makeCharacters(TonalLetterTags.gg);\n    }\n}\nclass FinalJJ extends StopFinal {\n    constructor() {\n        super(...arguments);\n        this.characters = this.makeCharacters(TonalLetterTags.jj);\n    }\n}\nclass FinalSS extends StopFinal {\n    constructor() {\n        super(...arguments);\n        this.characters = this.makeCharacters(TonalLetterTags.ss);\n    }\n}\nclass FinalM extends NasalFinal {\n    constructor() {\n        super(...arguments);\n        this.characters = this.makeCharacters(TonalLetterTags.m);\n    }\n}\nclass FinalN extends NasalFinal {\n    constructor() {\n        super(...arguments);\n        this.characters = this.makeCharacters(TonalLetterTags.n);\n    }\n}\nclass FinalNG extends NasalFinal {\n    constructor() {\n        super(...arguments);\n        this.characters = this.makeCharacters(TonalLetterTags.ng);\n    }\n}\nclass NasalizationNN extends Nasalization {\n    constructor() {\n        super(...arguments);\n        this.characters = this.makeCharacters(TonalLetterTags.nn);\n    }\n}\nclass NasalizationSound extends grapheme_1.SetOfSounds {\n    constructor() {\n        super();\n        this.sounds.push(new NasalizationNN());\n    }\n}\nexports.NasalizationSound = NasalizationSound;\nclass NasalFinalSounds extends grapheme_1.SetOfSounds {\n    constructor() {\n        super();\n        this.sounds.push(new FinalM());\n        this.sounds.push(new FinalN());\n        this.sounds.push(new FinalNG());\n    }\n}\nexports.NasalFinalSounds = NasalFinalSounds;\nclass NasalInitialSounds extends grapheme_1.SetOfSounds {\n    constructor() {\n        super();\n        this.sounds.push(new InitialM());\n        this.sounds.push(new InitialN());\n        this.sounds.push(new InitialNG());\n    }\n}\nexports.NasalInitialSounds = NasalInitialSounds;\nclass NeutralFinalSounds extends grapheme_1.SetOfSounds {\n    constructor() {\n        super();\n        this.sounds.push(new FinalH());\n        this.sounds.push(new FinalHH());\n    }\n}\nexports.NeutralFinalSounds = NeutralFinalSounds;\nclass MedialSounds extends grapheme_1.SetOfSounds {\n    constructor() {\n        super();\n        this.sounds.push(new MedialA());\n        this.sounds.push(new MedialE());\n        this.sounds.push(new MedialI());\n        this.sounds.push(new MedialO());\n        this.sounds.push(new MedialU());\n        this.sounds.push(new MedialUR());\n    }\n}\nexports.MedialSounds = MedialSounds;\nclass MaterLectionisSounds extends grapheme_1.SetOfSounds {\n    constructor() {\n        super();\n        this.sounds.push(new MaterLectionisM());\n        this.sounds.push(new MaterLectionisN());\n        this.sounds.push(new MaterLectionisNG());\n    }\n}\nexports.MaterLectionisSounds = MaterLectionisSounds;\nclass InitialSounds extends grapheme_1.SetOfSounds {\n    constructor() {\n        super();\n        this.sounds.push(new InitialP());\n        this.sounds.push(new InitialT());\n        this.sounds.push(new InitialK());\n        this.sounds.push(new InitialB());\n        this.sounds.push(new InitialD());\n        this.sounds.push(new InitialG());\n        this.sounds.push(new InitialH());\n        this.sounds.push(new InitialC());\n        this.sounds.push(new InitialCH());\n        this.sounds.push(new InitialJ());\n        this.sounds.push(new InitialL());\n        this.sounds.push(new InitialQ());\n        this.sounds.push(new InitialS());\n        this.sounds.push(new InitialV());\n        this.sounds.push(new InitialM());\n        this.sounds.push(new InitialN());\n        this.sounds.push(new InitialNG());\n    }\n}\nexports.InitialSounds = InitialSounds;\nclass FreeTonalSounds extends grapheme_1.SetOfSounds {\n    constructor() {\n        super();\n        this.sounds.push(new FreeTonalZ());\n        this.sounds.push(new FreeTonalW());\n        this.sounds.push(new FreeTonalXX());\n        this.sounds.push(new FreeTonalXXX());\n        this.sounds.push(new FreeTonalF());\n        this.sounds.push(new FreeTonalZX());\n        this.sounds.push(new FreeTonalX());\n        this.sounds.push(new FreeTonalY());\n    }\n}\nexports.FreeTonalSounds = FreeTonalSounds;\nclass CheckedTonalSounds extends grapheme_1.SetOfSounds {\n    constructor() {\n        super();\n        this.sounds.push(new CheckedTonalF());\n        this.sounds.push(new CheckedTonalY());\n        this.sounds.push(new CheckedTonalW());\n        this.sounds.push(new CheckedTonalX());\n    }\n}\nexports.CheckedTonalSounds = CheckedTonalSounds;\nclass FinalSounds extends grapheme_1.SetOfSounds {\n    constructor() {\n        super();\n        this.sounds.push(new FinalP());\n        this.sounds.push(new FinalT());\n        this.sounds.push(new FinalK());\n        this.sounds.push(new FinalH());\n        this.sounds.push(new FinalPP());\n        this.sounds.push(new FinalTT());\n        this.sounds.push(new FinalKK());\n        this.sounds.push(new FinalHH());\n        this.sounds.push(new FinalM());\n        this.sounds.push(new FinalN());\n        this.sounds.push(new FinalNG());\n    }\n}\nexports.FinalSounds = FinalSounds;\nclass StopFinalSounds extends grapheme_1.SetOfSounds {\n    constructor() {\n        super();\n        this.sounds.push(new FinalP());\n        this.sounds.push(new FinalT());\n        this.sounds.push(new FinalK());\n        this.sounds.push(new FinalH());\n        this.sounds.push(new FinalPP());\n        this.sounds.push(new FinalTT());\n        this.sounds.push(new FinalKK());\n        this.sounds.push(new FinalHH());\n    }\n}\nexports.StopFinalSounds = StopFinalSounds;\nclass EpenthesisSounds extends grapheme_1.SetOfSounds {\n    constructor() {\n        super();\n        this.sounds.push(new InitialB());\n        this.sounds.push(new InitialL());\n        this.sounds.push(new InitialG());\n        this.sounds.push(new InitialM());\n        this.sounds.push(new InitialN());\n    }\n}\nexports.EpenthesisSounds = EpenthesisSounds;\nclass EuphonicFinalsJLS extends grapheme_1.SetOfSounds {\n    constructor() {\n        super();\n        this.sounds.push(new FinalJ());\n        this.sounds.push(new FinalL());\n        this.sounds.push(new FinalS());\n    }\n}\nexports.EuphonicFinalsJLS = EuphonicFinalsJLS;\nclass EuphonicFinalsBGKP extends grapheme_1.SetOfSounds {\n    constructor() {\n        super();\n        this.sounds.push(new FinalB());\n        this.sounds.push(new FinalG());\n        this.sounds.push(new FinalK());\n        this.sounds.push(new FinalP());\n    }\n}\nexports.EuphonicFinalsBGKP = EuphonicFinalsBGKP;\nclass EuphonicFinalsBGJKLPS extends grapheme_1.SetOfSounds {\n    constructor() {\n        super();\n        this.sounds.push(new FinalB());\n        this.sounds.push(new FinalG());\n        this.sounds.push(new FinalJ());\n        this.sounds.push(new FinalK());\n        this.sounds.push(new FinalL());\n        this.sounds.push(new FinalP());\n        this.sounds.push(new FinalS());\n    }\n}\nexports.EuphonicFinalsBGJKLPS = EuphonicFinalsBGJKLPS;\nclass EuphonicFinalsJJLLSS extends grapheme_1.SetOfSounds {\n    constructor() {\n        super();\n        this.sounds.push(new FinalJJ());\n        this.sounds.push(new FinalLL());\n        this.sounds.push(new FinalSS());\n    }\n}\nexports.EuphonicFinalsJJLLSS = EuphonicFinalsJJLLSS;\nclass EuphonicFinalsBBGGKKPP extends grapheme_1.SetOfSounds {\n    constructor() {\n        super();\n        this.sounds.push(new FinalBB());\n        this.sounds.push(new FinalGG());\n        this.sounds.push(new FinalKK());\n        this.sounds.push(new FinalPP());\n    }\n}\nexports.EuphonicFinalsBBGGKKPP = EuphonicFinalsBBGGKKPP;\nclass EuphonicFinalsBBGGJJKKLLPPSS extends grapheme_1.SetOfSounds {\n    constructor() {\n        super();\n        this.sounds.push(new FinalBB());\n        this.sounds.push(new FinalGG());\n        this.sounds.push(new FinalJJ());\n        this.sounds.push(new FinalKK());\n        this.sounds.push(new FinalLL());\n        this.sounds.push(new FinalPP());\n        this.sounds.push(new FinalSS());\n    }\n}\nexports.EuphonicFinalsBBGGJJKKLLPPSS = EuphonicFinalsBBGGJJKKLLPPSS;\nclass FirstTonalF extends grapheme_1.SetOfSounds {\n    constructor() {\n        super();\n        this.sounds.push(new CheckedTonalF());\n    }\n}\nexports.FirstTonalF = FirstTonalF;\nclass ThirdFifthTonalsWX extends grapheme_1.SetOfSounds {\n    constructor() {\n        super();\n        this.sounds.push(new CheckedTonalW());\n        this.sounds.push(new CheckedTonalX());\n    }\n}\nexports.ThirdFifthTonalsWX = ThirdFifthTonalsWX;\nclass NeutralFinalH extends grapheme_1.SetOfSounds {\n    constructor() {\n        super();\n        this.sounds.push(new FinalH());\n    }\n}\nexports.NeutralFinalH = NeutralFinalH;\nclass NeutralFinalHH extends grapheme_1.SetOfSounds {\n    constructor() {\n        super();\n        this.sounds.push(new FinalHH());\n    }\n}\nexports.NeutralFinalHH = NeutralFinalHH;\nclass InitialsForEuphonicT extends grapheme_1.SetOfSounds {\n    constructor() {\n        super();\n        this.sounds.push(new InitialP());\n        this.sounds.push(new InitialK());\n        this.sounds.push(new InitialB());\n        this.sounds.push(new InitialG());\n        this.sounds.push(new InitialJ());\n        this.sounds.push(new InitialQ());\n        this.sounds.push(new InitialS());\n        this.sounds.push(new InitialV());\n        this.sounds.push(new InitialM());\n        this.sounds.push(new InitialN());\n        this.sounds.push(new InitialNG());\n    }\n}\nexports.InitialsForEuphonicT = InitialsForEuphonicT;\nclass InitialsForEuphonicTT extends grapheme_1.SetOfSounds {\n    constructor() {\n        super();\n        this.sounds.push(new InitialP());\n        this.sounds.push(new InitialK());\n        this.sounds.push(new InitialG());\n        this.sounds.push(new InitialQ());\n        this.sounds.push(new InitialS());\n        this.sounds.push(new InitialV());\n        this.sounds.push(new InitialM());\n        this.sounds.push(new InitialN());\n        this.sounds.push(new InitialNG());\n    }\n}\nexports.InitialsForEuphonicTT = InitialsForEuphonicTT;\n//------------------------------------------------------------------------------\nfunction positionalSound(sounds) {\n    return (t) => {\n        for (let i in sounds) {\n            if (sounds[i].name === t)\n                return sounds[i];\n        }\n        return new grapheme_1.Sound();\n    };\n}\nexports.positionalSound = positionalSound;\nconst ps_a = positionalSound([new MedialA()]);\nconst ps_b = positionalSound([new InitialB(), new FinalB()]);\nconst ps_bb = positionalSound([new FinalBB()]);\nconst ps_c = positionalSound([new InitialC()]);\nconst ps_ch = positionalSound([new InitialCH()]);\nconst ps_d = positionalSound([new InitialD()]);\nconst ps_e = positionalSound([new MedialE()]);\nconst ps_er = positionalSound([new MedialER()]);\nconst ps_f = positionalSound([new FreeTonalF(), new CheckedTonalF()]);\nconst ps_g = positionalSound([new InitialG(), new FinalG()]);\nconst ps_gg = positionalSound([new FinalGG()]);\nconst ps_h = positionalSound([new InitialH(), new FinalH()]);\nconst ps_hh = positionalSound([new FinalHH()]);\nconst ps_i = positionalSound([new MedialI()]);\nconst ps_ir = positionalSound([new MedialIR()]);\nconst ps_j = positionalSound([new InitialJ(), new FinalJ()]);\nconst ps_jj = positionalSound([new FinalJJ()]);\nconst ps_k = positionalSound([new InitialK(), new FinalK()]);\nconst ps_kk = positionalSound([new FinalKK()]);\nconst ps_l = positionalSound([new InitialL(), new FinalL()]);\nconst ps_ll = positionalSound([new FinalLL()]);\nconst ps_m = positionalSound([new InitialM(), new MaterLectionisM(), new FinalM()]);\nconst ps_n = positionalSound([new InitialN(), new MaterLectionisN(), new FinalN()]);\nconst ps_nn = positionalSound([new NasalizationNN()]);\nconst ps_ng = positionalSound([new InitialNG(), new MaterLectionisNG(), new FinalNG()]);\nconst ps_o = positionalSound([new MedialO()]);\nconst ps_or = positionalSound([new MedialOR()]);\nconst ps_p = positionalSound([new InitialP(), new FinalP()]);\nconst ps_pp = positionalSound([new FinalPP()]);\nconst ps_q = positionalSound([new InitialQ()]);\nconst ps_s = positionalSound([new InitialS(), new FinalS()]);\nconst ps_ss = positionalSound([new FinalSS()]);\nconst ps_t = positionalSound([new InitialT(), new FinalT()]);\nconst ps_tt = positionalSound([new FinalTT()]);\nconst ps_u = positionalSound([new MedialU()]);\nconst ps_ur = positionalSound([new MedialUR()]);\nconst ps_v = positionalSound([new InitialV()]);\nconst ps_w = positionalSound([new FreeTonalW(), new CheckedTonalW()]);\nconst ps_x = positionalSound([new FreeTonalX(), new CheckedTonalX()]);\nconst ps_xx = positionalSound([new FreeTonalXX()]);\nconst ps_xxx = positionalSound([new FreeTonalXXX()]);\nconst ps_y = positionalSound([new FreeTonalY(), new CheckedTonalY()]);\nconst ps_z = positionalSound([new FreeTonalZ()]);\nconst ps_zx = positionalSound([new FreeTonalZX()]);\nconst ps_zero = positionalSound([new ZeroTonal()]);\n//------------------------------------------------------------------------------\nclass CombiningRules {\n    constructor() {\n        this.o = new Map();\n        this.o\n            .set(TonalLetterTags.zero, { z: ps_z(TonalSoundTags.freeTonal) })\n            .set(TonalLetterTags.y, {\n            zero: ps_zero(TonalSoundTags.freeTonal),\n            f: ps_f(TonalSoundTags.freeTonal),\n        })\n            .set(TonalLetterTags.w, { y: ps_y(TonalSoundTags.freeTonal) })\n            .set(TonalLetterTags.x, {\n            z: ps_z(TonalSoundTags.freeTonal),\n            w: ps_w(TonalSoundTags.freeTonal),\n        })\n            .set(TonalLetterTags.z, { w: ps_w(TonalSoundTags.freeTonal) })\n            .set(TonalLetterTags.p, { f: ps_f(TonalSoundTags.checkedTonal) })\n            .set(TonalLetterTags.t, { f: ps_f(TonalSoundTags.checkedTonal) })\n            .set(TonalLetterTags.k, { f: ps_f(TonalSoundTags.checkedTonal) })\n            .set(TonalLetterTags.h, {\n            f: ps_f(TonalSoundTags.checkedTonal),\n            y: ps_y(TonalSoundTags.checkedTonal),\n        })\n            .set(TonalLetterTags.pp, {\n            w: ps_w(TonalSoundTags.checkedTonal),\n            x: ps_x(TonalSoundTags.checkedTonal),\n        })\n            .set(TonalLetterTags.tt, {\n            w: ps_w(TonalSoundTags.checkedTonal),\n            x: ps_x(TonalSoundTags.checkedTonal),\n        })\n            .set(TonalLetterTags.kk, {\n            w: ps_w(TonalSoundTags.checkedTonal),\n            x: ps_x(TonalSoundTags.checkedTonal),\n        })\n            .set(TonalLetterTags.hh, {\n            w: ps_w(TonalSoundTags.checkedTonal),\n            x: ps_x(TonalSoundTags.checkedTonal),\n        });\n    }\n    get(key) {\n        let value = this.o.get(key);\n        if (value) {\n            return value;\n        }\n        return {};\n    }\n}\nexports.combiningRules = new CombiningRules();\nexports.tonalPositionalSound = new Map()\n    .set(TonalLetterTags.a, ps_a)\n    .set(TonalLetterTags.b, ps_b)\n    .set(TonalLetterTags.bb, ps_bb)\n    .set(TonalLetterTags.c, ps_c)\n    .set(TonalLetterTags.ch, ps_ch)\n    .set(TonalLetterTags.d, ps_d)\n    .set(TonalLetterTags.e, ps_e)\n    .set(TonalLetterTags.er, ps_er)\n    .set(TonalLetterTags.f, ps_f)\n    .set(TonalLetterTags.g, ps_g)\n    .set(TonalLetterTags.gg, ps_gg)\n    .set(TonalLetterTags.h, ps_h)\n    .set(TonalLetterTags.hh, ps_hh)\n    .set(TonalLetterTags.i, ps_i)\n    .set(TonalLetterTags.ir, ps_ir)\n    .set(TonalLetterTags.j, ps_j)\n    .set(TonalLetterTags.jj, ps_jj)\n    .set(TonalLetterTags.k, ps_k)\n    .set(TonalLetterTags.kk, ps_kk)\n    .set(TonalLetterTags.l, ps_l)\n    .set(TonalLetterTags.ll, ps_ll)\n    .set(TonalLetterTags.m, ps_m)\n    .set(TonalLetterTags.n, ps_n)\n    .set(TonalLetterTags.nn, ps_nn)\n    .set(TonalLetterTags.ng, ps_ng)\n    .set(TonalLetterTags.o, ps_o)\n    .set(TonalLetterTags.or, ps_or)\n    .set(TonalLetterTags.p, ps_p)\n    .set(TonalLetterTags.pp, ps_pp)\n    .set(TonalLetterTags.q, ps_q)\n    .set(TonalLetterTags.s, ps_s)\n    .set(TonalLetterTags.ss, ps_ss)\n    .set(TonalLetterTags.t, ps_t)\n    .set(TonalLetterTags.tt, ps_tt)\n    .set(TonalLetterTags.u, ps_u)\n    .set(TonalLetterTags.ur, ps_ur)\n    .set(TonalLetterTags.v, ps_v)\n    .set(TonalLetterTags.w, ps_w)\n    .set(TonalLetterTags.x, ps_x)\n    .set(TonalLetterTags.xx, ps_xx)\n    .set(TonalLetterTags.xxx, ps_xxx)\n    .set(TonalLetterTags.y, ps_y)\n    .set(TonalLetterTags.z, ps_z)\n    .set(TonalLetterTags.zx, ps_zx);\n//------------------------------------------------------------------------------\nclass ZeroAllomorph extends FreeAllomorph {\n    constructor() {\n        super(...arguments);\n        this.tonal = new ZeroTonal();\n    }\n}\nexports.ZeroAllomorph = ZeroAllomorph;\nclass AllomorphF extends FreeAllomorph {\n    constructor() {\n        super(...arguments);\n        this.tonal = new FreeTonalF();\n    }\n}\nclass AllomorphZ extends FreeAllomorph {\n    constructor() {\n        super(...arguments);\n        this.tonal = new FreeTonalZ();\n    }\n}\nexports.AllomorphZ = AllomorphZ;\nclass AllomorphY extends FreeAllomorph {\n    constructor() {\n        super(...arguments);\n        this.tonal = new FreeTonalY();\n    }\n}\nexports.AllomorphY = AllomorphY;\nclass AllomorphW extends FreeAllomorph {\n    constructor() {\n        super(...arguments);\n        this.tonal = new FreeTonalW();\n    }\n}\nexports.AllomorphW = AllomorphW;\nclass AllomorphX extends FreeAllomorph {\n    constructor() {\n        super(...arguments);\n        this.tonal = new FreeTonalX();\n    }\n}\nexports.AllomorphX = AllomorphX;\nclass AllomorphXX extends FreeAllomorph {\n    constructor() {\n        super(...arguments);\n        this.tonal = new FreeTonalXX();\n    }\n}\nclass AllomorphXXX extends FreeAllomorph {\n    constructor() {\n        super(...arguments);\n        this.tonal = new FreeTonalXXX();\n    }\n}\nclass AllomorphZX extends FreeAllomorph {\n    constructor() {\n        super(...arguments);\n        this.tonal = new FreeTonalZX();\n    }\n}\nclass FreeAllomorphs {\n    constructor() {\n        this.o = new Map();\n        this.o\n            .set(TonalLetterTags.f, new AllomorphF())\n            .set(TonalLetterTags.w, new AllomorphW())\n            .set(TonalLetterTags.xx, new AllomorphXX())\n            .set(TonalLetterTags.xxx, new AllomorphXXX())\n            .set(TonalLetterTags.z, new AllomorphZ())\n            .set(TonalLetterTags.zx, new AllomorphZX())\n            .set(TonalLetterTags.y, new AllomorphY())\n            .set(TonalLetterTags.x, new AllomorphX());\n    }\n    get(key) {\n        let value = this.o.get(key);\n        if (value) {\n            return value;\n        }\n        return new Allomorph();\n    }\n    has(key) {\n        return this.o.has(key);\n    }\n}\nexports.freeAllomorphs = new FreeAllomorphs();\nclass AllomorphP extends CheckedAllomorph {\n    constructor() {\n        super(...arguments);\n        this.final = new FinalP();\n    }\n}\nclass AllomorphT extends CheckedAllomorph {\n    constructor() {\n        super(...arguments);\n        this.final = new FinalT();\n    }\n}\nclass AllomorphK extends CheckedAllomorph {\n    constructor() {\n        super(...arguments);\n        this.final = new FinalK();\n    }\n}\nclass AllomorphH extends CheckedAllomorph {\n    constructor() {\n        super(...arguments);\n        this.final = new FinalH();\n    }\n}\nexports.AllomorphH = AllomorphH;\nclass AllomorphPP extends CheckedAllomorph {\n    constructor() {\n        super(...arguments);\n        this.final = new FinalPP();\n    }\n}\nclass AllomorphTT extends CheckedAllomorph {\n    constructor() {\n        super(...arguments);\n        this.final = new FinalTT();\n    }\n}\nclass AllomorphKK extends CheckedAllomorph {\n    constructor() {\n        super(...arguments);\n        this.final = new FinalKK();\n    }\n}\nclass AllomorphHH extends CheckedAllomorph {\n    constructor() {\n        super(...arguments);\n        this.final = new FinalHH();\n    }\n}\nclass AllomorphPF extends CheckedAllomorph {\n    constructor() {\n        super(...arguments);\n        this.final = new FinalP();\n        this.tonal = new CheckedTonalF();\n    }\n}\nclass AllomorphTF extends CheckedAllomorph {\n    constructor() {\n        super(...arguments);\n        this.final = new FinalT();\n        this.tonal = new CheckedTonalF();\n    }\n}\nclass AllomorphKF extends CheckedAllomorph {\n    constructor() {\n        super(...arguments);\n        this.final = new FinalK();\n        this.tonal = new CheckedTonalF();\n    }\n}\nclass AllomorphHF extends CheckedAllomorph {\n    constructor() {\n        super(...arguments);\n        this.final = new FinalH();\n        this.tonal = new CheckedTonalF();\n    }\n}\nclass AllomorphHY extends CheckedAllomorph {\n    constructor() {\n        super(...arguments);\n        this.final = new FinalH();\n        this.tonal = new CheckedTonalY();\n    }\n}\nexports.AllomorphHY = AllomorphHY;\nclass AllomorphPPW extends CheckedAllomorph {\n    constructor() {\n        super(...arguments);\n        this.final = new FinalPP();\n        this.tonal = new CheckedTonalW();\n    }\n}\nclass AllomorphTTW extends CheckedAllomorph {\n    constructor() {\n        super(...arguments);\n        this.final = new FinalTT();\n        this.tonal = new CheckedTonalW();\n    }\n}\nclass AllomorphKKW extends CheckedAllomorph {\n    constructor() {\n        super(...arguments);\n        this.final = new FinalKK();\n        this.tonal = new CheckedTonalW();\n    }\n}\nclass AllomorphHHW extends CheckedAllomorph {\n    constructor() {\n        super(...arguments);\n        this.final = new FinalHH();\n        this.tonal = new CheckedTonalW();\n    }\n}\nclass AllomorphPPX extends CheckedAllomorph {\n    constructor() {\n        super(...arguments);\n        this.final = new FinalPP();\n        this.tonal = new CheckedTonalX();\n    }\n}\nclass AllomorphTTX extends CheckedAllomorph {\n    constructor() {\n        super(...arguments);\n        this.final = new FinalTT();\n        this.tonal = new CheckedTonalX();\n    }\n}\nclass AllomorphKKX extends CheckedAllomorph {\n    constructor() {\n        super(...arguments);\n        this.final = new FinalKK();\n        this.tonal = new CheckedTonalX();\n    }\n}\nclass AllomorphHHX extends CheckedAllomorph {\n    constructor() {\n        super(...arguments);\n        this.final = new FinalHH();\n        this.tonal = new CheckedTonalX();\n    }\n}\nclass CheckedAllomorphs {\n    constructor() {\n        this.o = new Map();\n        this.o\n            .set(ps_p(TonalSoundTags.stopFinal).toString(), new AllomorphP())\n            .set(ps_t(TonalSoundTags.stopFinal).toString(), new AllomorphT())\n            .set(ps_k(TonalSoundTags.stopFinal).toString(), new AllomorphK())\n            .set(ps_h(TonalSoundTags.stopFinal).toString(), new AllomorphH())\n            .set(ps_pp(TonalSoundTags.stopFinal).toString(), new AllomorphPP())\n            .set(ps_tt(TonalSoundTags.stopFinal).toString(), new AllomorphTT())\n            .set(ps_kk(TonalSoundTags.stopFinal).toString(), new AllomorphKK())\n            .set(ps_hh(TonalSoundTags.stopFinal).toString(), new AllomorphHH())\n            .set(ps_p(TonalSoundTags.stopFinal).toString() + ps_f(TonalSoundTags.checkedTonal).toString(), new AllomorphPF())\n            .set(ps_t(TonalSoundTags.stopFinal).toString() + ps_f(TonalSoundTags.checkedTonal).toString(), new AllomorphTF())\n            .set(ps_k(TonalSoundTags.stopFinal).toString() + ps_f(TonalSoundTags.checkedTonal).toString(), new AllomorphKF())\n            .set(ps_h(TonalSoundTags.stopFinal).toString() + ps_f(TonalSoundTags.checkedTonal).toString(), new AllomorphHF())\n            .set(ps_pp(TonalSoundTags.stopFinal).toString() + ps_w(TonalSoundTags.checkedTonal).toString(), new AllomorphPPW())\n            .set(ps_tt(TonalSoundTags.stopFinal).toString() + ps_w(TonalSoundTags.checkedTonal).toString(), new AllomorphTTW())\n            .set(ps_kk(TonalSoundTags.stopFinal).toString() + ps_w(TonalSoundTags.checkedTonal).toString(), new AllomorphKKW())\n            .set(ps_hh(TonalSoundTags.stopFinal).toString() + ps_w(TonalSoundTags.checkedTonal).toString(), new AllomorphHHW())\n            .set(ps_h(TonalSoundTags.stopFinal).toString() + ps_y(TonalSoundTags.checkedTonal).toString(), new AllomorphHY())\n            .set(ps_pp(TonalSoundTags.stopFinal).toString() + ps_x(TonalSoundTags.checkedTonal).toString(), new AllomorphPPX())\n            .set(ps_tt(TonalSoundTags.stopFinal).toString() + ps_x(TonalSoundTags.checkedTonal).toString(), new AllomorphTTX())\n            .set(ps_kk(TonalSoundTags.stopFinal).toString() + ps_x(TonalSoundTags.checkedTonal).toString(), new AllomorphKKX())\n            .set(ps_hh(TonalSoundTags.stopFinal).toString() + ps_x(TonalSoundTags.checkedTonal).toString(), new AllomorphHHX());\n    }\n    get(key) {\n        let value = this.o.get(key);\n        if (value) {\n            return value;\n        }\n        return new Allomorph();\n    }\n    keys() {\n        return this.o.keys();\n    }\n}\nexports.checkedAllomorphs = new CheckedAllomorphs();\nclass CombinedFreeAllomorphs {\n    constructor() {\n        this.o = new Map();\n        this.o\n            .set(ps_w(TonalSoundTags.freeTonal).toString(), new AllomorphW())\n            .set(ps_z(TonalSoundTags.freeTonal).toString(), new AllomorphZ())\n            .set(ps_x(TonalSoundTags.freeTonal).toString(), new AllomorphX())\n            .set(ps_y(TonalSoundTags.freeTonal).toString(), new AllomorphY())\n            .set(ps_f(TonalSoundTags.freeTonal).toString(), new AllomorphF());\n    }\n    has(key) {\n        return this.o.has(key);\n    }\n    get(key) {\n        let value = this.o.get(key);\n        if (value) {\n            return value;\n        }\n        return new Allomorph();\n    }\n}\nexports.combinedFreeAllomorphs = new CombinedFreeAllomorphs();\nclass UncombinedCheckedAllomorphs {\n    constructor() {\n        this.o = new Map();\n        this.o\n            .set(ps_p(TonalSoundTags.stopFinal).toString(), new AllomorphP())\n            .set(ps_t(TonalSoundTags.stopFinal).toString(), new AllomorphT())\n            .set(ps_k(TonalSoundTags.stopFinal).toString(), new AllomorphK())\n            .set(ps_h(TonalSoundTags.stopFinal).toString(), new AllomorphH())\n            .set(ps_pp(TonalSoundTags.stopFinal).toString(), new AllomorphPP())\n            .set(ps_tt(TonalSoundTags.stopFinal).toString(), new AllomorphTT())\n            .set(ps_kk(TonalSoundTags.stopFinal).toString(), new AllomorphKK())\n            .set(ps_hh(TonalSoundTags.stopFinal).toString(), new AllomorphHH());\n    }\n    get(key) {\n        let value = this.o.get(key);\n        if (value) {\n            return value;\n        }\n        return new Allomorph();\n    }\n    has(key) {\n        return this.o.has(key);\n    }\n}\nexports.uncombinedCheckedAllomorphs = new UncombinedCheckedAllomorphs();\nclass CombinedCheckedAllomorphs {\n    constructor() {\n        this.o = new Map();\n        this.o\n            .set(ps_p(TonalSoundTags.stopFinal).toString(), [new AllomorphPF()])\n            .set(ps_t(TonalSoundTags.stopFinal).toString(), [new AllomorphTF()])\n            .set(ps_k(TonalSoundTags.stopFinal).toString(), [new AllomorphKF()])\n            .set(ps_h(TonalSoundTags.stopFinal).toString(), [new AllomorphHF(), new AllomorphHY()])\n            .set(ps_pp(TonalSoundTags.stopFinal).toString(), [new AllomorphPPW(), new AllomorphPPX()])\n            .set(ps_tt(TonalSoundTags.stopFinal).toString(), [new AllomorphTTW(), new AllomorphTTX()])\n            .set(ps_kk(TonalSoundTags.stopFinal).toString(), [new AllomorphKKW(), new AllomorphKKX()])\n            .set(ps_hh(TonalSoundTags.stopFinal).toString(), [new AllomorphHHW(), new AllomorphHHX()]);\n    }\n    get(key) {\n        let value = this.o.get(key);\n        if (value) {\n            return value;\n        }\n        return [];\n    }\n    has(key) {\n        return this.o.has(key);\n    }\n}\nexports.combinedCheckedAllomorphs = new CombinedCheckedAllomorphs();\nclass FreeAllomorphUncombiningRules {\n    constructor() {\n        this.o = new Map();\n        this.o\n            .set(ps_f(TonalSoundTags.freeTonal).toString(), [new FreeTonalY()])\n            .set(ps_w(TonalSoundTags.freeTonal).toString(), [new FreeTonalZ(), new FreeTonalX()])\n            .set(ps_xx(TonalSoundTags.freeTonal).toString(), [new FreeTonalZ(), new FreeTonalF(), new FreeTonalX()])\n            .set(ps_xxx(TonalSoundTags.freeTonal).toString(), [new FreeTonalZ(), new FreeTonalF(), new FreeTonalX()])\n            .set(ps_z(TonalSoundTags.freeTonal).toString(), [new FreeTonalX(), new FreeTonalF(), new ZeroTonal()])\n            .set(ps_zx(TonalSoundTags.freeTonal).toString(), [])\n            .set(ps_x(TonalSoundTags.freeTonal).toString(), [])\n            .set(ps_y(TonalSoundTags.freeTonal).toString(), [new FreeTonalW()])\n            .set(TonalLetterTags.zero, [new FreeTonalY()]);\n    }\n    get(key) {\n        let value = this.o.get(key);\n        if (value) {\n            return value;\n        }\n        return [];\n    }\n}\nexports.freeAllomorphUncombiningRules = new FreeAllomorphUncombiningRules();\nclass UncombiningRulesAy {\n    constructor() {\n        this.o = new Map();\n        this.o\n            .set(ps_f(TonalSoundTags.freeTonal).toString(), [new FreeTonalY(), new FreeTonalW()])\n            .set(ps_x(TonalSoundTags.freeTonal).toString(), [new ZeroTonal(), new FreeTonalX(), new FreeTonalZ()]);\n    }\n    get(key) {\n        let value = this.o.get(key);\n        if (value) {\n            return value;\n        }\n        return [];\n    }\n}\nexports.uncombiningRulesAy = new UncombiningRulesAy();\nexports.voiceless_voiced_finals = new Map()\n    .set(TonalLetterTags.k, TonalLetterTags.g)\n    .set(TonalLetterTags.p, TonalLetterTags.b)\n    .set(TonalLetterTags.t, TonalLetterTags.l)\n    .set(TonalLetterTags.kk, TonalLetterTags.gg)\n    .set(TonalLetterTags.pp, TonalLetterTags.bb)\n    .set(TonalLetterTags.tt, TonalLetterTags.ll);\n// .set(TonalLetterTags.g, TonalLetterTags.k)\n// .set(TonalLetterTags.b, TonalLetterTags.p)\n// .set(TonalLetterTags.l, TonalLetterTags.t)\n// .set(TonalLetterTags.gg, TonalLetterTags.kk)\n// .set(TonalLetterTags.bb, TonalLetterTags.pp)\n// .set(TonalLetterTags.ll, TonalLetterTags.tt);\nexports.assimilatedFinals = new Map()\n    .set(TonalLetterTags.t + TonalLetterTags.p, TonalLetterTags.p)\n    .set(TonalLetterTags.t + TonalLetterTags.v, TonalLetterTags.p)\n    .set(TonalLetterTags.t + TonalLetterTags.k, TonalLetterTags.k)\n    .set(TonalLetterTags.t + TonalLetterTags.q, TonalLetterTags.k)\n    .set(TonalLetterTags.t + TonalLetterTags.m, TonalLetterTags.h)\n    .set(TonalLetterTags.t + TonalLetterTags.n, TonalLetterTags.h)\n    .set(TonalLetterTags.t + TonalLetterTags.ng, TonalLetterTags.h)\n    .set(TonalLetterTags.tt + TonalLetterTags.p, TonalLetterTags.pp)\n    .set(TonalLetterTags.tt + TonalLetterTags.v, TonalLetterTags.pp)\n    .set(TonalLetterTags.tt + TonalLetterTags.k, TonalLetterTags.kk)\n    .set(TonalLetterTags.tt + TonalLetterTags.q, TonalLetterTags.kk)\n    .set(TonalLetterTags.tt + TonalLetterTags.m, TonalLetterTags.hh)\n    .set(TonalLetterTags.tt + TonalLetterTags.n, TonalLetterTags.hh)\n    .set(TonalLetterTags.tt + TonalLetterTags.ng, TonalLetterTags.hh);\n//# sourceMappingURL=version2.js.map","import { useReducer } from 'react';\n\nimport {\n    TonalInflector,\n    TonalCombiningForms,\n    TonalDesinenceInflection,\n    TonalLemmatizationAnalyzer,\n    Client\n} from 'taipa';\n\nclass Segment {\n    literal: string = '';\n\n    constructor(str: string) {\n        this.literal = str;\n    }\n\n    isBaseForm(str: string) {\n        if (str === this.literal) return true;\n        return false;\n    }\n\n    isProceedingForm(str: string) {\n        const infl = new TonalInflector();\n        const lx = infl.inflect(this.literal, new TonalCombiningForms(), new TonalDesinenceInflection());\n        if (lx.getProceedingForms().filter(x => x.literal === str).length > 0) return true;\n        return false;\n    }\n\n    includes(str: string) {\n        if (this.isBaseForm(str) || this.isProceedingForm(str)) return true;\n        return false;\n    }\n}\n\nconst pah = new Segment('pah');\nconst jiz = new Segment('jiz');\nconst sek = new Segment('sek');\n\nconst opt1 = ['type'];\nconst opt2 = ['daizgiy', 'kana'];\nconst opt3 = ['blue', 'green', 'red'];\n\nconst segments = [\n    {\n        segment: pah,\n        options: opt1\n    },\n    {\n        segment: jiz,\n        options: opt2\n    },\n    {\n        segment: sek,\n        options: opt3\n    }\n];\n\nconst cli = new Client();\n\nfunction getSeqs(alphabet: string, str: string) {\n    if (alphabet == opt2[1]) {\n        const ta = cli.processKana(str);\n        return ta.blockSequences.filter(x => x.length > 0);\n    } else if (alphabet == opt2[0]) {\n        const ta = cli.processTonal(str);\n        return ta.word.syllables.flatMap(x => x.literal);\n    }\n    return [];\n}\n\nlet seqs: string[] = []; // output sequences\nlet alphabet = '';\nlet fcolor = {}; // font color\n\nconst ti = new TonalInflector();\nconst lx1 = ti.inflect(segments[0].segment.literal, new TonalCombiningForms(), new TonalDesinenceInflection());\nconst lx2 = ti.inflect(segments[1].segment.literal, new TonalCombiningForms(), new TonalDesinenceInflection());\nconst candidates = [\n    lx1.word.literal,\n    lx1.getProceedingForms()[1].literal + lx2.word.literal,\n    lx1.getProceedingForms()[1].literal + lx2.getProceedingForms()[0].literal + segments[2].segment.literal\n];\n\nfunction CompositionPage() {\n    const [input, setInput] = useReducer((state: any, newState: any) => ({ ...state, ...newState }), {\n        scanned: '',\n        selected: '',\n        typed: ''\n    });\n\n    const handleChange = function(e: React.ChangeEvent<HTMLInputElement>) {\n        const name = e.target.name;\n        const value = e.target.value;\n        setInput({ [name]: value });\n    };\n\n    let segNo: number = -1; // no. of segment\n    let combinedSegNo: number = -1; // no. of combined segments\n    let optNo = -1; // which radio button and input field to be displayed\n\n    const tl = new TonalLemmatizationAnalyzer();\n    const mphs = tl.morphAnalyze(input.scanned);\n    const len = mphs.length;\n\n    if (mphs) {\n        for (let i = 0; i < mphs.length; i++) {\n            if (mphs[i] && segments[i]) {\n                if (\n                    (i < segments.length - 1 && segments[i].segment.isProceedingForm(mphs[i].syllable.literal)) ||\n                    (i == segments.length - 1 && segments[i].segment.isBaseForm(mphs[i].syllable.literal))\n                ) {\n                    combinedSegNo = i;\n                } else {\n                    break;\n                }\n            }\n        }\n    }\n\n    for (let i = 0; i < segments.length; i++) {\n        if (mphs && mphs[i] && segments[i]) {\n            if (segments[i].segment.includes(mphs[i].syllable.literal)) {\n                segNo = i;\n            }\n        }\n    }\n\n    let options: string[] = [];\n\n    if (segNo >= 0) {\n        if (combinedSegNo < segNo) {\n            options = segments[combinedSegNo + 1].options;\n            optNo = combinedSegNo + 1;\n        } else {\n            options = segments[segNo].options;\n            optNo = segNo;\n        }\n    }\n\n    if (opt2.filter(x => x.includes(input.selected)).length > 0) {\n        alphabet = input.selected;\n        seqs = getSeqs(alphabet, input.typed);\n    } else {\n        seqs = getSeqs(alphabet, input.typed);\n    }\n\n    if (opt3.filter(x => x.includes(input.selected)).length > 0) {\n        const str: string = input.selected;\n        fcolor = { color: str };\n    }\n\n    return (\n        <div>\n            <input type=\"text\" list=\"words\" value={input.scanned} name=\"scanned\" onChange={handleChange} />\n            <datalist id=\"words\">\n                {candidates.map(item => (\n                    <option key={item} value={item} />\n                ))}\n            </datalist>\n            <br />\n            <div>\n                {options.map((checked_opt, i) => (\n                    <div key={i}>\n                        <input\n                            type=\"radio\"\n                            checked={input.selected === checked_opt}\n                            name=\"selected\"\n                            onChange={handleChange}\n                            value={checked_opt}\n                        />\n                        {checked_opt}\n                    </div>\n                ))}\n            </div>\n            <div style={fcolor}>\n                {optNo > 0 ? <input type=\"text\" value={input.typed} name=\"typed\" onChange={handleChange} /> : null}\n                {optNo > 0 ? seqs.map(x => <li> {x} </li>) : null}\n            </div>\n        </div>\n    );\n}\n\nexport default CompositionPage;\n","module.exports = dll_ef0ff7c60362f24a921f;"],"mappings":";;;;;;;;;AAAA;;;;;;;;;;;ACAA;;;;;;;;;;;ACAA;;;;;;;;;;;ACAA;;;;;;;;;;;ACAA;;;;;;;;;;;ACAA;;;;;;;;;;;;ACAA;AAAA;AAAA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACJA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACjBA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACdA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACJA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACJA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACJA;AACA;;;;;;;;;;;;ACDA;AACA;;;;;;;;;;;;ACDA;AACA;;;;;;;;;;;;ACDA;AACA;AACA;AACA;;;;;;;;;;;;ACHA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACtBA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACJA;AACA;;;;;;;;;;;;;ACDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACnBA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACJA;AACA;AACA;AACA;;;;;;;;;;;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACNA;AACA;AACA;AACA;;;;;;;;;;;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC7DA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACNA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACLA;AACA;AACA;AACA;;;;;;;;;;;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACPA;AACA;;;;;;;;;;;;ACDA;AACA;AACA;;;;;;;;;;;;ACFA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACLA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACJA;AACA;AACA;;;;;;;;;;;;ACFA;;;;;;;;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACpDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACxCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AClBA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACNA;;;;;;;;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACNA;;;;;;;;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACPA;;;;;;;;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACNA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACXA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACNA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACLA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACLA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACLA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACXA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACRA;;;;;;;;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACVA;AACA;AACA;;;;;;;;;;;;ACFA;AACA;AACA;;;;;;;;;;;;ACFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACrPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACZA;;;;;;;;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC1DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACnEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACvGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACpDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACjFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC/HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AClMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AClSA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACvJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC9FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC3LA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACzGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC5LA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACxPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACzCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC5BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACjGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC/1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC/LA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACzHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACzDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACnHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AChEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AClGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACpDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACnLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACvTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACtEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC/fA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC5TA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACn7CA;AAEA;AACA;AAOA;;;AAGA;AAAA;AACA;AADA;AACA;AAAA;AACA;AACA;;;AACA;AACA;AACA;AACA;;;AAEA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;;;AAEA;AACA;AACA;AACA;;;;;;AAGA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AAFA;AAKA;AACA;AAFA;AAKA;AACA;AAFA;AAMA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAHA;AADA;AAAA;AACA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AALA;AAAA;AAAA;AAAA;AAAA;AAAA;AAFA;AAaA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;ACvLA;;;;A","sourceRoot":""}